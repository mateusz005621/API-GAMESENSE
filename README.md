-- local variables for API functions. any changes to the line below will be lost on re-generation
local assert, bit_band, globals_curtime, globals_tickcount, globals_tickinterval, math_abs, math_floor, math_fmod, math_max, math_min, math_pow, table_remove, unpack, setmetatable = assert, bit.band, globals.curtime, globals.tickcount, globals.tickinterval, math.abs, math.floor, math.fmod, math.max, math.min, math.pow, table.remove, unpack, setmetatable

local type = type

local ffi = require 'ffi'
local vector = require 'vector'
local entity = require 'gamesense/entity'

local jmp_edx = client.find_signature('engine.dll', '\xFF\xE2')

local function vmt_thunk(index, typestring)
	local t = ffi.typeof(typestring)
	return function(instance, ...)
		assert(instance ~= nil)
		if instance then
			return ffi.cast(t, jmp_edx)(instance, ffi.cast('void***', instance)[0][index], ...)
		end
	end
end

local function clamp(val, min_val, max_val)
	return math_max(min_val, math_min(max_val, val))
end

local function anglemod(a)
	return (360 / 65536) * bit_band(math_floor(a * (65536 / 360)), 65535)
end

local function approach_angle(target, value, speed)
	target = anglemod(target)
	value = anglemod(value)

	local delta = target - value

	if speed < 0 then
		speed = -speed
	end

	if delta < -180 then
		delta = delta + 360
	elseif delta > 180 then
		delta = delta - 360
	end

	if delta > speed then
		value = value + speed
	elseif delta < -speed then
		value = value - speed
	else
		value = target
	end

	return value
end

local function normalize_angle(angle)
	while angle > 180 do angle = angle - 360 end
	while angle < -180 do angle = angle + 360 end
	return angle
end

local function angle_diff(dest_angle, src_angle)
	local delta = math_fmod(dest_angle - src_angle, 360)
	if dest_angle > src_angle then
		if delta >= 180 then
			delta = delta - 360
		end
	else
		if delta <= -180 then
			delta = delta + 360
		end
	end
	return delta
end

local function get_smoothed_velocity(min_delta, a, b)
	local delta = a - b
	local delta_length = delta:length()

	if delta_length <= min_delta then
		if -min_delta <= delta_length then
			return a
		else
			local radius = 1 / (delta_length + 1.19209290E-07)
			return b - ((delta * radius) * min_delta)
		end
	else
		local radius = 1 / (delta_length + 1.19209290E-07)
		return b + ((delta * radius) * min_delta)
	end
end

local estimate_abs_velocity = vmt_thunk(144, 'void(__fastcall*)(void*, void*, float*)')

local data = {
	abs_yaw = 0,
	feet_yaw = 0,
	server_feet_yaw = 0,
	desync_exact = 0,
	desync = 0,

	tickbase = { 
		shifting = 0,
		list = (function()
			-- dont mind me, i was having a stroke
			local index, max = { }, 16
			for i=1, max do
				index[#index+1] = 0
				if i == max then
					return index
				end
			end
		end)()
	},

	balance_adjust = {
		updating = false,
		next_update = 0
	}
}

local abs_vel, original_data = ffi.new('float[3]'), data
local stop_to_full_running_fraction, duck_amount, speed = 0, 0, 0
local eye_angles_y, srv_goal_feet_yaw

local function setup_velocity(c)
	local curtime = globals_curtime()
	local tickinterval = globals_tickinterval()

	local local_player = entity.get_local_player()
	local anim_state = local_player:get_anim_state()

	if anim_state.anim_update_timer <= 0.0 then
		stop_to_full_running_fraction, duck_amount, speed = 0, 0, 0
		eye_angles_y, srv_goal_feet_yaw = nil, nil
		data = original_data
		return
	end

	if eye_angles_y == nil or srv_goal_feet_yaw == nil then
		eye_angles_y = anim_state.eye_angles_y
		srv_goal_feet_yaw = anim_state.goal_feet_yaw
	end

	if c.chokedcommands == 0 then
		stop_to_full_running_fraction = anim_state.stop_to_full_running_fraction
		duck_amount = anim_state.duck_amount
		eye_angles_y = anim_state.eye_angles_y

		estimate_abs_velocity(local_player:get_client_entity(), abs_vel)

		local velocity_a = vector(abs_vel[0], abs_vel[1], abs_vel[2])
		local velocity_b = vector(local_player:get_prop('m_vecVelocity'))

		local spd = velocity_a:lengthsqr()

		if spd > math_pow(1.2 * 260, 2) then
			local velocity_normalized = velocity_a:normalized()
			velocity_a = velocity_normalized * (1.2 * 260)
		end

		velocity_a.z = 0
		velocity_b = get_smoothed_velocity(tickinterval * 2000, velocity_a, velocity_b)

		speed = math_min(velocity_b:length(), 260)
	end

	local lower_body = local_player:get_anim_overlay(3)

	local weapon = local_player:get_player_weapon():get_weapon_info()
	local max_movement_speed = weapon and math_max(weapon.flMaxSpeed, 0.001) or 260

	local running_speed = clamp(speed / (max_movement_speed * 0.520), 0, 1)
	local yaw_modifier = (((stop_to_full_running_fraction * -0.3) - 0.2) * running_speed) + 1

	if duck_amount > 0 then
		local ducking_speed = clamp(speed / (max_movement_speed * 0.340), 0, 1)
		yaw_modifier = yaw_modifier + ((duck_amount * ducking_speed) * (0.5 - yaw_modifier))
	end

	srv_goal_feet_yaw = clamp(srv_goal_feet_yaw, -360, 360)

	local eye_feet_delta = angle_diff(eye_angles_y, srv_goal_feet_yaw)
	local max_yaw_modifier, min_yaw_modifier = 
		yaw_modifier * 58,
		yaw_modifier * -58

	if eye_feet_delta <= max_yaw_modifier then
		if min_yaw_modifier > eye_feet_delta then
			srv_goal_feet_yaw = math_abs(min_yaw_modifier) + eye_angles_y
		end
	else
		srv_goal_feet_yaw = eye_angles_y - math_abs(max_yaw_modifier)
	end

	if speed > 0.1 then
		srv_goal_feet_yaw = approach_angle(
			eye_angles_y,
			normalize_angle(srv_goal_feet_yaw),
			((stop_to_full_running_fraction * 20) + 30) * tickinterval
		)
	else
		srv_goal_feet_yaw = approach_angle(
			local_player:get_prop('m_flLowerBodyYawTarget'),
			normalize_angle(srv_goal_feet_yaw), 
			tickinterval * 100
		)
	end

	if not data.balance_adjust.updating then
		data.balance_adjust.next_update = curtime + 0.22
	elseif local_player:get_sequence_activity(lower_body.sequence) == 979 then
		if data.balance_adjust.next_update < curtime and lower_body.weight > 0.000 then
			data.balance_adjust.next_update = curtime + 1.1
		end
	end

	if c.chokedcommands == 0 then
		local body_lean = math_abs(angle_diff(anim_state.eye_angles_y, anim_state.goal_feet_yaw))

		data.balance_adjust.updating = 
			anim_state.on_ground and anim_state.m_velocity < 0.1 and
			anim_state.anim_update_timer > 0.0

		data.abs_yaw = anim_state.eye_angles_y
		data.feet_yaw = anim_state.goal_feet_yaw
		data.server_feet_yaw = srv_goal_feet_yaw

		data.desync_exact = angle_diff(srv_goal_feet_yaw, anim_state.goal_feet_yaw)
		data.desync = clamp(data.desync_exact, -body_lean, body_lean)
	end
end

local function net_update()
	local local_player = entity.get_local_player()
	local sim_time = local_player:get_prop('m_flSimulationTime')

	if local_player == nil or sim_time == nil then
		return
	end

	local tick_count = globals_tickcount()
	local shifted = math_max(unpack(data.tickbase.list))

	data.tickbase.shifting = shifted < 0 and math_abs(shifted) or 0
	data.tickbase.list[#data.tickbase.list+1] = sim_time/globals_tickinterval() - tick_count

	table_remove(data.tickbase.list, 1)
end

client.set_event_callback('setup_command', setup_velocity)
client.set_event_callback('net_update_start', net_update)

local this = { }

local ret_thing = function(n, ...)
	local type = { }
	local _arr = { ... }

	for i=1, #_arr do
		type[#type+1] = _arr[i]
	end

	if type[n] == nil then
		return unpack(_arr)
	end

	return type[n]
end

local get_curtime = function(nOffset)
	return globals_curtime() - (nOffset * globals_tickinterval())
end

local weapon_ready = function()
	local target = entity.get_local_player()
	local weapon = target:get_player_weapon()

	if target == nil or weapon == nil then
		return false
	end

	if get_curtime(16) < target:get_prop('m_flNextAttack') then 
		return false
	end

	if get_curtime(0) < weapon:get_prop('m_flNextPrimaryAttack') then
		return false
	end

	return true
end

return {
	approach_angle = function(target, value, speed) return approach_angle(target, value, speed) end,
	angle_diff = function(dest_angle, src_angle) return angle_diff(dest_angle, src_angle) end,
	normalize_angle = function(angle) return normalize_angle(angle) end,

	get_abs_yaw = function() return data.abs_yaw end,
	get_balance_adjust = function() return data.balance_adjust end,
	get_body_yaw = function(n) return ret_thing(n, data.feet_yaw, data.server_feet_yaw) end,
	get_desync = function(n) return ret_thing(n, data.desync, data.desync_exact) end,
	get_tickbase_shifting = function() return data.tickbase.shifting end,
	get_double_tap = function() return weapon_ready() and data.tickbase.shifting > 0 end,

	get_overlap = function(rotation)
		local client, server, lean =
			data.feet_yaw,
			data.server_feet_yaw,
			angle_diff(data.abs_yaw, data.feet_yaw)
	
		if type(rotation) == 'number' then
			local cLean = math_abs(lean)
	
			client = clamp(
				rotation, 
				data.abs_yaw-cLean, data.abs_yaw+cLean
			)
		end
	
		if rotation == true then
			client = data.abs_yaw + lean
		end
	
		local adiff = math_abs(angle_diff(client, server))
	
		return 1 - (adiff / 120 * 1), client
	end
local bit = require "bit"
local M = {}

local shl, shr, band = bit.lshift, bit.rshift, bit.band
local char, byte, gsub, sub, format, concat, tostring, error, pairs = string.char, string.byte, string.gsub, string.sub, string.format, table.concat, tostring, error, pairs

local extract = function(v, from, width)
	return band(shr(v, from), shl(1, width) - 1)
end

local function makeencoder(alphabet)
	local encoder, decoder = {}, {}
	for i=1, 65 do
		local chr = byte(sub(alphabet, i, i)) or 32 -- or " "
		if decoder[chr] ~= nil then
			error("invalid alphabet: duplicate character " .. tostring(chr), 3)
		end
		encoder[i-1] = chr
		decoder[chr] = i-1
	end
	return encoder, decoder
end

local encoders, decoders = {}, {}

encoders["base64"], decoders["base64"] = makeencoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")
encoders["base64url"], decoders["base64url"] = makeencoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")

local alphabet_mt = {
	__index = function(tbl, key)
		if type(key) == "string" and key:len() == 64 or key:len() == 65 then
			-- if key is a valid looking base64 alphabet, try to make an encoder/decoder pair from it
			encoders[key], decoders[key] = makeencoder(key)
			return tbl[key]
		end
	end
}

setmetatable(encoders, alphabet_mt)
setmetatable(decoders, alphabet_mt)

function M.encode(str, encoder)
	encoder = encoders[encoder or "base64"] or error("invalid alphabet specified", 2)

	str = tostring(str)

	local t, k, n = {}, 1, #str
	local lastn = n % 3
	local cache = {}

	for i = 1, n-lastn, 3 do
		local a, b, c = byte(str, i, i+2)
		local v = a*0x10000 + b*0x100 + c
		local s = cache[v]

		if not s then
			s = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[extract(v,0,6)])
			cache[v] = s
		end

		t[k] = s
		k = k + 1
	end

	if lastn == 2 then
		local a, b = byte(str, n-1, n)
		local v = a*0x10000 + b*0x100
		t[k] = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[64])
	elseif lastn == 1 then
		local v = byte(str, n)*0x10000
		t[k] = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[64], encoder[64])
	end

	return concat(t)
end

function M.decode(b64, decoder)
	decoder = decoders[decoder or "base64"] or error("invalid alphabet specified", 2)

	local pattern = "[^%w%+%/%=]"
	if decoder then
		local s62, s63
		for charcode, b64code in pairs(decoder) do
			if b64code == 62 then s62 = charcode
			elseif b64code == 63 then s63 = charcode
			end
		end
		pattern = format("[^%%w%%%s%%%s%%=]", char(s62), char(s63))
	end

	b64 = gsub(tostring(b64), pattern, '')

	local cache = {}
	local t, k = {}, 1
	local n = #b64
	local padding = sub(b64, -2) == "==" and 2 or sub(b64, -1) == "=" and 1 or 0

	for i = 1, padding > 0 and n-4 or n, 4 do
		local a, b, c, d = byte(b64, i, i+3)

		local v0 = a*0x1000000 + b*0x10000 + c*0x100 + d
		local s = cache[v0]
		if not s then
			local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d]
			s = char(extract(v,16,8), extract(v,8,8), extract(v,0,8))
			cache[v0] = s
		end

		t[k] = s
		k = k + 1
	end

	if padding == 1 then
		local a, b, c = byte(b64, n-3, n-1)
		local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40
		t[k] = char(extract(v,16,8), extract(v,8,8))
	elseif padding == 2 then
		local a, b = byte(b64, n-3, n-2)
		local v = decoder[a]*0x40000 + decoder[b]*0x1000
		t[k] = char(extract(v,16,8))
	end
	return concat(t)
end

return M
}
local KF = require("gamesense/nyx_lua_framework")
local ffi = require("ffi")

-- imports
local function vmt_entry(instance, index, type)
	return ffi.cast(type, (ffi.cast("void***", instance)[0])[index])
end

-- instance is bound to the callback as an upvalue
local function vmt_bind(module, interface, index, typestring)
	local instance = client.create_interface(module, interface) or error("invalid interface")
	local success, typeof = pcall(ffi.typeof, typestring)
	if not success then
		error(typeof, 2)
	end
	local fnptr = vmt_entry(instance, index, typeof) or error("invalid vtable")
	return function(...)
		return fnptr(instance, ...)
	end
end

local get_event_data = vmt_bind("inputsystem.dll", "InputSystemVersion001", 21, "const struct {int m_nType, m_nTick, m_nData, m_nData2, m_nData3;}*(__thiscall*)(void*)")
local button_code_to_string = vmt_bind("inputsystem.dll", "InputSystemVersion001", 40, "const char*(__thiscall*)(void*, int)")

local key_state = {}

local event_types = {
	[0] = "IE_ButtonPressed",
	[1] = "IE_ButtonReleased",
	[2] = "IE_ButtonDoubleClicked",
	[3] = "IE_AnalogValueChanged",
	[100] = "IE_FirstSystemEvent",
	[101] = "IE_ControllerInserted",
	[102] = "IE_ControllerUnplugged",
	[103] = "IE_Close",
	[104] = "IE_WindowSizeChanged",
	[105] = "IE_PS_CameraUnplugged",
	[106] = "IE_PS_Move_OutOfView",
	[200] = "IE_FirstUIEvent",
	[201] = "IE_SetCursor",
	[202] = "IE_KeyTyped",
	[203] = "IE_KeyCodeTyped",
	[204] = "IE_InputLanguageChanged",
	[205] = "IE_IMESetWindow",
	[206] = "IE_IMEStartComposition",
	[207] = "IE_IMEComposition",
	[208] = "IE_IMEEndComposition",
	[209] = "IE_IMEShowCandidates",
	[210] = "IE_IMEChangeCandidates",
	[211] = "IE_IMECloseCandidates",
	[212] = "IE_IMERecomputeModes",
	[213] = "IE_OverlayEvent",
	[1000] = "IE_FirstVguiEvent",
	[2000] = "IE_FirstAppEvent",
	[2001] = "IE_EnteredLeftMainWindow" -- if m_nData is 0 it left, if its 1 it entered
}

local reservedTable = {
	'and', 'break', 'do', 'else', 'elseif', 'end',
	'for', 'function', 'goto', 'if', 'in', 'local', 'not', 'or', 'repeat',
	'return', 'then', 'until', 'while', 'continue'
}

local reservedTable2 = {
	'true', 'false', 'nil'
}

local function contains (tab, val)
	for index, value in ipairs(tab) do
		if value == val then
			return true
		end
	end

	return false
end

local stringbyte = string.byte
local stringchar = string.char
local stringsub = string.sub

local function chars(str)
	local strc = {}
	for i = 1, #str do
		table.insert(strc, string.sub(str, i, i))
	end
	return strc
end

local function construct_text(charstr)
	local wordlist = {}
	local temp = ""
	for i=1, #charstr do
		--print(charstr[i])
		local curchar = charstr[i]
		if curchar ~= " " then
			temp = temp..curchar
			--print("CURCHAR: "..curchar)
		else
			table.insert(wordlist, temp.." ")
			--print("INSERTING: "..temp)
			temp = ""
		end
	end

	if temp:len() > 0 then
		table.insert(wordlist, temp)
	end
	return wordlist
end

local function magiclines( str )
	local pos = 1;
	return function()
		if not pos then return nil end
		local  p1, p2 = string.find( str, "\r?\n", pos )
		local line
		if p1 then
			line = str:sub( pos, p1 - 1 )
			pos = p2 + 1
		else
			line = str:sub( pos )
			pos = nil
		end
		return line
	end
end

local last_tick = 0
local last_button = -1
local continues_button = -1

local function get_mousewheel()
	local event_data = get_event_data()
	local state = -1
	if event_data.m_nType == 0 and last_tick ~= event_data.m_nTick then
		state = event_data.m_nData == 112 and 1 or event_data.m_nData == 113 and 0 or -1
		last_tick = event_data.m_nTick
	end
	return state
end

--- @class KeyInput
local KeyInput = {}
local lKeyInputs = {}

--- @return KeyInput
function KeyInput:new()
	local chartable = {}
	return KF.new(self, {chartable = chartable})
end

--- @return void
function KeyInput:__init()
	table.insert(lKeyInputs, self)
end

--- @return void
function KeyInput:capture()
	local event_data = get_event_data()
	local etype = event_types[event_data.m_nType]
	local pressed_key_char = nil
	local pressed_key_int = nil

	if etype == "IE_ButtonPressed" or etype == "IE_ButtonDoubleClicked" then
		pressed_key_char = ffi.string(button_code_to_string(event_data.m_nData))
		pressed_key_int = event_data.m_nData
		if last_tick ~= event_data.m_nTick then
			if pressed_key_int <= 36 and continues_button ~= 83 and continues_button ~= 84 then
				table.insert(self.chartable, pressed_key_char)
			end
			if pressed_key_char == "BACKSPACE" then
				table.remove(self.chartable, #self.chartable)
			end
			last_button = pressed_key_int
		end
		last_tick = event_data.m_nTick
	elseif etype == "IE_ButtonReleased" then
		pressed_key_char = ""
		pressed_key_int = event_data.m_nData
	elseif etype == "IE_KeyCodeTyped" then
		pressed_key_char = ffi.string(button_code_to_string(event_data.m_nData))
		pressed_key_int = event_data.m_nData
		if last_tick ~= event_data.m_nTick then
			if pressed_key_int <= 36 then
				table.insert(self.chartable, pressed_key_char)
			end
			if pressed_key_char == "BACKSPACE" then
				table.remove(self.chartable, #self.chartable)
			end
			continues_button = pressed_key_int
		end
	end

	return etype, pressed_key_char, pressed_key_int
end

KF.class('bob/keyinput', KeyInput)

--- @class Container
local Container = {}
local lContainers = {}

--- @param x number
--- @param y number
--- @param w number
--- @param h number
--- @param outline boolean
--- @param draggable boolean
--- @param resizable boolean
--- @return Container
function Container:new(x, y, w, h, outline, draggable, resizable)
	return KF.new(self, {x=x,y=y,w=w,h=h,outline=outline,draggable=draggable,resizable=resizable,cockblock=false,img=nil})
end

function Container:__init()
	table.insert(lContainers, self)
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
--- @return void
function Container:color(r, g, b, a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

--- @return boolean
function Container:is_inside()
	local mx, my = ui.mouse_position()
	local w, h = (self.x + self.w), (self.y + self.h)

	if mx >= self.x and mx <= w and my >= self.y and my <= h then
		return true
	end
	return false
end

--- @return boolean
function Container:is_inside_resize_element()
	local x, y, w, h = self.x, self.y, self.w, self.h
	if self:is_inside() then
		local btrlx, btrly = x+w-20, y+h-20
		local btrx, btry = x+w, y+h
		local mx, my = ui.mouse_position()

		if mx >= btrlx and mx <= btrx and my >= btrly and my <= btry then
			return true
		end
		return false
	end
	return false
end

--- @return void
function Container:drag()
	local tX, tY = self.x, self.y

	if not ui.is_menu_open() or self.cockblock then
		return tX, tY
	end

	local mouse_down = client.key_state(0x01)
	if mouse_down then
		local X, Y = ui.mouse_position()
		if not self._d then
			if self:is_inside() then
				self.oX, self.oY, self._d = X - self.x, Y - self.y, true
			end
		else
			tX, tY = X - self.oX, Y - self.oY
		end
	else
		self._d = false
	end

	self.x = tX
	self.y = tY
end

--- @param state boolean
--- @return void
function Container:blockResizeAndDrag(state)
	self.cockblock = state or true
end

--- @return void
function Container:resize()
	local mouse_down = client.key_state(0x01)
	if (self:is_inside_resize_element() or self.dragging) and mouse_down and not self.cockblock then
		local x, y, w, h = self.x, self.y, self.w, self.h
		local ax, ay = x+w-10, y+h-10

		local mx, my = ui.mouse_position()
		local addx, addy = mx - ax, my - ay

		--print(ax.. "-"..mx.."="..addx)

		self.w = w + addx
		self.h = h + addy

		self.dragging = self:is_inside_resize_element() and mouse_down
		return
	end
	self.dragging = false
end

--- @param identifier string
--- @return void
function Container:save(identifier)
	local paramTable = {}
	paramTable.x = self.x
	paramTable.y = self.y
	paramTable.w = self.w
	paramTable.h = self.h

	database.write(identifier, paramTable)
end

--- @param identifier string
--- @return void
function Container:load(identifier)
	local paramTable = database.read(identifier) or {}
	self.x = paramTable.x or self.x
	self.y = paramTable.y or self.y
	self.w = paramTable.w or self.w
	self.h = paramTable.h or self.h
end

--- @param type string
--- @param image_path string
--- @param imgw number
--- @param imgh number
--- @return void
function Container:image(type, image_path, imgw, imgh)
	if type == "png" then
		self.img = renderer.load_png(readfile(image_path), imgw, imgh)
	elseif type == "jpg" then
		self.img = renderer.load_jpg(readfile(image_path), imgw, imgh)
	elseif type == "svg" then
		self.img = renderer.load_svg(readfile(image_path), imgw, imgh)
	end
end

--- @param ored number
--- @param ogreen number
--- @param oblue number
--- @param oalpha number
--- @return void
function Container:render(ored, ogreen, oblue, oalpha)
	local x, y, w, h, r, g, b, a = self.x, self.y, self.w, self.h, self.r or 255, self.g or 255, self.b or 255, self.a or 255
	renderer.rectangle(x, y, w, h, r, g, b, a)

	if self.outline then
		renderer.line(x, y, x+w, y, ored, ogreen, oblue, oalpha) -- top
		renderer.line(x, y+h, x+w, y+h, ored, ogreen, oblue, oalpha) -- bot
		renderer.line(x, y, x, y+h, ored, ogreen, oblue, oalpha) --left
		renderer.line(x+w, y, x+w, y+h, ored, ogreen, oblue, oalpha) -- right
	end

	if self.img ~= nil then
		renderer.texture(self.img, x, y, w, h, 255, 255, 255, 255, "r")
	end

	if self.resizable then
		local btrax, btray = x+w-1, y+h-11
		local btrx, btry = x+w-1, y+h-1
		local btrlx, btrly = x+w-11, y+h-1
		renderer.triangle(btrax, btray, btrx, btry, btrlx, btrly, 10, 10, 10, 120)
	end
end

--- @return void
function Container:background()
	if self.resizable then
		self:resize()
	end
	if self.draggable and not self.dragging then
		self:drag()
	end
end

KF.class('bob/container', Container)

--- @class SubContainer
local SubContainer = {}
local lSubContainers = {}

--- @param x number
--- @param y number
--- @param w number
--- @param h number
--- @param outline boolean
--- @param draggable boolean
--- @param resizable boolean
--- @return SubContainer
function SubContainer:new(parent, w, h, outline, draggable, resizable)
	return KF.new(self, {parent=parent,w=w,h=h,outline=outline,draggable=draggable,resizable=resizable,cockblock=false,img=nil})
end

--- @return void
function SubContainer:__init()
	table.insert(lContainers, self)
end

--- @param x number
--- @param y number
--- @return void
function SubContainer:offset(x, y)
	self.ox = x
	self.oy = y
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
--- @return void
function SubContainer:color(r, g, b, a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

--- @return boolean
function SubContainer:is_inside()
	local mx, my = ui.mouse_position()
	local w, h = (self.x + self.w), (self.y + self.h)

	if mx >= self.x and mx <= w and my >= self.y and my <= h then
		return true
	end
	return false
end

--- @return boolean
function SubContainer:is_inside_resize_element()
	local x, y, w, h = self.x, self.y, self.w, self.h
	if self:is_inside() then
		local btrlx, btrly = x+w-20, y+h-20
		local btrx, btry = x+w, y+h
		local mx, my = ui.mouse_position()

		if mx >= btrlx and mx <= btrx and my >= btrly and my <= btry then
			return true
		end
		return false
	end
	return false
end

--- @return void
function SubContainer:drag()
	local tX, tY = self.x, self.y

	if not ui.is_menu_open() or self.cockblock then
		return tX, tY
	end

	local mouse_down = client.key_state(0x01)
	if mouse_down then
		local X, Y = ui.mouse_position()
		if not self._d then
			if self:is_inside() then
				self.oX, self.oY, self._d = X - self.x, Y - self.y, true
			end
		else
			tX, tY = X - self.oX, Y - self.oY
		end
	else
		self._d = false
	end

	self.x = tX
	self.y = tY
end

--- @param state boolean
--- @return void
function SubContainer:blockResizeAndDrag(state)
	self.cockblock = state or true
end

--- @return void
function SubContainer:resize()
	local mouse_down = client.key_state(0x01)
	if (self:is_inside_resize_element() or self.dragging) and mouse_down and not self.cockblock then
		local x, y, w, h = self.x, self.y, self.w, self.h
		local ax, ay = x+w-10, y+h-10

		local mx, my = ui.mouse_position()
		local addx, addy = mx - ax, my - ay

		self.w = w + addx
		self.h = h + addy

		self.dragging = self:is_inside_resize_element() and mouse_down
		return
	end
	self.dragging = false
end

--- @param identifier string
--- @return void
function SubContainer:save(identifier)
	local paramTable = {}
	paramTable.x = self.x
	paramTable.y = self.y
	paramTable.w = self.w
	paramTable.h = self.h

	database.write(identifier, paramTable)
end

--- @param identifier string
--- @return void
function SubContainer:load(identifier)
	local paramTable = database.read(identifier) or {}
	self.x = paramTable.x or self.x
	self.y = paramTable.y or self.y
	self.w = paramTable.w or self.w
	self.h = paramTable.h or self.h
end

--- @param type string
--- @param image_path string
--- @param imgw number
--- @param imgh number
--- @return void
function SubContainer:image(type, image_path, imgw, imgh)
	if type == "png" then
		self.img = renderer.load_png(readfile(image_path), imgw, imgh)
	elseif type == "jpg" then
		self.img = renderer.load_jpg(readfile(image_path), imgw, imgh)
	elseif type == "svg" then
		self.img = renderer.load_svg(readfile(image_path), imgw, imgh)
	end
end

--- @return void
function SubContainer:background()
	if self.resizable then
		self:resize()
	end
	if self.draggable and not self.dragging then
		self:drag()
	end
end

--- @return void
function SubContainer:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy
end

--- @return void
function SubContainer:normalize()
	if self.parent.h < (self.oy/#lSubContainers) * #lSubContainers-1 then
		self.parent.h = (self.oy/#lSubContainers) * #lSubContainers-1
	end

	if self.parent.w <= self.w + 5 then
		self.parent.w = self.w + 15
	end

	if self.w > self.parent.w then
		self.w = self.parent.w
	end

	if self.h > self.parent.h then
		self.h = self.parent.h
	end
end

--- @param ored number
--- @param ogreen number
--- @param oblue number
--- @param oalpha number
--- @return void
function SubContainer:render(ored, ogreen, oblue, oalpha)
	self:normalize()
	self:update()
	local x, y, w, h, r, g, b, a = self.x, self.y, self.w, self.h, self.r or 255, self.g or 255, self.b or 255, self.a or 255
	renderer.rectangle(x, y, w, h, r, g, b, a)

	if self.outline then
		renderer.line(x, y, x+w, y, ored, ogreen, oblue, oalpha) -- top
		renderer.line(x, y+h, x+w, y+h, ored, ogreen, oblue, oalpha) -- bot
		renderer.line(x, y, x, y+h, ored, ogreen, oblue, oalpha) --left
		renderer.line(x+w, y, x+w, y+h, ored, ogreen, oblue, oalpha) -- right
	end

	if self.img ~= nil then
		renderer.texture(self.img, x, y, w, h, 255, 255, 255, 255, "r")
	end

	if self.resizable then
		local btrax, btray = x+w-1, y+h-11
		local btrx, btry = x+w-1, y+h-1
		local btrlx, btrly = x+w-11, y+h-1
		renderer.triangle(btrax, btray, btrx, btry, btrlx, btrly, 10, 10, 10, 120)
	end
end

KF.class('bob/subcontainer', SubContainer)

--- @class Slider : container
local Slider = {}
local lSliders = {}

--- @param parent Container|SubContainer
--- @param w number
--- @param h number
--- @param header string
--- @param percentage number
--- @param slider_text string
--- @param minPadding number
--- @param center_text boolean
--- @return Slider
function Slider:new(parent, w, h, header, percentage, slider_text, minPadding, absolute, center_text)
	local center_text = center_text or false
	return KF.new(self, {parent = parent, w = w, h = h, header = header, percentage = percentage, slider_text = slider_text, minPadding = minPadding, x = parent.x, y = parent.y, absolute = absolute, center_text=center_text, ox=0, oy=0})
end

function Slider:__init()
	table.insert(lSliders, self)
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
function Slider:color(r, g, b, a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

--- @param x number
--- @param y number
function Slider:offset(x, y)
	self.ox = x
	self.oy = y
end

--- @return void
function Slider:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy + self.minPadding

	if self.absolute == false then
		self.w = self.parent.w - self.ox*2
	end
end

--- @return void
function Slider:normalize()
	local header_length, height = renderer.measure_text("c", self.header)

	if self.parent.h < (self.oy/#lSliders) + self.minPadding * #lSliders-1 then
		self.parent.h = (self.oy/#lSliders) + (self.minPadding) * #lSliders-1
	end

	if self.parent.w <= header_length + 5 then
		self.parent.w = header_length + 15
	end

	if self.w > self.parent.w then
		self.w = self.parent.w
	end

	if self.h > self.parent.h then
		self.h = self.parent.h
	end
end

--- @param percentage number
--- @param slider_text string
--- @return void
function Slider:override_percentage(percentage, slider_text)
	self.percentage = percentage
	self.slider_text = slider_text
end

--- @param identifier string
--- @return void
function Slider:save(identifier)
	local paramTable = {}
	paramTable.x = self.x
	paramTable.y = self.y
	paramTable.w = self.w
	paramTable.h = self.h

	database.write(identifier, paramTable)
end

--- @param identifier string
--- @return void
function Slider:load(identifier)
	local paramTable = database.read(identifier) or {}
	self.x = paramTable.x or self.x
	self.y = paramTable.y or self.y
	self.w = paramTable.w or self.w
	self.h = paramTable.h or self.h
end

--- @return void
function Slider:render()
	self:update()
	self:normalize()
	if self.center_text then
		renderer.text(self.x + (self.w/2), self.y - 10, 255, 255, 255, 255, "c", 0, self.header)
	else
		renderer.text(self.x, self.y - 15, 255, 255, 255, 255, "", 0, self.header)
	end
	renderer.rectangle(self.x - 2, self.y - 2, self.w + 2, self.h + 4, 10, 10, 10, 110)
	renderer.rectangle(self.x, self.y, (self.w / 100 * self.percentage - 2), self.h, self.r, self.g, self.b, self.a)
	renderer.text(self.x + self.w / 2 + 2, self.y + 4, 255, 255, 255, 110, "c", 0, string.format("%s", self.slider_text))
end

KF.class('bob/slider', Slider)

--- @class InputBox
local InputBox = {}
local lInputBoxes = {}

--- @param parent Container|SubContainer
--- @param w number
--- @param h number
--- @param minPadding number
--- @param header string
--- @param adaptive boolean
--- @return InputBox
function InputBox:new(parent, w, h, minPadding, header, adaptive)
	return KF.new(self, {parent=parent, w=w, h=h, minPadding=minPadding,header=header,adaptive=adaptive, ox=0, oy=0, inputHandler=KeyInput:new(), isActive=false})
end

--- @return void
function InputBox:__init()
	table.insert(lInputBoxes, self)
end

--- @param x number
--- @param y number
--- @return void
function InputBox:offset(x, y)
	self.ox = x
	self.oy = y
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
function InputBox:color(r,g,b,a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

--- @return void
function InputBox:normalize()
	if self.parent.h < (self.oy/#lInputBoxes) + self.minPadding * #lInputBoxes-1 then
		self.parent.h = (self.oy/#lInputBoxes) + self.minPadding * #lInputBoxes-1
	end

	if self.parent.w <= self.w + 5 then
		self.parent.w = self.w + 15
	end

	if self.w > self.parent.w then
		self.w = self.parent.w
	end

	if self.h > self.parent.h then
		self.h = self.parent.h
	end
end

--- @return boolean
function InputBox:is_inside()
	local mx, my = ui.mouse_position()
	local w, h = (self.x + self.w), (self.y + self.h)

	if mx >= self.x and mx <= w and my >= self.y and my <= h then
		return true
	end
	return false
end

--- @return void
function InputBox:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy + self.minPadding
	self:shouldType()
	if self.isActive then
		self.inputHandler:capture()
	end
	self.content = self.inputHandler.chartable
end

--- @return boolean
function InputBox:shouldType()
	if not ui.is_menu_open() then
		self.isActive = false
		return
	end

	local mouse_down = client.key_state(0x01)
	if mouse_down then
		if self:is_inside() then
			self.isActive = true
		else
			self.isActive = false
		end
	end
end

--- @param identifier string
--- @return void
function InputBox:save(identifier)
	local paramTable = {}
	paramTable.x = self.x
	paramTable.y = self.y
	paramTable.w = self.w
	paramTable.h = self.h

	database.write(identifier, paramTable)
end

--- @param identifier string
--- @return void
function InputBox:load(identifier)
	local paramTable = database.read(identifier) or {}
	self.x = paramTable.x or self.x
	self.y = paramTable.y or self.y
	self.w = paramTable.w or self.w
	self.h = paramTable.h or self.h
end

--- @return void
function InputBox:render()
	self:update()
	self:normalize()

	local content = table.concat(self.content, "")

	renderer.text(self.x, self.y - 15, 255, 255, 255, 255, "", 0, self.header)
	renderer.rectangle(self.x - 2, self.y - 2, self.w + 4, self.h + 4, 10, 10, 10, 110)
	renderer.rectangle(self.x, self.y, self.w, self.h, self.r, self.g, self.b, self.a)
	renderer.text(self.x + 2, self.y + 4, 255, 255, 255, 255, "", self.w, content)
end

KF.class('bob/inputbox', InputBox)

--- @class Button
local Button = {}
local lButtons = {}

--- @param parent Container|SubContainer
--- @param w number
--- @param h number
--- @param minPadding number
--- @param text string
--- @param callback function
--- @param togglable boolean
--- @return Button
function Button:new(parent, w, h, minPadding, text, callback, togglable)
	return KF.new(self, {parent=parent,w=w,h=h,minPadding=minPadding,text=text, callback=callback, ran=false,toggled=false, togglable=togglable})
end

--- @return void
function Button:__init()
	table.insert(lButtons, self)
end

--- @param x number
--- @param y number
--- @return void
function Button:offset(x, y)
	self.ox = x
	self.oy = y
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
function Button:color(r,g,b,a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
function Button:click_color(r,g,b,a)
	self.cr = r
	self.cg = g
	self.cb = b
	self.ca = a
end

function Button:active_color(r,g,b,a)
	self.tr = r
	self.tg = g
	self.tb = b
	self.ta = a
end

--- @return void
function Button:normalize()
	if self.parent.h < (self.oy) + self.minPadding * #lButtons-1 then
		self.parent.h = (self.oy) + self.minPadding * #lButtons-1
	end

	if self.parent.w <= self.w + self.ox + 5 then
		self.parent.w = self.w + self.ox + 10
	end

	if self.w > self.parent.w then
		self.w = self.parent.w
	end

	if self.h > self.parent.h then
		self.h = self.parent.h
	end
end

--- @return boolean
function Button:is_inside()
	local mx, my = ui.mouse_position()
	local w, h = (self.x + self.w), (self.y + self.h)

	if mx >= self.x and mx <= w and my >= self.y and my <= h then
		return true
	end
	return false
end

--- @return void
function Button:on_press()
	if not self.ran then
		self.ran = true
		self.toggled = not self.toggled
		self.callback()
	end
end

--- @return void
function Button:handle_clicks()
	local mouse_down = client.key_state(0x01)

	if not mouse_down then
		self.ran = false
	end

	self.clicking = mouse_down
	if self:is_inside() and mouse_down then
		self:on_press()
	else
		self.clicking = false
	end
end

--- @return void
function Button:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy + self.minPadding

	self:handle_clicks()


	if self.clicking then
		self.ar = self.cr or self.r
		self.ag = self.cg or self.g
		self.ab = self.cb or self.b
		self.aa = self.ca or self.a
	else
		self.ar = self.toggled and self.tr or self.r
		self.ag = self.toggled and self.tg or self.g
		self.ab = self.toggled and self.tb or self.b
		self.aa = self.toggled and self.ta or self.a
	end
end

--- @param identifier string
--- @return void
function Button:save(identifier)
	local paramTable = {}
	paramTable.x = self.x
	paramTable.y = self.y
	paramTable.w = self.w
	paramTable.h = self.h

	database.write(identifier, paramTable)
end

--- @param identifier string
--- @return void
function Button:load(identifier)
	local paramTable = database.read(identifier) or {}
	self.x = paramTable.x or self.x
	self.y = paramTable.y or self.y
	self.w = paramTable.w or self.w
	self.h = paramTable.h or self.h
end

--- @return void
function Button:render()
	self:update()
	self:normalize()

	renderer.rectangle(self.x - 2, self.y - 2, self.w + 4, self.h + 4, 10, 10, 10, 110)
	renderer.rectangle(self.x, self.y, self.w, self.h, self.ar, self.ag, self.ab, self.aa)
	renderer.text(self.x + (self.w / 2), self.y + (self.h / 2), 255, 255, 255, 255, "c", self.w, self.text)
end

KF.class('bob/button', Button)

--- @class Label
local Label = {}
local lLabels = {}

--- @param parent Container|SubContainer
--- @param flags string
--- @param maxwidth number
--- @param text string
--- @param minPadding number
--- @return Label
function Label:new(parent, flags, maxwidth, text, minPadding)
	return KF.new(self, {parent=parent, flags=flags, maxwidth=maxwidth, text=text, minPadding=minPadding})
end

--- @return void
function Label:__init()
	table.insert(self, lLabels)
end

--- @param x number
--- @param y number
--- @return void
function Label:offset(x, y)
	self.ox = x
	self.oy = y
end

--- @param r number
--- @param g number
--- @param b number
--- @param a number
--- @return void
function Label:color(r, g, b, a)
	self.r = r
	self.g = g
	self.b = b
	self.a = a
end

function Label:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy
end

--- @return void
function Label:normalize()
	local text_width, text_height = renderer.measure_text(self.flags, self.text)
	if self.parent.h < (self.oy/#lLabels) + self.minPadding * #lLabels-1 then
		self.parent.h = (self.oy/#lLabels) + self.minPadding * #lLabels-1
	elseif self.parent.h < text_height then
		self.parent.h = text_height + 5
	end

	if self.parent.w <= text_width + 5 then
		self.parent.w = text_width + 15
	end
end

--- @return void
function Label:render()
	self:update()
	--self:normalize()
	renderer.text(self.x, self.y, self.r, self.g, self.b, self.a, self.flags, self.maxwidth, self.text)
end

KF.class('bob/label', Label)


--- @class Image
local Image = {}
local lImages = {}

--- @param parent Container|SubContainer
--- @param w number
--- @param h number
--- @param minPadding number
--- @param text string
--- @param callback function
--- @return Button
function Image:new(parent, w, h, minPadding, type, imgpath)
	return KF.new(self, {parent=parent,w=w,h=h,minPadding=minPadding,type=type,image_path=imgpath, img=nil})
end

--- @return void
function Image:__init()
	if self.type == "png" then
		self.img = renderer.load_png(readfile(self.image_path), self.w, self.h)
	elseif self.type == "jpg" then
		self.img = renderer.load_jpg(readfile(self.image_path), self.w, self.h)
	elseif self.type == "svg" then
		self.img = renderer.load_svg(readfile(self.image_path), self.w, self.h)
	end
	table.insert(lImages, self)
end

--- @param x number
--- @param y number
--- @return void
function Image:offset(x, y)
	self.ox = x
	self.oy = y
end

function Image:update()
	self.x = self.parent.x + self.ox
	self.y = self.parent.y + self.oy
end

--- @return void
function Image:normalize()
	if self.parent.h < (self.oy/#lImages) + self.minPadding * #lImages-1 then
		self.parent.h = (self.oy/#lImages) + self.minPadding * #lImages-1
	end

	if self.parent.w <= self.w + 5 then
		self.parent.w = self.w + 15
	end

	if self.w > self.parent.w then
		self.w = self.parent.w
	end

	if self.h > self.parent.h then
		self.h = self.parent.h
	end
end

--- @return void
function Image:render()
	self:update()
	self:normalize()
	renderer.texture(self.img, self.x, self.y, self.w, self.h, 255, 255, 255, 255, "f")
end

KF.class('bob/image', Image)

--- @class Editor
local Editor = {}
local lEditors = {}

--- @field parent Container
--- @field compact boolean
--- @field showlines boolean
--- @field cursor boolean
--- @field context_menu boolean
--- @field executable boolean
--- @field syntax_highlight boolean
--- @return Editor
function Editor:new(parent, compact, showlines, cursor, context_menu, executable, syntax_highlight)
	return KF.new(self, {parent=parent, compact=compact, showlines=showlines, cursor=cursor, context_menu=context_menu, executable=executable, syntax_highlight=syntax_highlight, content={}})
end

--- @return void
function Editor:__init()
	table.insert(lEditors, self)
end

--- @return void
function Editor:loadfile(file_name)
	for line in magiclines(readfile(file_name)) do
		table.insert(self.content, line)
	end
end

--- @return void
function Editor:render()
	local x, y, w, h = self.parent.x, self.parent.y, self.parent.w, self.parent.h

	local char_length, char_height = renderer.measure_text("", "A")
	local space_length = renderer.measure_text("", " ")
	local lines_total = h / char_height - 1


	renderer.line(x + 30, y + 1, x + 30, y+h - 1, 60, 60, 60, 120)
	for i=1, lines_total do
		i = i-1
		renderer.text(x + 2, y + char_height*i + 1, 60, 60, 60, 120, "", 0, i+1)

		local pad = 0
		local text = self.content[i+1] or ""
		local iterator = 1

		local noob = chars(text)
		local constrtext = construct_text(noob)

		for a=1, #constrtext do
			local word = constrtext[a]
			--print(word)
			local r,g,b = 255, 255, 255
			local cleanword = string.match(word, "%w+")
			local text_length = renderer.measure_text("", word)

			if contains(reservedTable, word) or contains(reservedTable, cleanword) then
				r, g, b = 244, 161, 255
				renderer.text(x + 34 + pad, y + char_height*i + 2, r, g, b, 255, "", 0, word)
			elseif contains(reservedTable2, word) or contains(reservedTable2, cleanword) then
				r, g, b = 3, 202, 252
				renderer.text(x + 34 + pad, y + char_height*i + 2, r, g, b, 255, "", 0, word)
			end

			renderer.text(x + 34 + pad, y + char_height*i + 2, r, g, b, 255, "", 0, word)
			pad = pad + text_length + space_length
			iterator = iterator + 1
		end
	end
end

KF.class('bob/editor', Editor)

--[[
local uffja = Container:new(400, 400, 200, 200, true, true, true)
uffja:color(10, 10, 10, 110)

local gayslider = Slider:new(uffja, 100, 10, "GAY", 80, "yeah", 35, false)
gaySlider:color(255, 0, 0, 255)
gaySlider:offset(5, 0)
client.set_event_callback("paint", function ()
	uffja:background()
	uffja:render(255, 0, 0, 255)
	gaySlider:render()
end)
]]--

return {
	Container = Container,
	SubContainer = SubContainer,
	Slider = Slider,
	Editor = Editor,
	KeyInput = KeyInput,
	InputBox = InputBox,
	Button = Button,
	Label = Label,
	Image = Image,

	lContainers = lContainers,
	lSubContainers = lSubContainers,
	lSliders = lSliders,
	lEditors = lEditors,
	lKeyInput = lKeyInputs,
	lInputBoxes = lInputBoxes,
	lButtons = lButtons,
	lLabels = lLabels,
	lImages = lImages,
}
local ffi = require "ffi"
local gsub, pairs = string.gsub, pairs

local replacements = {
	["{white}"] = "\x01",
	["{darkred}"] = "\x02",
	["{team}"] = "\x03",
	["{green}"] = "\x04",
	["{lightgreen}"] = "\x05",
	["{lime}"] = "\x06",
	["{red}"] = "\x07",
	["{grey}"] = "\x08",
	["{yellow}"] = "\x09",
	["{bluegrey}"] = "\x0A",
	["{blue}"] = "\x0B",
	["{darkblue}"] = "\x0C",
	["{purple}"] = "\x0D",
	["{violet}"] = "\x0E",
	["{lightred}"] = "\x0F",
	["{orange}"] = "\x10",
	["\u{202E}"] = "",
	["\u{2029}"] = "",
	["  +"] = function(c)
		return " " .. ("\x18 "):rep(c:len()-1)
	end
}

local function find_sig(mdlname, pattern, typename, offset, deref_count)
	local raw_match = client.find_signature(mdlname, pattern) or error("signature not found", 2)
	local match = ffi.cast("uintptr_t", raw_match)

	if offset ~= nil and offset ~= 0 then
		match = match + offset
	end

	if deref_count ~= nil then
		for i = 1, deref_count do
			match = ffi.cast("uintptr_t*", match)[0]
			if match == nil then
				return error("signature not found", 2)
			end
		end
	end

	return ffi.cast(typename, match)
end

local function table_concat_tostring(tbl, sep)
	local result = ""
	for i=1, #tbl do
		result = result .. tostring(tbl[i]) .. (i == #tbl and "" or sep)
	end
	return result
end

local hud = find_sig("client.dll", "\xB9\xCC\xCC\xCC\xCC\x88\x46\x09", "void*", 1, 1)

local native_FindHudElement = find_sig("client.dll", "\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x57\x8B\xF9\x33\xF6\x39\x77\x28", "void***(__thiscall*)(void*, const char*)")
local native_ChatPrintf = vtable_thunk(27, "void(__cdecl*)(void*, int, int, const char*, ...)")

-- thisptr for native_ChatPrintf
local hud_chat = native_FindHudElement(hud, "CHudChat")

local function print_player(entindex, ...)
	local text = table_concat_tostring(entindex == 0 and {" ", ...} or {...}, "")

	for res, rep in pairs(replacements) do
		text = gsub(text, res, rep)
	end

	native_ChatPrintf(hud_chat, entindex, 0, text)
end

return {
	print = function(...)
		return print_player(0, ...)
	end,
	print_player = print_player
}
--
-- dependencies
--

local ffi = require "ffi"
local string_len, tostring, ffi_string = string.len, tostring, ffi.string

--
-- our module
--

local M = {}

--
-- game funcs (https://github.com/perilouswithadollarsign/cstrike15_src/blob/master/public/vgui/ISystem.h)
--

local native_GetClipboardTextCount = vtable_bind("vgui2.dll", "VGUI_System010", 7, "int(__thiscall*)(void*)")
local native_SetClipboardText = vtable_bind("vgui2.dll", "VGUI_System010", 9, "void(__thiscall*)(void*, const char*, int)")
local native_GetClipboardText = vtable_bind("vgui2.dll", "VGUI_System010", 11, "int(__thiscall*)(void*, int, const char*, int)")

local new_char_arr = ffi.typeof("char[?]")

-- returns (pastes) clipboard text
function M.get()
	local len = native_GetClipboardTextCount()

	if len > 0 then
		local char_arr = new_char_arr(len)
		native_GetClipboardText(0, char_arr, len)
		return ffi_string(char_arr, len-1)
	end
end
M.paste = M.get

-- sets (copies) the clipboard text
function M.set(text)
	text = tostring(text)

	native_SetClipboardText(text, string_len(text))
end
M.copy = M.set

return M
local ffi = require "ffi"

local CCSWeaponInfo_t = [[
struct {
    char         __pad_0x0000[4];                       // 0x0000
    char*        console_name;                          // 0x0004
    char         __pad_0x0008[12];                      // 0x0008
    int          primary_clip_size;                     // 0x0014
    int          secondary_clip_size;                   // 0x0018
    int          primary_default_clip_size;             // 0x001c
    int          secondary_default_clip_size;           // 0x0020
    int          primary_reserve_ammo_max;              // 0x0024
    int          secondary_reserve_ammo_max;            // 0x0028
    char*        model_world;                           // 0x002c
    char*        model_player;                          // 0x0030
    char*        model_dropped;                         // 0x0034
    char*        sound_empty;                           // 0x0038
    char*        sound_single_shot;                     // 0x003c
    char*        sound_single_shot_accurate;            // 0x0040
    char         __pad_0x0044[12];                      // 0x0044
    char*        sound_burst;                           // 0x0050
    char*        sound_reload;                          // 0x0054
    char         __pad_0x0058[16];                      // 0x0058
    char*        sound_special1;                        // 0x0068
    char*        sound_special2;                        // 0x006c
    char*        sound_special3;                        // 0x0070
    char         __pad_0x0074[4];                       // 0x0074
    char*        sound_nearlyempty;                     // 0x0078
    char         __pad_0x007c[4];                       // 0x007c
    char*        primary_ammo;                          // 0x0080
    char*        secondary_ammo;                        // 0x0084
    char*        item_name;                             // 0x0088
    char*        item_class;                            // 0x008c
    bool         itemflag_exhaustible;                  // 0x0090
    bool         model_right_handed;                    // 0x0091
    bool         is_melee_weapon;                       // 0x0092
    char         __pad_0x0093[9];                       // 0x0093
    int          weapon_weight;                         // 0x009c
    char         __pad_0x00a0[8];                       // 0x00a0
    int          item_gear_slot_position;               // 0x00a8
    char         __pad_0x00ac[28];                      // 0x00ac
    int          weapon_type_int;                       // 0x00c8
    char         __pad_0x00cc[4];                       // 0x00cc
    int          in_game_price;                         // 0x00d0
    int          kill_award;                            // 0x00d4
    char*        player_animation_extension;            // 0x00d8
    float        cycletime;                             // 0x00dc
    float        cycletime_alt;                         // 0x00e0
    float        time_to_idle;                          // 0x00e4
    float        idle_interval;                         // 0x00e8
    bool         is_full_auto;                          // 0x00ec
    char         __pad_0x00ed[3];                       // 0x00ed
    int          damage;                                // 0x00f0
    float        armor_ratio;                           // 0x00f4
    int          bullets;                               // 0x00f8
    float        penetration;                           // 0x00fc
    float        flinch_velocity_modifier_large;        // 0x0100
    float        flinch_velocity_modifier_small;        // 0x0104
    float        range;                                 // 0x0108
    float        range_modifier;                        // 0x010c
    float        throw_velocity;                        // 0x0110
    char         __pad_0x0114[12];                      // 0x0114
    int          has_silencer;                          // 0x0120
    char         __pad_0x0124[4];                       // 0x0124
    int          crosshair_min_distance;                // 0x0128
    int          crosshair_delta_distance;              // 0x012c
    float        max_player_speed;                      // 0x0130
    float        max_player_speed_alt;                  // 0x0134
    float        attack_movespeed_factor;               // 0x0138
    float        spread;                                // 0x013c
    float        spread_alt;                            // 0x0140
    float        inaccuracy_crouch;                     // 0x0144
    float        inaccuracy_crouch_alt;                 // 0x0148
    float        inaccuracy_stand;                      // 0x014c
    float        inaccuracy_stand_alt;                  // 0x0150
    float        inaccuracy_jump_initial;               // 0x0154
    float        inaccuracy_jump_apex;                  // 0x0158
    float        inaccuracy_jump;                       // 0x015c
    float        inaccuracy_jump_alt;                   // 0x0160
    float        inaccuracy_land;                       // 0x0164
    float        inaccuracy_land_alt;                   // 0x0168
    float        inaccuracy_ladder;                     // 0x016c
    float        inaccuracy_ladder_alt;                 // 0x0170
    float        inaccuracy_fire;                       // 0x0174
    float        inaccuracy_fire_alt;                   // 0x0178
    float        inaccuracy_move;                       // 0x017c
    float        inaccuracy_move_alt;                   // 0x0180
    float        inaccuracy_reload;                     // 0x0184
    int          recoil_seed;                           // 0x0188
    float        recoil_angle;                          // 0x018c
    float        recoil_angle_alt;                      // 0x0190
    float        recoil_angle_variance;                 // 0x0194
    float        recoil_angle_variance_alt;             // 0x0198
    float        recoil_magnitude;                      // 0x019c
    float        recoil_magnitude_alt;                  // 0x01a0
    float        recoil_magnitude_variance;             // 0x01a4
    float        recoil_magnitude_variance_alt;         // 0x01a8
    int          spread_seed;                           // 0x01ac
    float        recovery_time_crouch;                  // 0x01b0
    float        recovery_time_stand;                   // 0x01b4
    float        recovery_time_crouch_final;            // 0x01b8
    float        recovery_time_stand_final;             // 0x01bc
    int          recovery_transition_start_bullet;      // 0x01c0
    int          recovery_transition_end_bullet;        // 0x01c4
    bool         unzoom_after_shot;                     // 0x01c8
    bool         hide_view_model_zoomed;                // 0x01c9
    char         __pad_0x01ca[2];                       // 0x01ca
    int          zoom_levels;                           // 0x01cc
    int          zoom_fov_1;                            // 0x01d0
    int          zoom_fov_2;                            // 0x01d4
    int          zoom_time_0;                           // 0x01d8
    int          zoom_time_1;                           // 0x01dc
    int          zoom_time_2;                           // 0x01e0
    char*        addon_location;                        // 0x01e4
    char         __pad_0x01e8[4];                       // 0x01e8
    float        addon_scale;                           // 0x01ec
    char*        eject_brass_effect;                    // 0x01f0
    char*        tracer_effect;                         // 0x01f4
    int          tracer_frequency;                      // 0x01f8
    int          tracer_frequency_alt;                  // 0x01fc
    char*        muzzle_flash_effect_1st_person;        // 0x0200
    char*        muzzle_flash_effect_1st_person_alt;    // 0x0204
    char*        muzzle_flash_effect_3rd_person;        // 0x0208
    char*        muzzle_flash_effect_3rd_person_alt;    // 0x020c
    char*        heat_effect;                           // 0x0210
    float        heat_per_shot;                         // 0x0214
    char*        zoom_in_sound;                         // 0x0218
    char*        zoom_out_sound;                        // 0x021c
    char         __pad_0x0220[4];                       // 0x0220
    float        inaccuracy_alt_sound_threshold;        // 0x0224
    float        bot_audible_range;                     // 0x0228
    char         __pad_0x022c[12];                      // 0x022c
    bool         has_burst_mode;                        // 0x0238
    bool         is_revolver;                           // 0x0239
    char         __pad_0x023a[2];                       // 0x023a
}
]]
local struct_keys = {"console_name", "primary_clip_size", "secondary_clip_size", "primary_default_clip_size", "secondary_default_clip_size", "primary_reserve_ammo_max", "secondary_reserve_ammo_max", "model_world", "model_player", "model_dropped", "sound_empty", "sound_single_shot", "sound_single_shot_accurate", "sound_burst", "sound_reload", "sound_special1", "sound_special2", "sound_special3", "sound_nearlyempty", "primary_ammo", "secondary_ammo", "item_name", "item_class", "itemflag_exhaustible", "model_right_handed", "is_melee_weapon", "weapon_weight", "item_gear_slot_position", "weapon_type_int", "in_game_price", "kill_award", "player_animation_extension", "cycletime", "cycletime_alt", "time_to_idle", "idle_interval", "is_full_auto", "damage", "armor_ratio", "bullets", "penetration", "flinch_velocity_modifier_large", "flinch_velocity_modifier_small", "range", "range_modifier", "throw_velocity", "has_silencer", "crosshair_min_distance", "crosshair_delta_distance", "max_player_speed", "max_player_speed_alt", "attack_movespeed_factor", "spread", "spread_alt", "inaccuracy_crouch", "inaccuracy_crouch_alt", "inaccuracy_stand", "inaccuracy_stand_alt", "inaccuracy_jump_initial", "inaccuracy_jump_apex", "inaccuracy_jump", "inaccuracy_jump_alt", "inaccuracy_land", "inaccuracy_land_alt", "inaccuracy_ladder", "inaccuracy_ladder_alt", "inaccuracy_fire", "inaccuracy_fire_alt", "inaccuracy_move", "inaccuracy_move_alt", "inaccuracy_reload", "recoil_seed", "recoil_angle", "recoil_angle_alt", "recoil_angle_variance", "recoil_angle_variance_alt", "recoil_magnitude", "recoil_magnitude_alt", "recoil_magnitude_variance", "recoil_magnitude_variance_alt", "spread_seed", "recovery_time_crouch", "recovery_time_stand", "recovery_time_crouch_final", "recovery_time_stand_final", "recovery_transition_start_bullet", "recovery_transition_end_bullet", "unzoom_after_shot", "hide_view_model_zoomed", "zoom_levels", "zoom_fov_1", "zoom_fov_2", "zoom_time_0", "zoom_time_1", "zoom_time_2", "addon_location", "addon_scale", "eject_brass_effect", "tracer_effect", "tracer_frequency", "tracer_frequency_alt", "muzzle_flash_effect_1st_person", "muzzle_flash_effect_1st_person_alt", "muzzle_flash_effect_3rd_person", "muzzle_flash_effect_3rd_person_alt", "heat_effect", "heat_per_shot", "zoom_in_sound", "zoom_out_sound", "inaccuracy_alt_sound_threshold", "bot_audible_range", "has_burst_mode", "is_revolver"}

local weapon_types = {
	[0] = "knife",
	[1] = "pistol",
	[2] = "smg",
	[3] = "rifle",
	[4] = "shotgun",
	[5] = "sniperrifle",
	[6] = "machinegun",
	[7] = "c4",
	[9] = "grenade",
	[11] = "stackableitem",
	[12] = "fists",
	[13] = "breachcharge",
	[14] = "bumpmine",
	[15] = "tablet",
	[16] = "melee",
	[19] = "equipment"
}

local weapon_types_lookup = {
	[31] = "taser"
}

-- IWeaponSystem
local match = client.find_signature("client_panorama.dll", "\x8B\x35\xCC\xCC\xCC\xCC\xFF\x10\x0F\xB7\xC0") or error("IWeaponSystem signature invalid")
local IWeaponSystem_raw = ffi.cast("void****", ffi.cast("char*", match) + 0x2)[0]

local native_GetCSWeaponInfo = vtable_thunk(2, CCSWeaponInfo_t .. "*(__thiscall*)(void*, unsigned int)") or error("invalid GetCSWeaponInfo index")
local ctype_char = ffi.typeof("char*")

-- Panorama InventoryAPI
local js = panorama.loadstring([[
return {
	get_weapon_info: (idx) => {
		let itemid = InventoryAPI.GetFauxItemIDFromDefAndPaintIndex(idx)

		if(itemid && itemid > 0) {
			return InventoryAPI.BuildItemSchemaDefJSON(itemid)
		} else {
			return "null"
		}
	},
	localize: $.Localize
}
]], "CSGOMainMenu")()

-- generate weapons table
local weapons, weapons_index = {}, {}

for idx=1, 1000 do
	local res = native_GetCSWeaponInfo(IWeaponSystem_raw, idx)

	if res ~= nil then
		local weapon = {}

		-- add all struct values to table
		for i=1, #struct_keys do
			local key = struct_keys[i]
			local val = res[key]

			local ct_success, ct = pcall(ffi.typeof, val)
			if ct_success and ct == ctype_char then
				weapon[key] = ffi.string(val)
			else
				weapon[key] = val
			end
		end

		weapon.idx = idx
		weapon.type = weapon_types_lookup[idx] or weapon_types[res.weapon_type_int]
		weapon.name = js.localize(weapon.item_name)
		weapon.raw = res

		weapon.schema = json.parse(js.get_weapon_info(idx))

		-- add to table
		weapons[idx] = weapon
		weapons_index[weapon.console_name] = weapon
	end
end

local function weapons_get_by_entity(tbl, entindex)
	if tbl ~= weapons or type(entindex) ~= "number" or entindex < 0 or entindex > 8191 then
		return
	end

	local idx = entity.get_prop(entindex, "m_iItemDefinitionIndex")
	return weapons[idx]
end

setmetatable(weapons, {
	__index = weapons_index,
	__metatable = false,
	__call = weapons_get_by_entity
})

return weapons
--// Libraries
local http = require('gamesense/http')

--// RichEmbed object
local RichEmbed = { Properties = {} }

function RichEmbed:setTitle(title) self.Properties.title = title end
function RichEmbed:setDescription(description) self.Properties.description = description end
function RichEmbed:setURL(url) self.Properties.url = url end
function RichEmbed:setTimestamp(timestamp) self.Properties.timestamp = timestamp end
function RichEmbed:setColor(color) self.Properties.color = color end
function RichEmbed:setFooter(text, icon, proxy_icon) self.Properties.footer = { text = text, icon_url = icon or '', proxy_icon_url = proxy_icon or '' } end
function RichEmbed:setImage(icon, proxy_icon, height, width) self.Properties.image = { url = icon or '', proxy_url = proxy_icon or '', height = height or nil, width = width or nil } end
function RichEmbed:setThumbnail(icon, proxy_icon, height, width) self.Properties.thumbnail = { url = icon or '', proxy_url = proxy_icon or '', height = height or nil, width = width or nil } end
function RichEmbed:setVideo(url, height, width) self.Properties.video = { url = url or '', height = height or nil, width = width or nil } end
function RichEmbed:setAuthor(name, url, icon, proxy_icon) self.Properties.author = { name = name or '', url = url or '', icon_url = icon or '', proxy_icon_url = proxy_icon or '' } end
function RichEmbed:addField(name, value, inline) if not self.Properties.fields then self.Properties.fields = {} end table.insert(self.Properties.fields, { name = name, value = value, inline = inline or false }) end

--// WebhookClient object
local WebhookClient = { URL = '' }

function WebhookClient:send(...)
	local unifiedBody = {}
	local arguments = table.pack(...)

	-- Other variables
	if self.username then unifiedBody.username = self.username end
	if self.avatar_url then unifiedBody.avatar_url = self.avatar_url end

	for _, value in next, arguments do
		if type(value) == 'table' then
			-- The object has to be a RichEmbed
			if not unifiedBody.embeds then
				unifiedBody.embeds = {}
			end

			table.insert(unifiedBody.embeds, value.Properties)
		elseif type(value) == 'string' then
			unifiedBody.content = value
		end
	end

	http.post(self.URL, { body = json.stringify(unifiedBody), headers = { ['Content-Length'] = #json.stringify(unifiedBody), ['Content-Type'] = 'application/json' } }, function() end)
end

function WebhookClient:setUsername(username) self.username = username end
function WebhookClient:setAvatarURL(avatar_url) self.avatar_url = avatar_url end

return {
	newEmbed = function()
		return setmetatable({ Properties = {} }, {__index = RichEmbed})
	end,
	new = function(url)
		return setmetatable({ URL = url }, {__index = WebhookClient})
	end
}
--
-- Adapted from
-- Tweener's easing functions (Penner's Easing Equations)
-- and http://code.google.com/p/tweener/ (jstweener javascript version)
--

--[[
Disclaimer for Robert Penner's Easing Equations license:

TERMS OF USE - EASING EQUATIONS

Open source under the BSD License.

Copyright  2001 Robert Penner
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

		* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
		* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
		* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = begin
-- c = change == ending - beginning
-- d = duration (total time)

local pow = math.pow
local sin = math.sin
local cos = math.cos
local pi = math.pi
local sqrt = math.sqrt
local abs = math.abs
local asin	= math.asin

local function linear(t, b, c, d)
	return c * t / d + b
end

local function inQuad(t, b, c, d)
	t = t / d
	return c * pow(t, 2) + b
end

local function outQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 2) + b
	else
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end
end

local function outInQuad(t, b, c, d)
	if t < d / 2 then
		return outQuad (t * 2, b, c / 2, d)
	else
		return inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inCubic (t, b, c, d)
	t = t / d
	return c * pow(t, 3) + b
end

local function outCubic(t, b, c, d)
	t = t / d - 1
	return c * (pow(t, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * t * t * t + b
	else
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end
end

local function outInCubic(t, b, c, d)
	if t < d / 2 then
		return outCubic(t * 2, b, c / 2, d)
	else
		return inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inQuart(t, b, c, d)
	t = t / d
	return c * pow(t, 4) + b
end

local function outQuart(t, b, c, d)
	t = t / d - 1
	return -c * (pow(t, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 4) + b
	else
		t = t - 2
		return -c / 2 * (pow(t, 4) - 2) + b
	end
end

local function outInQuart(t, b, c, d)
	if t < d / 2 then
		return outQuart(t * 2, b, c / 2, d)
	else
		return inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inQuint(t, b, c, d)
	t = t / d
	return c * pow(t, 5) + b
end

local function outQuint(t, b, c, d)
	t = t / d - 1
	return c * (pow(t, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(t, 5) + b
	else
		t = t - 2
		return c / 2 * (pow(t, 5) + 2) + b
	end
end

local function outInQuint(t, b, c, d)
	if t < d / 2 then
		return outQuint(t * 2, b, c / 2, d)
	else
		return inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inSine(t, b, c, d)
	return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
	return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
	return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
	if t < d / 2 then
		return outSine(t * 2, b, c / 2, d)
	else
		return inSine((t * 2) -d, b + c / 2, c / 2, d)
	end
end

local function inExpo(t, b, c, d)
	if t == 0 then
		return b
	else
		return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end
end

local function outExpo(t, b, c, d)
	if t == d then
		return b + c
	else
		return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
	end
end

local function inOutExpo(t, b, c, d)
	if t == 0 then return b end
	if t == d then return b + c end
	t = t / d * 2
	if t < 1 then
		return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005
	else
		t = t - 1
		return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + b
	end
end

local function outInExpo(t, b, c, d)
	if t < d / 2 then
		return outExpo(t * 2, b, c / 2, d)
	else
		return inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inCirc(t, b, c, d)
	t = t / d
	return(-c * (sqrt(1 - pow(t, 2)) - 1) + b)
end

local function outCirc(t, b, c, d)
	t = t / d - 1
	return(c * sqrt(1 - pow(t, 2)) + b)
end

local function inOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c / 2 * (sqrt(1 - t * t) - 1) + b
	else
		t = t - 2
		return c / 2 * (sqrt(1 - t * t) + 1) + b
	end
end

local function outInCirc(t, b, c, d)
	if t < d / 2 then
		return outCirc(t * 2, b, c / 2, d)
	else
		return inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end
end

local function inElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d

	if t == 1	then return b + c end

	if not p then p = d * 0.3 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c/a)
	end

	t = t - 1

	return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

-- a: amplitud
-- p: period
local function outElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d

	if t == 1 then return b + c end

	if not p then p = d * 0.3 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c/a)
	end

	return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

-- p = period
-- a = amplitud
local function inOutElastic(t, b, c, d, a, p)
	if t == 0 then return b end

	t = t / d * 2

	if t == 2 then return b + c end

	if not p then p = d * (0.3 * 1.5) end
	if not a then a = 0 end

	local s

	if not a or a < abs(c) then
		a = c
		s = p / 4
	else
		s = p / (2 * pi) * asin(c / a)
	end

	if t < 1 then
		t = t - 1
		return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
	else
		t = t - 1
		return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b
	end
end

-- a: amplitud
-- p: period
local function outInElastic(t, b, c, d, a, p)
	if t < d / 2 then
		return outElastic(t * 2, b, c / 2, d, a, p)
	else
		return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
	end
end

local function inBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
	if not s then s = 1.70158 end
	s = s * 1.525
	t = t / d * 2
	if t < 1 then
		return c / 2 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function outInBack(t, b, c, d, s)
	if t < d / 2 then
		return outBack(t * 2, b, c / 2, d, s)
	else
		return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end
end

local function outBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function inBounce(t, b, c, d)
	return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
	if t < d / 2 then
		return inBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end
end

local function outInBounce(t, b, c, d)
	if t < d / 2 then
		return outBounce(t * 2, b, c / 2, d)
	else
		return inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end
end

return {
	linear = linear,

	quad_in = inQuad,
	quad_out = outQuad,
	quad_in_out = inOutQuad,
	quad_out_in = outInQuad,

	cubic_in = inCubic ,
	cubic_out = outCubic,
	cubic_in_out = inOutCubic,
	cubic_out_in = outInCubic,

	quart_in = inQuart,
	quart_out = outQuart,
	quart_in_out = inOutQuart,
	quart_out_in = outInQuart,

	quint_in = inQuint,
	quint_out = outQuint,
	quint_in_out = inOutQuint,
	quint_out_in = outInQuint,

	sine_in = inSine,
	sine_out = outSine,
	sine_in_out = inOutSine,
	sine_out_in = outInSine,

	expo_in = inExpo,
	expo_out = outExpo,
	expo_in_out = inOutExpo,
	expo_out_in = outInExpo,

	circ_in = inCirc,
	circ_out = outCirc,
	circ_in_out = inOutCirc,
	circ_out_in = outInCirc,

	elastic_in = inElastic,
	elastic_out = outElastic,
	elastic_in_out = inOutElastic,
	elastic_out_in = outInElastic,

	back_in = inBack,
	back_out = outBack,
	back_in_out = inOutBack,
	back_out_in = outInBack,

	bounce_in = inBounce,
	bounce_out = outBounce,
	bounce_in_out = inOutBounce,
	bounce_out_in = outInBounce,
}
local ffi = require 'ffi'

local animation_layer_t = ffi.typeof([[
	struct {										char pad_0x0000[0x18];
		uint32_t	sequence;
		float		prev_cycle;
		float		weight;
		float		weight_delta_rate;
		float		playback_rate;
		float		cycle;
		void		*entity;						char pad_0x0038[0x4];
	} **
]])

local animation_state_t = ffi.typeof([[
	struct {										char pad_0x0000[0x18];
		float		anim_update_timer;				char pad_0x001C[0xC];
		float		started_moving_time;
		float		last_move_time;					char pad_0x0030[0x10];
		float		last_lby_time;					char pad_0x0044[0x8];
		float		run_amount;						char pad_0x0050[0x10];
		void		*entity;
		__int32		active_weapon;
		__int32		last_active_weapon;
		float		last_client_side_animation_update_time;
		__int32		last_client_side_animation_update_framecount;
		float		eye_timer;
		float		eye_angles_y;
		float		eye_angles_x;
		float		goal_feet_yaw;
		float		current_feet_yaw;
		float		torso_yaw;
		float		last_move_yaw;
		float		lean_amount;					char pad_0x0094[0x4];
		float		feet_cycle;
		float		feet_yaw_rate;					char pad_0x00A0[0x4];
		float		duck_amount;
		float		landing_duck_amount;			char pad_0x00AC[0x4];
		float		current_origin[3];
		float		last_origin[3];
		float		velocity_x;
		float		velocity_y;						char pad_0x00D0[0x10];
		float		move_direction_1;
		float		move_direction_2;				char pad_0x00E8[0x4];
		float		m_velocity;
		float		jump_fall_velocity;
		float		clamped_velocity;
		float		feet_speed_forwards_or_sideways;
		float		feet_speed_unknown_forwards_or_sideways;
		float		last_time_started_moving;
		float		last_time_stopped_moving;
		bool		on_ground;
		bool		hit_in_ground_animation;		char pad_0x0110[0x8];
		float		last_origin_z;
		float		head_from_ground_distance_standing;
		float		stop_to_full_running_fraction;	char pad_0x0120[0x14];
		__int32 	is_not_moving;					char pad_0x0138[0x20];
		float		last_anim_update_time;
		float		moving_direction_x;
		float		moving_direction_y;
		float		moving_direction_z;				char pad_0x0168[0x44];
		__int32 	started_moving;					char pad_0x01B0[0x8];
		float		lean_yaw;						char pad_0x01BC[0x8];
		float		poses_speed;					char pad_0x01C8[0x8];
		float		ladder_speed;					char pad_0x01D4[0x8];
		float		ladder_yaw;						char pad_0x01E0[0x8];
		float		some_pose;						char pad_0x01EC[0x14];
		float		body_yaw;						char pad_0x0204[0x8];
		float		body_pitch;						char pad_0x0210[0x8];
		float		death_yaw;						char pad_0x021C[0x8];
		float		stand;							char pad_0x0228[0x8];
		float		jump_fall;						char pad_0x0234[0x8];
		float		aim_blend_stand_idle;			char pad_0x0240[0x8];
		float		aim_blend_crouch_idle;			char pad_0x024C[0x8];
		float		strafe_yaw;						char pad_0x0258[0x8];
		float		aim_blend_stand_walk;			char pad_0x0264[0x8];
		float		aim_blend_stand_run;			char pad_0x0270[0x8];
		float		aim_blend_crouch_walk;			char pad_0x027C[0x8];
		float		move_blend_walk;				char pad_0x0288[0x8];
		float		move_blend_run;					char pad_0x0294[0x8];
		float		move_blend_crouch;				char pad_0x02A0[0x4];
		float		speed;
		__int32 	moving_in_any_direction;
		float		acceleration;					char pad_0x02B0[0x74];
		float		crouch_height;
		__int32 	is_full_crouched;				char pad_0x032C[0x4];
		float		velocity_subtract_x;
		float		velocity_subtract_y;
		float		velocity_subtract_z;
		float		standing_head_height;			char pad_0x0340[0x4];
	} **
]])

local get_weapon_info_t = ffi.typeof([[
	struct {
		char	pad_vtable[0x4];
		char*	consoleName;		char	pad_0[0xc];
		int		iMaxClip1;
		int		MaxClip2;
		int		iDefaultClip1;
		int 	iDefaultClip2;
		int		iPrimaryReserveAmmoMax;
		int		iSecondaryReserveAmmoMax;
		char*	szWorldModel;
		char*	szViewModel;
		char*	szDroppedModel;		char	pad_9[0x50];
		char*	szHudName;
		char*	szWeaponName;		char	pad_11[0x2];
		bool	bIsMeleeWeapon;		char	pad_12[0x9];
		float	flWeaponWeight;		char	pad_13[0x2c];
		int		iWeaponType;
		int		iWeaponPrice;
		int		iKillAward;			char	pad_16[0x4];
		float	flCycleTime;
		float	flCycleTimeAlt;		char	pad_18[0x8];
		bool	bFullAuto;			char	pad_19[0x3];
		int		iDamage;
		float	flArmorRatio;
		int		iBullets;
		float	flPenetration;		char	pad_23[0x8];
		float	flWeaponRange;
		float	flRangeModifier;
		float	flThrowVelocity;	char	pad_26[0xc];
		bool	bHasSilencer;		char	pad_27[0xb];
		char*	szBulletType;
		float	flMaxSpeed;
		float	flMaxSpeedAlt;		char	pad_29[0x50];
		int		iRecoilSeed;
	}* (__thiscall*)(void*)
]])

local get_client_networkable = vtable_bind('client.dll', 'VClientEntityList003', 0, 'void*(__thiscall*)(void*, int)')
local get_client_entity = vtable_bind('client.dll', 'VClientEntityList003', 3, 'void*(__thiscall*)(void*, int)')
local get_client_unknown = vtable_thunk(0, 'void*(__thiscall*)(void*)')
local get_client_renderable = vtable_thunk(5, 'void*(__thiscall*)(void*)')
local get_model = vtable_thunk(8, 'const void*(__thiscall*)(void*)')
local get_studio_model = vtable_bind('engine.dll', 'VModelInfoClient004', 32, 'void*(__thiscall*)(void*, const void*)')
local get_weapon_info = vtable_thunk(460, get_weapon_info_t)

local get_sequence_activity_match = client.find_signature('client_panorama.dll','\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x8B\xF1\x83') or error('Invalid GetSequenceActivity signature')
local get_sequence_activity = ffi.cast('int(__fastcall*)(void*, void*, int)', get_sequence_activity_match)

local ent_c = {}
local ent_mt = {
	__index = ent_c,
	__metatable = 'ent'
}

local function is_ent(value)
	return getmetatable(value) == 'ent'
end

function ent_mt.__call(ent, entindex_new)
	entindex_new = entindex_new or ent.entindex

	ent.entindex = entindex_new
end

function ent_mt.__eq(ent_a, ent_b)
	local a, b = ent_a, ent_b

	if is_ent(ent_a) then
		a = ent_a.entindex
	end

	if is_ent(ent_b) then
		b = ent_b.entindex
	end

	return a == b
end

function ent_c.new(entindex)
	return setmetatable(
		{
			entindex = entindex or 0
		},
		ent_mt
	)
end

function ent_mt.__tostring(ent)
	return string.format('%d', ent.entindex)
end

function ent_c.get_local_player()
	return ent_c.new(entity.get_local_player())
end

function ent_c.get_all(classname)
	local tbl = {}

	local entities = classname and entity.get_all(classname) or entity.get_all()
	for i=1, #entities do
		tbl[i] = ent_c.new(entities[i])
	end

	return tbl
end

function ent_c.get_players(enemies_only)
	local tbl = {}
	
	local players = enemies_only and entity.get_players(enemies_only) or entity.get_players()
	for i=1, #players do
		tbl[i] = ent_c.new(players[i])
	end

	return tbl
end

function ent_c.get_game_rules()
	return ent_c.new(entity.get_game_rules())
end

function ent_c.get_player_resource()
	return ent_c.new(entity.get_player_resource())
end

function ent_c:get_entindex()
	return self.entindex
end

function ent_c:get_classname()
	return entity.get_classname(self.entindex)
end

function ent_c:set_prop(propname, value, array_index)
	if is_ent(array_index) then
		array_index = array_index.entindex
	end
	
	return array_index and entity.set_prop(self.entindex, propname, value, array_index) or entity.set_prop(self.entindex, propname, value)
end

function ent_c:get_prop(propname, array_index)
	if is_ent(array_index) then
		array_index = array_index.entindex
	end

	-- it wouldn't return multiple values otherwise :(
	if array_index then
		return entity.get_prop(self.entindex, propname, array_index)
	else
		return entity.get_prop(self.entindex, propname)
	end
end

function ent_c:is_enemy()
	return entity.is_enemy(self.entindex)
end

function ent_c:is_alive()
	return entity.is_alive(self.entindex)
end

function ent_c:is_dormant()
	return entity.is_dormant(self.entindex)
end

function ent_c:get_player_name()
	return entity.get_player_name(self.entindex)
end

function ent_c:get_player_weapon()
	return ent_c.new(entity.get_player_weapon(self.entindex))
end

function ent_c:hitbox_position(hitbox)
	return entity.hitbox_position(self.entindex, hitbox)
end

function ent_c:get_steam64()
	return entity.get_steam64(self.entindex)
end

function ent_c:get_bounding_box()
	return entity.get_bounding_box(self.entindex)
end

function ent_c:get_origin()
	return entity.get_origin(self.entindex)
end

function ent_c:get_esp_data()
	return entity.get_esp_data(self.entindex)
end

function ent_c:get_client_networkable()
	return get_client_networkable(self.entindex)
end

function ent_c:get_client_entity()
	return get_client_entity(self.entindex)
end

function ent_c:get_model()
	local client_ptr = ffi.cast('void***', self:get_client_networkable())
	local unknown_ptr = ffi.cast('void***', get_client_unknown(client_ptr))
	local renderable_ptr = ffi.cast('void***', get_client_renderable(unknown_ptr))

	return get_model(renderable_ptr)
end

function ent_c:get_sequence_activity(sequence)
	local hdr = get_studio_model(self:get_model())

	if not hdr then
		return -1
	end

	return get_sequence_activity(self:get_client_entity(), hdr, sequence)
end

function ent_c:get_anim_overlay(layer) -- (*(animation_layer_t)((char*)ent_ptr + 0x2980))[layer]
	local ent_ptr = ffi.cast('void***', self:get_client_entity())

	return ffi.cast(animation_layer_t, ffi.cast('char*', ent_ptr) + 0x2980)[0][layer] 
end

function ent_c:get_anim_state() -- (*(animation_state_t)((char*)ent_ptr + 0x3914))
	local ent_ptr = ffi.cast('void***', self:get_client_entity())

	return ffi.cast(animation_state_t, ffi.cast('char*', ent_ptr) + 0x3914)[0]
end

function ent_c:get_weapon_info()
	local ent_ptr = ffi.cast('void***', self:get_client_entity())

	return get_weapon_info(ent_ptr)
end

return ent_c
--[===================================================================[--
	 Copyright  2016, 2018 Pedro Gimeno Fortea. All rights reserved.

	 Permission is hereby granted to everyone to copy and use this file,
	 for any purpose, in whole or in part, free of charge, provided this
	 single condition is met: The above copyright notice, together with
	 this permission grant and the disclaimer below, should be included
	 in all copies of this software or of a substantial portion of it.

	 THIS SOFTWARE COMES WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED.
--]===================================================================]--

-- GIF(sm) image decoder for the love2d framework, using LuaJIT + FFI.
-- ported to gamesense lua api by sapphyrus
-- Includes LZW decompression.

local ffi = require 'ffi'
local bit = require 'bit'
local table_new = require 'table.new'
local table_clear = require 'table.clear'

local renderer_load_rgba, string_format, table_insert, bit_band, bit_rshift, bit_lshift, string_char, coroutine_yield, ffi_new, ffi_copy, ffi_fill, ffi_string = renderer.load_rgba, string.format, table.insert, bit.band, bit.rshift, bit.lshift, string.char, coroutine.yield, ffi.new, ffi.copy, ffi.fill, ffi.string

-- We have a "double buffer" coroutine-based consumer-producer system
-- requiring the consumer to not request large chunks at a time
-- otherwise the buffer would overflow (this is detected but it will
-- cause an assertion error).

local bytearray = ffi.typeof('uint8_t[?]')
local intarray = ffi.typeof('int[?]')

if not pcall(ffi.sizeof, "gif_rgba") then
	ffi.cdef("typedef union { uint32_t all; struct { uint8_t r, g, b, a; }; } gif_rgba;")
	ffi.cdef("typedef struct { uint8_t r,g,b; } gif_rgb;")
end

local gif_rgba = ffi.typeof("gif_rgba")
local gif_rgba_array = ffi.typeof("gif_rgba[?]")
local gif_rgb_ptr = ffi.typeof("const gif_rgb *")

-- Interlaced mode table. Format:
-- {initial value for pass 1, increment for pass 1,
--  initial value for pass 2, increment for pass 2, ...}
local intertable = {0, 8, 4, 8, 2, 4, 1, 2, false}

-- constants
local GIF_MAGIC1 = 'GIF87a'
local GIF_MAGIC2 = 'GIF89a'
local GIF_INVALID_BLOCK = 0x3B
local GIF_IMG_BLOCK = 0x2C
local GIF_EXT_BLOCK = 0x21
local GIF_APP_BLOCK = 0xFF
local GIF_GFX_CTL_BLOCK = 0xF9
local GIF_GFX_TEXT_BLOCK = 0x01
local GIF_GFX_COMMENT_BLOCK = 0xFE

local transparent_rgba = ffi_new(gif_rgba)

-- Consumer
local function gifread(self, length)
	local curptr = self.baseva + self.seekpos
	local size_remaining = self.endva - curptr
	if length > size_remaining then
		return error('tried to read past end')
	end
	local tmp = self.seekpos
	self.seekpos = tmp + length
	return tmp
end

local function gifread_u8(self)
	return self.baseva[gifread(self, 1)]
end

local function gifdone(self)
	-- clean up non-public vars
	self.baseva = nil
	self.endva = nil
	self.contents = nil
	self.ncomplete = nil

	-- calculate gif duration
	self.duration = 0
	for i=1, #self.frames do
		self.duration = self.duration + self.frames[i][2]
	end
end

-- Gif decoding aux functions
local function gifpalette(palette, source, psize)
	-- Read a palette, inserting alpha

	local src = ffi.cast(gif_rgb_ptr, source)

	for i = 0, psize - 1 do
		palette[i].r = src[i].r
		palette[i].g = src[i].g
		palette[i].b = src[i].b
		palette[i].a = 255
	end
end

-- Gif decoder proper
local function gifdecode(self)
	if #self.contents < 13 then
		return 'Invalid GIF file format'
	end

	local magic = self.contents:sub(1, 6)

	-- Read file ID and header
	gifread(self, 13)
	if magic ~= GIF_MAGIC1 and magic ~= GIF_MAGIC2 then
		return 'Invalid GIF file format'
	end

	local buffer = self.baseva

	local iw, ih = buffer[6] + 256*buffer[7], buffer[8] + 256*buffer[9]
	local npixels = iw*ih
	local image_data = gif_rgba_array(npixels)
	self.width, self.height = iw, ih

	local gpalettesize = buffer[10] >= 128 and bit_lshift(1, bit_band(buffer[10], 7) + 1) or 0
	local background = buffer[11]
	self.aspect = ((buffer[12] == 0 and 49 or 0) + 15) / 64

	local gpalette = gif_rgba_array(256)
	local lpalette = gif_rgba_array(256)

	local lpalettesize, c_background
	-- Read palette and set background
	if gpalettesize > 0 then
		gifread(self, gpalettesize * 3)
		gifpalette(gpalette, buffer + 13, gpalettesize)

		if background < gpalettesize then
			c_background = gif_rgba()
			c_background.r = gpalette[background].r
			c_background.g = gpalette[background].g
			c_background.b = gpalette[background].b
		end
	end

	local p
	local GCE_trans = false
	local GCE_dispose = 0
	local GCE_delay = 0

	-- Allocate the buffers in advance, to reuse them for every frame
	local dict = bytearray(4096)
	local dictptrs = intarray(4096)
	local reversebuf = bytearray(4096)

	if c_background ~= nil and c_background.a > 0 then
		for i=0, npixels-1 do
			image_data[i].all = c_background.all
		end
	end

	while true do
		-- Get block type
		local blocktype = gifread_u8(self)
		local blocklen
		-- for simplicity (?), we fuse the block type and the extension type into
		-- 'blocktype'
		if blocktype == GIF_IMG_BLOCK then
			-- Image block
			blocktype = GIF_IMG_BLOCK
		elseif blocktype == GIF_EXT_BLOCK then
			-- Extension block
			blocktype = gifread_u8(self)
			if blocktype == GIF_IMG_BLOCK then
				-- there's no extension 2C - terminate
				-- (avoids ambiguity with block type 2C)
				break
			end
		elseif blocktype ~= GIF_INVALID_BLOCK then
			return string_format("Unknown block type: 0x%02X", blocktype)
		end

		if blocktype == GIF_INVALID_BLOCK then
			-- Trailer block or invalid block - terminate
			break
		elseif blocktype == GIF_APP_BLOCK then
			-- Application extension - may be loop, otherwise skip
			blocklen = gifread_u8(self)
			p = gifread(self, blocklen + 1)
			if blocklen >= 11 and ffi.string(buffer + p, 11) == 'NETSCAPE2.0' then
				-- these *are* the androids we're looking for
				p = p + blocklen
				while buffer[p] ~= 0 do
					local sblen = buffer[p]
					p = gifread(self, sblen + 1) -- read also the next block length
					if buffer[p] == 1 and sblen >= 3 then
						-- looping subblock - that's for us
						self.loop = buffer[p + 1] + 256 * buffer[p + 2]
					end
					p = p + sblen -- advance to next block
				end
			else
				-- skip entire block
				p = p + blocklen
				while buffer[p] ~= 0 do
					gifread(self, buffer[p])
					p = gifread(self, 1)
				end
			end

		elseif blocktype == GIF_GFX_TEXT_BLOCK or blocktype == GIF_GFX_COMMENT_BLOCK then
			-- Text or Comment Extension - not processed by us, skip
			p = gifread(self, 1) -- read length
			if blocktype < GIF_GFX_TEXT_BLOCK then
				-- skip the block header (contains a length field)
				p = gifread(self, buffer[p] + 1) + buffer[p]

				-- the text extension "consumes" the GCE, so we clear it
				GCE_trans = false
				GCE_dispose = 0
				GCE_delay = 0
			end
			while buffer[p] ~= 0 do
				p = gifread(self, buffer[p] + 1) + buffer[p]
			end

		elseif blocktype == GIF_GFX_CTL_BLOCK then
			-- Graphic Control Extension
			p = gifread(self, 1)
			blocklen = buffer[p]
			p = gifread(self, blocklen + 1)
			if blocklen >= 4 then
				GCE_delay = (buffer[p+1] + 256 * buffer[p+2]) / 100
				GCE_trans = bit_band(buffer[p], 1) ~= 0 and buffer[p + 3]
				GCE_dispose = bit_rshift(bit_band(buffer[p], 0x1C), 2)

				if GCE_delay == 0 then
					GCE_delay = 0.1
				end
			end
			p = p + blocklen
			while buffer[p] ~= 0 do
				p = gifread(self, buffer[p] + 1) + buffer[p]
			end
		elseif blocktype == GIF_IMG_BLOCK then
			-- Here be dragons
			p = gifread(self, 9)

			local x, y = buffer[p] + 256*buffer[p+1], buffer[p+2] + 256*buffer[p+3]
			local w, h = buffer[p+4] + 256*buffer[p+5], buffer[p+6] + 256*buffer[p+7]

			if w == 0 or h == 0 then
				return 'Zero size image'
			end

			table_insert(self.frames, {GCE_dispose, GCE_delay, x, y, w, h})
			local fx, fy, fw, fh = x, y, w, h
			local frame_compressed = fx ~= 0 or fy ~= 0 or fw ~= iw or fh ~= ih

			local flags = buffer[p+8]
			if flags >= 128 then
				-- Has local palette
				lpalettesize = bit_lshift(1, bit_band(flags, 7) + 1)
				p = gifread(self, lpalettesize*3)
				gifpalette(lpalette, buffer + p, lpalettesize)
			else
				-- No local palette - copy the global palette to the local one
				-- lpalette = gpalette
				ffi_copy(lpalette, gpalette, gpalettesize*4)
				lpalettesize = gpalettesize
			end
			if GCE_trans and GCE_trans < lpalettesize then
				-- Clear alpha
				lpalette[GCE_trans].all = 0
			end
			local interlace = bit_band(flags, 64) ~= 0 and 1

			-- LZW decoder.

			-- This could really use another coroutine for
			-- simplicity, as there's another producer/consumer,
			-- but we won't go there.

			p = gifread(self, 2)
			local LZWsize = buffer[p]
			p = p + 1
			if LZWsize == 0 or LZWsize > 11 then
				return "Invalid code size"
			end
			local codebits = LZWsize + 1
			local clearcode = bit_lshift(1, LZWsize) -- End-of-stream is always clearcode+1
			local dictlen = clearcode + 2

			local bitstream, bitlen = 0, 0
			x, y = 0, 0
			local nextlenptr = p
			local oldcode
			local walkcode

			local nrows = 0 -- counts vertical rows, used because interlacing makes the last y invalid
			local frame_offset = iw*fy + fx

			while true do
				-- Are there enough bits in curcode? Do we need to read more data?
				if bitlen >= codebits and y then
					-- Extract next code
					local code = bit_band(bitstream, bit_lshift(1, codebits) - 1)
					bitstream = bit_rshift(bitstream, codebits)
					bitlen = bitlen - codebits

					if code == clearcode then
						codebits = LZWsize + 1
						dictlen = clearcode + 2
						oldcode = false
					elseif code == clearcode + 1 then
						if x ~= 0 or nrows ~= h then
							return "Soft EOD before all rows were output"
						end
						-- signal end of processing
						-- (further data won't be read, but we need to follow the blocks)
						y = false
					else
						-- The dictionary is stored as a list of back pointers.
						-- We need to reverse the order to output the entries.
						-- We use a reverse buffer for that.
						local reverseptr = 4095
						-- Is this code already in the table?
						if code < dictlen then
							-- Already in the table - get the string from the table
							walkcode = code
							while walkcode >= clearcode do
								reversebuf[reverseptr] = dict[walkcode]
								reverseptr = reverseptr - 1
								walkcode = dictptrs[walkcode]
							end
							reversebuf[reverseptr] = walkcode
							-- Add to the table
							if oldcode then
								if dictlen < 4096 then
									dictptrs[dictlen] = oldcode
									dict[dictlen] = walkcode
									dictlen = dictlen + 1
									if dictlen ~= 4096 and bit_band(dictlen, dictlen - 1) == 0 then
										-- perfect power of two - increase code size
										codebits = codebits + 1
									end
								end
							end
							oldcode = code
						else
							-- Not in the table - deal with the special case
							-- The compressor has created a new code, which must be the next
							-- in sequence. We know what it must contain.
							-- It must contain oldcode + first character of oldcode.
							if code > dictlen or not oldcode or not walkcode then
								return "Broken LZW"
							end

							-- Add to the table
							if oldcode then
								if dictlen < 4096 then
									dictptrs[dictlen] = oldcode
									dict[dictlen] = walkcode
									dictlen = dictlen + 1
									if dictlen ~= 4096 and bit_band(dictlen, dictlen - 1) == 0 then
										-- perfect power of two - increase code size
										codebits = codebits + 1
									end
								end
							end
							oldcode = code
							walkcode = oldcode

							while walkcode >= clearcode do
								reversebuf[reverseptr] = dict[walkcode]
								reverseptr = reverseptr - 1
								walkcode = dictptrs[walkcode]
							end
							reversebuf[reverseptr] = walkcode
						end

						if y then
							for i = reverseptr, 4095 do
								local c = reversebuf[i]
								if c >= lpalettesize then c = 0 end

								local lpi = lpalette[c]
								if GCE_dispose ~= 1 or lpi.all > 0 then
									c = lpi

									image_data[frame_offset + x] = c

									if (fx > 0 or fy > 0) and interlace then
										return "Interlaced + frame compressed gifs not supported"
									end
								end

								if interlace then
									-- The passes 1, 2, 3, 4 correspond to the
									-- values 1, 3, 5, 7 of 'interlace'.
									if c and self.progressive and interlace < 7 and y + 1 < h then
										-- In any pass but the last, there are at least 2 lines.
										image_data[frame_offset + x + w] = c
										if interlace < 5 and y + 2 < h then
											-- In the first two passes, there are at least 4 lines.
											image_data[frame_offset + x + w*2] = c
											if y + 3 < h then
												image_data[frame_offset + x + w*3] = c
												if interlace < 3 and y + 4 < h then
													-- In the first pass there are 8 lines.
													image_data[frame_offset + x + w*4] = c
													if y + 5 < h then
														image_data[frame_offset + x + w*5] = c
														if y + 6 < h then
															image_data[frame_offset + x + w*6] = c
															if y + 7 < h then
																image_data[frame_offset + x + w*7] = c
															end
														end
													end
												end
											end
										end
									end
									-- Advance pixel
									x = x + 1
									if x >= w then
										-- Skip to next interlaced row
										x = 0
										nrows = nrows + 1
										y = y + intertable[interlace + 1]
										if y >= h then
											interlace = interlace + 2
											if interlace > 7 then
												y = false
											else
												y = intertable[interlace]
											end
										end
										if y then
											frame_offset = y * w + (frame_compressed and (iw*fy + y*(iw-fw) + fx) or 0)
										end
									end
								else
									-- No interlace, just increment y
									x = x + 1
									if x >= w then
										x = 0
										y = y + 1
										nrows = y
										if y >= h then
											y = false
										else
											frame_offset = y * w + (frame_compressed and (iw*fy + y*(iw-fw) + fx) or 0)
										end
									end
								end
							end

						else
							-- This should not happen.
							return 'Data past the end of the image'
						end
					end
				else
					-- Not enough bits, grab 8 more
					if p >= nextlenptr then
						-- End of this subblock - read next subblock
						-- assert(p == nextlenptr)
						local sblen = buffer[nextlenptr]

						if sblen == 0 then
							-- no more data
							if y then
								return "Hard EOD before the end of the image"
							end
							break
						end
						p = gifread(self, sblen + 1)
						nextlenptr = p + sblen
					end
					if y then
						bitstream = bitstream + bit_lshift(buffer[p], bitlen)
						bitlen = bitlen + 8
						p = p + 1
					else
						-- end of data - fast forward to end of block
						p = nextlenptr
					end
				end
			end

			local data_str = ffi_string(image_data, npixels*4)
			local texture = renderer_load_rgba(data_str, iw, ih)

			if texture == nil then
				return string_format("Failed to load frame %d", #self.frames)
			end

			table_insert(self.frames[#self.frames], texture)

			if GCE_dispose == 0 then
				-- clear, expects next frame to be full width or it'll crash
				ffi_fill(image_data, npixels*4, 0)
			elseif GCE_dispose == 1 then
				-- do nothing
			elseif GCE_dispose == 2 then
				-- -- fill with background
				if c_background ~= nil then
					if c_background.all == 0 then
						ffi_fill(image_data, npixels*4, 0)
					else
						for i=0, npixels-1 do
							image_data[i].all = c_background.all
						end
					end
				else
					return "Dispose mode 2, but no background given"
				end
			else
				return string_format("Unsupported dispose mode: %d", GCE_dispose)
			end

			GCE_trans = false
			GCE_dispose = 0
			GCE_delay = 0
			self.ncomplete = #self.frames
		else
			break
		end
	end
end

local function gifframe(self, frame)
	if self.frames[frame] == nil then
		error("Frame not found", 2)
	end

	local dispose, delay, x, y, w, h, texture = unpack(self.frames[frame])
	return texture, x, y, w, h, dispose, delay
end

local function gifdrawframe(self, frame, x, y, w, h, r, g, b, a, flags, ...)
	if self.frames[frame] == nil then
		error("Frame not found", 2)
	end

	local texture = gifframe(self, frame)
	renderer.texture(texture, x, y, w or self.width, h or self.height, r or 255, g or 255, b or 255, a or 255, flags or "f", ...)
end

local function gifdraw(self, time, ...)
	if self.duration == 0 then
		time = 0
	else
		time = time % self.duration
	end

	local tmpdur, frame = 0
	for i=1, #self.frames do
		tmpdur = tmpdur + self.frames[i][2]
		if tmpdur >= time then
			frame = i
			break
		end
	end

	if frame == nil then
		error("Frame not found", 2)
	end

	return gifdrawframe(self, frame, ...)
end

-- high level interface
local M = {}
local gif_mt = {
	__index = {
		frame = gifframe;
		drawframe = gifdrawframe,
		draw = gifdraw,
	}
}

-- load a gif from raw byte buffer (string)
function M.load_gif(contents)
	local gif = {
		width = false,
		height = false,
		frames = {},
		ncomplete = 0,
		progressive = false,
		loop = false,
		aspect = false,

		baseva = ffi.cast("const uint8_t *", ffi.cast("const char *", contents)),
		endva = false,
		contents = contents,
		seekpos = 0
	}

	gif.endva = gif.baseva + #contents

	-- load contents
	local err = gifdecode(gif)
	gifdone(gif)

	if err ~= nil then
		return error(err, 2)
	end

	return setmetatable(gif, gif_mt)
end

return M
--
-- dependencies
--

local ffi = require "ffi"
local base64 = require "gamesense/base64"

local assert, pcall, xpcall, error, setmetatable, tostring, tonumber, type, pairs, ipairs = assert, pcall, xpcall, error, setmetatable, tostring, tonumber, type, pairs, ipairs
local client_log, client_delay_call, ui_get, string_format = client.log, client.delay_call, ui.get, string.format
local typeof, sizeof, cast, cdef, ffi_string, ffi_gc = ffi.typeof, ffi.sizeof, ffi.cast, ffi.cdef, ffi.string, ffi.gc
local string_lower, string_len, string_find = string.lower, string.len, string.find
local base64_encode = base64.encode

--
-- steam api
--

local register_call_result, register_callback, steam_client_context
do
	if not pcall(ffi.sizeof, "SteamAPICall_t") then
		cdef([[
			typedef uint64_t SteamAPICall_t;

			struct SteamAPI_callback_base_vtbl {
				void(__thiscall *run1)(struct SteamAPI_callback_base *, void *, bool, uint64_t);
				void(__thiscall *run2)(struct SteamAPI_callback_base *, void *);
				int(__thiscall *get_size)(struct SteamAPI_callback_base *);
			};

			struct SteamAPI_callback_base {
				struct SteamAPI_callback_base_vtbl *vtbl;
				uint8_t flags;
				int id;
				uint64_t api_call_handle;
				struct SteamAPI_callback_base_vtbl vtbl_storage[1];
			};
		]])
	end

	local ESteamAPICallFailure = {
		[-1] = "No failure",
		[0]  = "Steam gone",
		[1]  = "Network failure",
		[2]  = "Invalid handle",
		[3]  = "Mismatched callback"
	}

	local SteamAPI_RegisterCallResult, SteamAPI_UnregisterCallResult
	local SteamAPI_RegisterCallback, SteamAPI_UnregisterCallback
	local GetAPICallFailureReason

	local callback_base        = typeof("struct SteamAPI_callback_base")
	local sizeof_callback_base = sizeof(callback_base)
	local callback_base_array  = typeof("struct SteamAPI_callback_base[1]")
	local callback_base_ptr    = typeof("struct SteamAPI_callback_base*")
	local uintptr_t            = typeof("uintptr_t")
	local api_call_handlers    = {}
	local pending_call_results = {}
	local registered_callbacks = {}

	local function pointer_key(p)
		return tostring(tonumber(cast(uintptr_t, p)))
	end

	local function callback_base_run_common(self, param, io_failure)
		if io_failure then
			io_failure = ESteamAPICallFailure[GetAPICallFailureReason(self.api_call_handle)] or "Unknown error"
		end

		-- prevent SteamAPI_UnregisterCallResult from being called for this callresult
		self.api_call_handle = 0

		xpcall(function()
			local key = pointer_key(self)
			local handler = api_call_handlers[key]
			if handler ~= nil then
				xpcall(handler, client.error_log, param, io_failure)
			end

			if pending_call_results[key] ~= nil then
				api_call_handlers[key] = nil
				pending_call_results[key] = nil
			end
		end, client.error_log)
	end

	local function callback_base_run1(self, param, io_failure, api_call_handle)
		if api_call_handle == self.api_call_handle then
			callback_base_run_common(self, param, io_failure)
		end
	end

	local function callback_base_run2(self, param)
		callback_base_run_common(self, param, false)
	end

	local function callback_base_get_size(self)
		return sizeof_callback_base
	end

	local function call_result_cancel(self)
		if self.api_call_handle ~= 0 then
			SteamAPI_UnregisterCallResult(self, self.api_call_handle)
			self.api_call_handle = 0

			local key = pointer_key(self)
			api_call_handlers[key] = nil
			pending_call_results[key] = nil
		end
	end

	pcall(ffi.metatype, callback_base, {
		__gc = call_result_cancel,
		__index = {
			cancel = call_result_cancel
		}
	})

	local callback_base_run1_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *, bool, uint64_t)", callback_base_run1)
	local callback_base_run2_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *)", callback_base_run2)
	local callback_base_get_size_ct = cast("int(__thiscall *)(struct SteamAPI_callback_base *)", callback_base_get_size)

	function register_call_result(api_call_handle, handler, id)
		assert(api_call_handle ~= 0)
		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)

		instance.vtbl_storage[0].run1 = callback_base_run1_ct
		instance.vtbl_storage[0].run2 = callback_base_run2_ct
		instance.vtbl_storage[0].get_size = callback_base_get_size_ct
		instance.vtbl = instance.vtbl_storage
		instance.api_call_handle = api_call_handle
		instance.id = id

		local key = pointer_key(instance)
		api_call_handlers[key] = handler
		pending_call_results[key] = instance_storage

		SteamAPI_RegisterCallResult(instance, api_call_handle)

		return instance
	end

	function register_callback(id, handler)
		assert(registered_callbacks[id] == nil)

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)

		instance.vtbl_storage[0].run1 = callback_base_run1_ct
		instance.vtbl_storage[0].run2 = callback_base_run2_ct
		instance.vtbl_storage[0].get_size = callback_base_get_size_ct
		instance.vtbl = instance.vtbl_storage
		instance.api_call_handle = 0
		instance.id = id

		local key = pointer_key(instance)
		api_call_handlers[key] = handler
		registered_callbacks[id] = instance_storage

		SteamAPI_RegisterCallback(instance, id)
	end

	local function find_sig(mdlname, pattern, typename, offset, deref_count)
		local raw_match = client.find_signature(mdlname, pattern) or error("signature not found", 2)
		local match = cast("uintptr_t", raw_match)

		if offset ~= nil and offset ~= 0 then
			match = match + offset
		end

		if deref_count ~= nil then
			for i = 1, deref_count do
				match = cast("uintptr_t*", match)[0]
				if match == nil then
					return error("signature not found")
				end
			end
		end

		return cast(typename, match)
	end

	local function vtable_entry(instance, index, type)
		return cast(type, (cast("void***", instance)[0])[index])
	end

	SteamAPI_RegisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xFF\x75\x10", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")
	SteamAPI_UnregisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\xFF\x75\x10\xFF\x75\x0C", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")

	SteamAPI_RegisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xC7\x05", "void(__cdecl*)(struct SteamAPI_callback_base *, int)")
	SteamAPI_UnregisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\xEC\x08\x80\x3D", "void(__cdecl*)(struct SteamAPI_callback_base *)")

	steam_client_context = find_sig(
		"client_panorama.dll",
		"\xB9\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x0F\x84",
		"uintptr_t",
		1, 1
	)

	-- initialize isteamutils and native_GetAPICallFailureReason
	local steamutils = cast("uintptr_t*", steam_client_context)[3]
	local native_GetAPICallFailureReason = vtable_entry(steamutils, 12, "int(__thiscall*)(void*, SteamAPICall_t)")

	function GetAPICallFailureReason(handle)
		return native_GetAPICallFailureReason(steamutils, handle)
	end

	client.set_event_callback("shutdown", function()
		for key, value in pairs(pending_call_results) do
			local instance = cast(callback_base_ptr, value)
			call_result_cancel(instance)
		end

		for key, value in pairs(registered_callbacks) do
			local instance = cast(callback_base_ptr, value)
			SteamAPI_UnregisterCallback(instance)
		end
	end)
end

--
-- ffi definitions
--

if not pcall(sizeof, "http_HTTPRequestHandle") then
	cdef([[
		typedef uint32_t http_HTTPRequestHandle;
		typedef uint32_t http_HTTPCookieContainerHandle;

		enum http_EHTTPMethod {
			k_EHTTPMethodInvalid,
			k_EHTTPMethodGET,
			k_EHTTPMethodHEAD,
			k_EHTTPMethodPOST,
			k_EHTTPMethodPUT,
			k_EHTTPMethodDELETE,
			k_EHTTPMethodOPTIONS,
			k_EHTTPMethodPATCH,
		};

		struct http_ISteamHTTPVtbl {
			http_HTTPRequestHandle(__thiscall *CreateHTTPRequest)(uintptr_t, enum http_EHTTPMethod, const char *);
			bool(__thiscall *SetHTTPRequestContextValue)(uintptr_t, http_HTTPRequestHandle, uint64_t);
			bool(__thiscall *SetHTTPRequestNetworkActivityTimeout)(uintptr_t, http_HTTPRequestHandle, uint32_t);
			bool(__thiscall *SetHTTPRequestHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, const char *);
			bool(__thiscall *SetHTTPRequestGetOrPostParameter)(uintptr_t, http_HTTPRequestHandle, const char *, const char *);
			bool(__thiscall *SendHTTPRequest)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *);
			bool(__thiscall *SendHTTPRequestAndStreamResponse)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *);
			bool(__thiscall *DeferHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
			bool(__thiscall *PrioritizeHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
			bool(__thiscall *GetHTTPResponseHeaderSize)(uintptr_t, http_HTTPRequestHandle, const char *, uint32_t *);
			bool(__thiscall *GetHTTPResponseHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t);
			bool(__thiscall *GetHTTPResponseBodySize)(uintptr_t, http_HTTPRequestHandle, uint32_t *);
			bool(__thiscall *GetHTTPResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint8_t *, uint32_t);
			bool(__thiscall *GetHTTPStreamingResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint32_t, uint8_t *, uint32_t);
			bool(__thiscall *ReleaseHTTPRequest)(uintptr_t, http_HTTPRequestHandle);
			bool(__thiscall *GetHTTPDownloadProgressPct)(uintptr_t, http_HTTPRequestHandle, float *);
			bool(__thiscall *SetHTTPRequestRawPostBody)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t);
			http_HTTPCookieContainerHandle(__thiscall *CreateCookieContainer)(uintptr_t, bool);
			bool(__thiscall *ReleaseCookieContainer)(uintptr_t, http_HTTPCookieContainerHandle);
			bool(__thiscall *SetCookie)(uintptr_t, http_HTTPCookieContainerHandle, const char *, const char *, const char *);
			bool(__thiscall *SetHTTPRequestCookieContainer)(uintptr_t, http_HTTPRequestHandle, http_HTTPCookieContainerHandle);
			bool(__thiscall *SetHTTPRequestUserAgentInfo)(uintptr_t, http_HTTPRequestHandle, const char *);
			bool(__thiscall *SetHTTPRequestRequiresVerifiedCertificate)(uintptr_t, http_HTTPRequestHandle, bool);
			bool(__thiscall *SetHTTPRequestAbsoluteTimeoutMS)(uintptr_t, http_HTTPRequestHandle, uint32_t);
			bool(__thiscall *GetHTTPRequestWasTimedOut)(uintptr_t, http_HTTPRequestHandle, bool *pbWasTimedOut);
		};
	]])
end

--
-- constants
--

local method_name_to_enum = {
	get = ffi.C.k_EHTTPMethodGET,
	head = ffi.C.k_EHTTPMethodHEAD,
	post = ffi.C.k_EHTTPMethodPOST,
	put = ffi.C.k_EHTTPMethodPUT,
	delete = ffi.C.k_EHTTPMethodDELETE,
	options = ffi.C.k_EHTTPMethodOPTIONS,
	patch = ffi.C.k_EHTTPMethodPATCH,
}

local status_code_to_message = {
	[100]="Continue",[101]="Switching Protocols",[102]="Processing",[200]="OK",[201]="Created",[202]="Accepted",[203]="Non-Authoritative Information",[204]="No Content",[205]="Reset Content",[206]="Partial Content",[207]="Multi-Status",
	[208]="Already Reported",[250]="Low on Storage Space",[226]="IM Used",[300]="Multiple Choices",[301]="Moved Permanently",[302]="Found",[303]="See Other",[304]="Not Modified",[305]="Use Proxy",[306]="Switch Proxy",
	[307]="Temporary Redirect",[308]="Permanent Redirect",[400]="Bad Request",[401]="Unauthorized",[402]="Payment Required",[403]="Forbidden",[404]="Not Found",[405]="Method Not Allowed",[406]="Not Acceptable",[407]="Proxy Authentication Required",
	[408]="Request Timeout",[409]="Conflict",[410]="Gone",[411]="Length Required",[412]="Precondition Failed",[413]="Request Entity Too Large",[414]="Request-URI Too Long",[415]="Unsupported Media Type",[416]="Requested Range Not Satisfiable",
	[417]="Expectation Failed",[418]="I'm a teapot",[420]="Enhance Your Calm",[422]="Unprocessable Entity",[423]="Locked",[424]="Failed Dependency",[424]="Method Failure",[425]="Unordered Collection",[426]="Upgrade Required",[428]="Precondition Required",
	[429]="Too Many Requests",[431]="Request Header Fields Too Large",[444]="No Response",[449]="Retry With",[450]="Blocked by Windows Parental Controls",[451]="Parameter Not Understood",[451]="Unavailable For Legal Reasons",[451]="Redirect",
	[452]="Conference Not Found",[453]="Not Enough Bandwidth",[454]="Session Not Found",[455]="Method Not Valid in This State",[456]="Header Field Not Valid for Resource",[457]="Invalid Range",[458]="Parameter Is Read-Only",[459]="Aggregate Operation Not Allowed",
	[460]="Only Aggregate Operation Allowed",[461]="Unsupported Transport",[462]="Destination Unreachable",[494]="Request Header Too Large",[495]="Cert Error",[496]="No Cert",[497]="HTTP to HTTPS",[499]="Client Closed Request",[500]="Internal Server Error",
	[501]="Not Implemented",[502]="Bad Gateway",[503]="Service Unavailable",[504]="Gateway Timeout",[505]="HTTP Version Not Supported",[506]="Variant Also Negotiates",[507]="Insufficient Storage",[508]="Loop Detected",[509]="Bandwidth Limit Exceeded",
	[510]="Not Extended",[511]="Network Authentication Required",[551]="Option not supported",[598]="Network read timeout error",[599]="Network connect timeout error"
}

local single_allowed_keys = {"params", "body", "json"}

-- https://github.com/AlexApps99/SteamworksSDK/blob/fe3524b655eb9df6ae4d24e0ffb365357a370c7f/public/steam/isteamhttp.h#L162-L214
local CALLBACK_HTTPRequestCompleted = 2101
local CALLBACK_HTTPRequestHeadersReceived = 2102
local CALLBACK_HTTPRequestDataReceived = 2103

--
-- private functions
--

local function find_isteamhttp()
	local steamhttp = cast("uintptr_t*", steam_client_context)[12]

	if steamhttp == 0 or steamhttp == nil then
		return error("find_isteamhttp failed")
	end

	local vmt = cast("struct http_ISteamHTTPVtbl**", steamhttp)[0]
	if vmt == 0 or vmt == nil then
		return error("find_isteamhttp failed")
	end

	return steamhttp, vmt
end

local function func_bind(func, arg)
	return function(...)
		return func(arg, ...)
	end
end

--
-- steamhttp ffi stuff
--

local HTTPRequestCompleted_t_ptr = typeof([[
struct {
	http_HTTPRequestHandle m_hRequest;
	uint64_t m_ulContextValue;
	bool m_bRequestSuccessful;
	int m_eStatusCode;
	uint32_t m_unBodySize;
} *
]])

local HTTPRequestHeadersReceived_t_ptr = typeof([[
struct {
	http_HTTPRequestHandle m_hRequest;
	uint64_t m_ulContextValue;
} *
]])

local HTTPRequestDataReceived_t_ptr = typeof([[
struct {
	http_HTTPRequestHandle m_hRequest;
	uint64_t m_ulContextValue;
	uint32_t m_cOffset;
	uint32_t m_cBytesReceived;
} *
]])

local CookieContainerHandle_t = typeof([[
struct {
	http_HTTPCookieContainerHandle m_hCookieContainer;
}
]])

local SteamAPICall_t_arr = typeof("SteamAPICall_t[1]")
local char_ptr = typeof("const char[?]")
local unit8_ptr = typeof("uint8_t[?]")
local uint_ptr = typeof("unsigned int[?]")
local bool_ptr = typeof("bool[1]")
local float_ptr = typeof("float[1]")

--
-- get isteamhttp interface
--

local steam_http, steam_http_vtable = find_isteamhttp()

--
-- isteamhttp functions
--

local native_CreateHTTPRequest = func_bind(steam_http_vtable.CreateHTTPRequest, steam_http)
local native_SetHTTPRequestContextValue = func_bind(steam_http_vtable.SetHTTPRequestContextValue, steam_http)
local native_SetHTTPRequestNetworkActivityTimeout = func_bind(steam_http_vtable.SetHTTPRequestNetworkActivityTimeout, steam_http)
local native_SetHTTPRequestHeaderValue = func_bind(steam_http_vtable.SetHTTPRequestHeaderValue, steam_http)
local native_SetHTTPRequestGetOrPostParameter = func_bind(steam_http_vtable.SetHTTPRequestGetOrPostParameter, steam_http)
local native_SendHTTPRequest = func_bind(steam_http_vtable.SendHTTPRequest, steam_http)
local native_SendHTTPRequestAndStreamResponse = func_bind(steam_http_vtable.SendHTTPRequestAndStreamResponse, steam_http)
local native_DeferHTTPRequest = func_bind(steam_http_vtable.DeferHTTPRequest, steam_http)
local native_PrioritizeHTTPRequest = func_bind(steam_http_vtable.PrioritizeHTTPRequest, steam_http)
local native_GetHTTPResponseHeaderSize = func_bind(steam_http_vtable.GetHTTPResponseHeaderSize, steam_http)
local native_GetHTTPResponseHeaderValue = func_bind(steam_http_vtable.GetHTTPResponseHeaderValue, steam_http)
local native_GetHTTPResponseBodySize = func_bind(steam_http_vtable.GetHTTPResponseBodySize, steam_http)
local native_GetHTTPResponseBodyData = func_bind(steam_http_vtable.GetHTTPResponseBodyData, steam_http)
local native_GetHTTPStreamingResponseBodyData = func_bind(steam_http_vtable.GetHTTPStreamingResponseBodyData, steam_http)
local native_ReleaseHTTPRequest = func_bind(steam_http_vtable.ReleaseHTTPRequest, steam_http)
local native_GetHTTPDownloadProgressPct = func_bind(steam_http_vtable.GetHTTPDownloadProgressPct, steam_http)
local native_SetHTTPRequestRawPostBody = func_bind(steam_http_vtable.SetHTTPRequestRawPostBody, steam_http)
local native_CreateCookieContainer = func_bind(steam_http_vtable.CreateCookieContainer, steam_http)
local native_ReleaseCookieContainer = func_bind(steam_http_vtable.ReleaseCookieContainer, steam_http)
local native_SetCookie = func_bind(steam_http_vtable.SetCookie, steam_http)
local native_SetHTTPRequestCookieContainer = func_bind(steam_http_vtable.SetHTTPRequestCookieContainer, steam_http)
local native_SetHTTPRequestUserAgentInfo = func_bind(steam_http_vtable.SetHTTPRequestUserAgentInfo, steam_http)
local native_SetHTTPRequestRequiresVerifiedCertificate = func_bind(steam_http_vtable.SetHTTPRequestRequiresVerifiedCertificate, steam_http)
local native_SetHTTPRequestAbsoluteTimeoutMS = func_bind(steam_http_vtable.SetHTTPRequestAbsoluteTimeoutMS, steam_http)
local native_GetHTTPRequestWasTimedOut = func_bind(steam_http_vtable.GetHTTPRequestWasTimedOut, steam_http)

--
-- private variables
--

local completed_callbacks, is_in_callback = {}, false
local headers_received_callback_registered, headers_received_callbacks = false, {}
local data_received_callback_registered, data_received_callbacks = false, {}

-- weak table containing headers tbl -> cookie container handle
local cookie_containers = setmetatable({}, {__mode = "k"})

-- weak table containing headers tbl -> request handle
local headers_request_handles, request_handles_headers = setmetatable({}, {__mode = "k"}), setmetatable({}, {__mode = "v"})

-- table containing in-flight http requests
local pending_requests = {}

--
-- response headers metatable
--

local response_headers_mt = {
	__index = function(req_key, name)
		local req = headers_request_handles[req_key]
		if req == nil then
			return
		end

		name = tostring(name)
		if req.m_hRequest ~= 0 then
			local header_size = uint_ptr(1)
			if native_GetHTTPResponseHeaderSize(req.m_hRequest, name, header_size) then
				if header_size ~= nil then
					header_size = header_size[0]
					if header_size < 0 then
						return
					end

					local buffer = unit8_ptr(header_size)
					if native_GetHTTPResponseHeaderValue(req.m_hRequest, name, buffer, header_size) then
						req_key[name] = ffi_string(buffer, header_size-1)
						return req_key[name]
					end
				end
			end
		end
	end,
	__metatable = false
}

--
-- cookie container metatable
--

local cookie_container_mt = {
	__index = {
		set_cookie = function(handle_key, host, url, name, value)
			local handle = cookie_containers[handle_key]
			if handle == nil or handle.m_hCookieContainer == 0 then
				return
			end

			native_SetCookie(handle.m_hCookieContainer, host, url, tostring(name) .. "=" .. tostring(value))
		end
	},
	__metatable = false
}

--
-- garbage collection callbaks
--

local function cookie_container_gc(handle)
	if handle.m_hCookieContainer ~= 0 then
		native_ReleaseCookieContainer(handle.m_hCookieContainer)
		handle.m_hCookieContainer = 0
	end
end

local function http_request_gc(req)
	if req.m_hRequest ~= 0 then
		native_ReleaseHTTPRequest(req.m_hRequest)
		req.m_hRequest = 0
	end
end

local function http_request_error(req_handle, ...)
	native_ReleaseHTTPRequest(req_handle)
	return error(...)
end

local function http_request_callback_common(req, callback, successful, data, ...)
	local headers = request_handles_headers[req.m_hRequest]
	if headers == nil then
		headers = setmetatable({}, response_headers_mt)
		request_handles_headers[req.m_hRequest] = headers
	end
	headers_request_handles[headers] = req
	data.headers = headers

	-- run callback
	is_in_callback = true
	xpcall(callback, client.error_log, successful, data, ...)
	is_in_callback = false
end

local function http_request_completed(param, io_failure)
	if param == nil then
		return
	end

	local req = cast(HTTPRequestCompleted_t_ptr, param)

	if req.m_hRequest ~= 0 then
		local callback = completed_callbacks[req.m_hRequest]

		-- if callback ~= nil the request was sent by us
		if callback ~= nil then
			completed_callbacks[req.m_hRequest] = nil
			data_received_callbacks[req.m_hRequest] = nil
			headers_received_callbacks[req.m_hRequest] = nil

			-- callback can be false
			if callback then
				local successful = io_failure == false and req.m_bRequestSuccessful
				local status = req.m_eStatusCode

				local response = {
					status = status
				}

				local body_size = req.m_unBodySize
				if successful and body_size > 0 then
					local buffer = unit8_ptr(body_size)
					if native_GetHTTPResponseBodyData(req.m_hRequest, buffer, body_size) then
						response.body = ffi_string(buffer, body_size)
					end
				elseif not req.m_bRequestSuccessful then
					local timed_out = bool_ptr()
					native_GetHTTPRequestWasTimedOut(req.m_hRequest, timed_out)
					response.timed_out = timed_out ~= nil and timed_out[0] == true
				end

				if status > 0 then
					response.status_message = status_code_to_message[status] or "Unknown status"
				elseif io_failure then
					response.status_message = string_format("IO Failure: %s", io_failure)
				else
					response.status_message = response.timed_out and "Timed out" or "Unknown error"
				end

				-- release http request on garbage collection
				-- ffi.gc(req, http_request_gc)

				http_request_callback_common(req, callback, successful, response)
			end

			http_request_gc(req)
		end
	end
end

local function http_request_headers_received(param, io_failure)
	if param == nil then
		return
	end

	local req = cast(HTTPRequestHeadersReceived_t_ptr, param)

	if req.m_hRequest ~= 0 then
		local callback = headers_received_callbacks[req.m_hRequest]
		if callback then
			http_request_callback_common(req, callback, io_failure == false, {})
		end
	end
end

local function http_request_data_received(param, io_failure)
	if param == nil then
		return
	end

	local req = cast(HTTPRequestDataReceived_t_ptr, param)

	if req.m_hRequest ~= 0 then
		local callback = data_received_callbacks[req.m_hRequest]
		if data_received_callbacks[req.m_hRequest] then
			local data = {}

			local download_percentage_prt = float_ptr()
			if native_GetHTTPDownloadProgressPct(req.m_hRequest, download_percentage_prt) then
				data.download_progress = tonumber(download_percentage_prt[0])
			end

			local buffer = unit8_ptr(req.m_cBytesReceived)
			if native_GetHTTPStreamingResponseBodyData(req.m_hRequest, req.m_cOffset, buffer, req.m_cBytesReceived) then
				data.body = ffi_string(buffer, req.m_cBytesReceived)
			end

			http_request_callback_common(req, callback, io_failure == false, data)
		end
	end
end

local function http_request_new(method, url, options, callbacks)
	-- support overload: http.request(method, url, callback)
	if type(options) == "function" and callbacks == nil then
		callbacks = options
		options = {}
	end

	options = options or {}

	local method = method_name_to_enum[string_lower(tostring(method))]
	if method == nil then
		return error("invalid HTTP method")
	end

	if type(url) ~= "string" then
		return error("URL has to be a string")
	end

	local completed_callback, headers_received_callback, data_received_callback
	if type(callbacks) == "function" then
		completed_callback = callbacks
	elseif type(callbacks) == "table" then
		completed_callback = callbacks.completed or callbacks.complete
		headers_received_callback = callbacks.headers_received or callbacks.headers
		data_received_callback = callbacks.data_received or callbacks.data

		if completed_callback ~= nil and type(completed_callback) ~= "function" then
			return error("callbacks.completed callback has to be a function")
		elseif headers_received_callback ~= nil and type(headers_received_callback) ~= "function" then
			return error("callbacks.headers_received callback has to be a function")
		elseif data_received_callback ~= nil and type(data_received_callback) ~= "function" then
			return error("callbacks.data_received callback has to be a function")
		end
	else
		return error("callbacks has to be a function or table")
	end

	local req_handle = native_CreateHTTPRequest(method, url)
	if req_handle == 0 then
		return error("Failed to create HTTP request")
	end

	local set_one = false
	for i, key in ipairs(single_allowed_keys) do
		if options[key] ~= nil then
			if set_one then
				return error("can only set options.params, options.body or options.json")
			else
				set_one = true
			end
		end
	end

	local json_body
	if options.json ~= nil then
		local success
		success, json_body = pcall(json.stringify, options.json)

		if not success then
			return error("options.json is invalid: " .. json_body)
		end
	end

	-- WARNING:
	-- use http_request_error after this point to properly free the http request

	local network_timeout = options.network_timeout
	if network_timeout == nil then
		network_timeout = 10
	end

	if type(network_timeout) == "number" and network_timeout > 0 then
		if not native_SetHTTPRequestNetworkActivityTimeout(req_handle, network_timeout) then
			return http_request_error(req_handle, "failed to set network_timeout")
		end
	elseif network_timeout ~= nil then
		return http_request_error(req_handle, "options.network_timeout has to be of type number and greater than 0")
	end

	local absolute_timeout = options.absolute_timeout
	if absolute_timeout == nil then
		absolute_timeout = 30
	end

	if type(absolute_timeout) == "number" and absolute_timeout > 0 then
		if not native_SetHTTPRequestAbsoluteTimeoutMS(req_handle, absolute_timeout*1000) then
			return http_request_error(req_handle, "failed to set absolute_timeout")
		end
	elseif absolute_timeout ~= nil then
		return http_request_error(req_handle, "options.absolute_timeout has to be of type number and greater than 0")
	end

	local content_type = json_body ~= nil and "application/json" or "text/plain"
	local authorization_set

	local headers = options.headers
	if type(headers) == "table" then
		for name, value in pairs(headers) do
			name = tostring(name)
			value = tostring(value)

			local name_lower = string_lower(name)

			if name_lower == "content-type" then
				content_type = value
			elseif name_lower == "authorization" then
				authorization_set = true
			end

			if not native_SetHTTPRequestHeaderValue(req_handle, name, value) then
				return http_request_error(req_handle, "failed to set header " .. name)
			end
		end
	elseif headers ~= nil then
		return http_request_error(req_handle, "options.headers has to be of type table")
	end

	local authorization = options.authorization
	if type(authorization) == "table" then
		if authorization_set then
			return http_request_error(req_handle, "Cannot set both options.authorization and the 'Authorization' header.")
		end

		local username, password = authorization[1], authorization[2]
		local header_value = string_format("Basic %s", base64_encode(string_format("%s:%s", tostring(username), tostring(password)), "base64"))

		if not native_SetHTTPRequestHeaderValue(req_handle, "Authorization", header_value) then
			return http_request_error(req_handle, "failed to apply options.authorization")
		end
	elseif authorization ~= nil then
		return http_request_error(req_handle, "options.authorization has to be of type table")
	end

	local body = json_body or options.body
	if type(body) == "string" then
		local len = string_len(body)

		if not native_SetHTTPRequestRawPostBody(req_handle, content_type, cast("unsigned char*", body), len) then
			return http_request_error(req_handle, "failed to set post body")
		end
	elseif body ~= nil then
		return http_request_error(req_handle, "options.body has to be of type string")
	end

	local params = options.params
	if type(params) == "table" then
		for name, value in pairs(params) do
			name = tostring(name)

			if not native_SetHTTPRequestGetOrPostParameter(req_handle, name, tostring(value)) then
				return http_request_error(req_handle, "failed to set parameter " .. name)
			end
		end
	elseif params ~= nil then
		return http_request_error(req_handle, "options.params has to be of type table")
	end

	local require_ssl = options.require_ssl
	if type(require_ssl) == "boolean" then
		if not native_SetHTTPRequestRequiresVerifiedCertificate(req_handle, require_ssl == true) then
			return http_request_error(req_handle, "failed to set require_ssl")
		end
	elseif require_ssl ~= nil then
		return http_request_error(req_handle, "options.require_ssl has to be of type boolean")
	end

	local user_agent_info = options.user_agent_info
	if type(user_agent_info) == "string" then
		if not native_SetHTTPRequestUserAgentInfo(req_handle, tostring(user_agent_info)) then
			return http_request_error(req_handle, "failed to set user_agent_info")
		end
	elseif user_agent_info ~= nil then
		return http_request_error(req_handle, "options.user_agent_info has to be of type string")
	end

	local cookie_container = options.cookie_container
	if type(cookie_container) == "table" then
		local handle = cookie_containers[cookie_container]

		if handle ~= nil and handle.m_hCookieContainer ~= 0 then
			if not native_SetHTTPRequestCookieContainer(req_handle, handle.m_hCookieContainer) then
				return http_request_error(req_handle, "failed to set user_agent_info")
			end
		else
			return http_request_error(req_handle, "options.cookie_container has to a valid cookie container")
		end
	elseif cookie_container ~= nil then
		return http_request_error(req_handle, "options.cookie_container has to a valid cookie container")
	end

	local send_func = native_SendHTTPRequest
	local stream_response = options.stream_response
	if type(stream_response) == "boolean" then
		if stream_response then
			send_func = native_SendHTTPRequestAndStreamResponse

			-- at least one callback is required
			if completed_callback == nil and headers_received_callback == nil and data_received_callback == nil then
				return http_request_error(req_handle, "a 'completed', 'headers_received' or 'data_received' callback is required")
			end
		else
			-- completed callback is required and others cant be used
			if completed_callback == nil then
				return http_request_error(req_handle, "'completed' callback has to be set for non-streamed requests")
			elseif headers_received_callback ~= nil or data_received_callback ~= nil then
				return http_request_error(req_handle, "non-streamed requests only support 'completed' callbacks")
			end
		end
	elseif stream_response ~= nil then
		return http_request_error(req_handle, "options.stream_response has to be of type boolean")
	end

	if headers_received_callback ~= nil or data_received_callback ~= nil then
		headers_received_callbacks[req_handle] = headers_received_callback or false
		if headers_received_callback ~= nil then
			if not headers_received_callback_registered then
				register_callback(CALLBACK_HTTPRequestHeadersReceived, http_request_headers_received)
				headers_received_callback_registered = true
			end
		end

		data_received_callbacks[req_handle] = data_received_callback or false
		if data_received_callback ~= nil then
			if not data_received_callback_registered then
				register_callback(CALLBACK_HTTPRequestDataReceived, http_request_data_received)
				data_received_callback_registered = true
			end
		end
	end

	local call_handle = SteamAPICall_t_arr()
	if not send_func(req_handle, call_handle) then
		native_ReleaseHTTPRequest(req_handle)

		if completed_callback ~= nil then
			completed_callback(false, {status = 0, status_message = "Failed to send request"})
		end

		return
	end

	if options.priority == "defer" or options.priority == "prioritize" then
		local func = options.priority == "prioritize" and native_PrioritizeHTTPRequest or native_DeferHTTPRequest

		if not func(req_handle) then
			return http_request_error(req_handle, "failed to set priority")
		end
	elseif options.priority ~= nil then
		return http_request_error(req_handle, "options.priority has to be 'defer' of 'prioritize'")
	end

	completed_callbacks[req_handle] = completed_callback or false
	if completed_callback ~= nil then
		register_call_result(call_handle[0], http_request_completed, CALLBACK_HTTPRequestCompleted)
	end
end

local function cookie_container_new(allow_modification)
	if allow_modification ~= nil and type(allow_modification) ~= "boolean" then
		return error("allow_modification has to be of type boolean")
	end

	local handle_raw = native_CreateCookieContainer(allow_modification == true)

	if handle_raw ~= nil then
		local handle = CookieContainerHandle_t(handle_raw)
		ffi_gc(handle, cookie_container_gc)

		local key = setmetatable({}, cookie_container_mt)
		cookie_containers[key] = handle

		return key
	end
end

--
-- public module functions
--

local M = {
	request = http_request_new,
	create_cookie_container = cookie_container_new
}

-- shortcut for http methods
for method in pairs(method_name_to_enum) do
	M[method] = function(...)
		return http_request_new(method, ...)
	end
end

return M
local M = {}

--
-- dependencies
--

local ffi = require "ffi"
local csgo_weapons = require "gamesense/csgo_weapons"

local string_gsub = string.gsub
local math_floor = math.floor
local cast = ffi.cast

--
-- ffi structs
-- (mostly for image parsing)
--

local png_ihdr_t = ffi.typeof([[
struct {
	char type[4];
	uint32_t width;
	uint32_t height;
	char bitDepth;
	char colorType;
	char compression;
	char filter;
	char interlace;
} *
]])

local jpg_segment_t = ffi.typeof([[
struct {
	char type[2];
	uint16_t size;
} *
]])

local jpg_segment_sof0_t = ffi.typeof([[
struct {
	uint16_t size;
	char precision;
	uint16_t height;
	uint16_t width;
} __attribute__((packed)) *
]])

local uint16_t_ptr = ffi.typeof("uint16_t*")
local charbuffer = ffi.typeof("char[?]")
local uintbuffer = ffi.typeof("unsigned int[?]")

--
-- constants
--

local INVALID_TEXTURE = -1
local PNG_MAGIC = "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"

local JPG_MAGIC_1 = "\xFF\xD8\xFF\xDB"
local JPG_MAGIC_2 = "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01"

local JPG_SEGMENT_SOI = "\xFF\xD8"
local JPG_SEGMENT_SOF0 = "\xFF\xC0"
local JPG_SEGMENT_SOS = "\xFF\xDA"
local JPG_SEGMENT_EOI = "\xFF\xD9"

local RENDERER_LOAD_FUNCS = {
	png = renderer.load_png,
	svg = renderer.load_svg,
	jpg = renderer.load_jpg,
	rgba = renderer.load_rgba
}

--
-- utility functions
--

local function bswap_16(x)
	return bit.rshift(bit.bswap(x), 16)
end

local function hexdump(str)
	local out = {}
	str:gsub(".", function(chr)
		table.insert(out, string.format("%02x", string.byte(chr)))
	end)
	return table.concat(out, " ")
end

--
-- small filesystem implementation
--

local native_ReadFile = vtable_bind("filesystem_stdio.dll", "VBaseFileSystem011", 0, "int(__thiscall*)(void*, void*, int, void*)")
local native_OpenFile = vtable_bind("filesystem_stdio.dll", "VBaseFileSystem011", 2, "void*(__thiscall*)(void*, const char*, const char*, const char*)")
local native_CloseFile = vtable_bind("filesystem_stdio.dll", "VBaseFileSystem011", 3, "void(__thiscall*)(void*, void*)")
local native_GetFileSize = vtable_bind("filesystem_stdio.dll", "VBaseFileSystem011", 7, "unsigned int(__thiscall*)(void*, void*)")

local function engine_read_file(filename)
	local handle = native_OpenFile(filename, "r", "MOD")
	if handle == nil then return end

	local filesize = native_GetFileSize(handle)
	if filesize == nil or filesize < 0 then return end

	local buffer = charbuffer(filesize + 1)
	if buffer == nil then return end

	local read_success = native_ReadFile(buffer, filesize, handle)
	if not read_success then return end

	return ffi.string(buffer, filesize)
end

--
-- ISteamFriends / ISteamUtils
--

-- That shit now use ingame context of steamapi instead of connecting to global user
-- enjoy, by w7rus

ffi.cdef([[
	typedef struct
	{
		void* steam_client;
		void* steam_user;
		void* steam_friends;
		void* steam_utils;
		void* steam_matchmaking;
		void* steam_user_stats;
		void* steam_apps;
		void* steam_matchmakingservers;
		void* steam_networking;
		void* steam_remotestorage;
		void* steam_screenshots;
		void* steam_http;
		void* steam_unidentifiedmessages;
		void* steam_controller;
		void* steam_ugc;
		void* steam_applist;
		void* steam_music;
		void* steam_musicremote;
		void* steam_htmlsurface;
		void* steam_inventory;
		void* steam_video;
	} S_steamApiCtx_t;
]])

local pS_SteamApiCtx = ffi.cast(
	"S_steamApiCtx_t**", ffi.cast(
		"char*",
		client.find_signature(
			"client_panorama.dll",
			"\xFF\x15\xCC\xCC\xCC\xCC\xB9\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x6A"
		)
	) + 7
)[0] or error("invalid interface", 2)

local native_ISteamFriends = ffi.cast("void***", pS_SteamApiCtx.steam_friends)
local native_ISteamUtils = ffi.cast("void***", pS_SteamApiCtx.steam_utils)

local native_ISteamFriends_GetSmallFriendAvatar = vtable_thunk(34, "int(__thiscall*)(void*, uint64_t)")
local native_ISteamFriends_GetMediumFriendAvatar = vtable_thunk(35, "int(__thiscall*)(void*, uint64_t)")
local native_ISteamFriends_GetLargeFriendAvatar = vtable_thunk(36, "int(__thiscall*)(void*, uint64_t)")

local native_ISteamUtils_GetImageSize = vtable_thunk(5, "bool(__thiscall*)(void*, int, uint32_t*, uint32_t*)")
local native_ISteamUtils_GetImageRGBA = vtable_thunk(6, "bool(__thiscall*)(void*, int, unsigned char*, int)")

--
-- image object implementation
--

local function image_measure(self, width, height)
	if width ~= nil and height ~= nil then
		return width, height
	else
		if self.width == nil or self.height == nil then
			error("Image dimensions not known, full size is required")
		elseif width == nil then
			height = height or self.height
			local width = math_floor(self.width * (height/self.height))
			return width, height
		elseif height == nil then
			width = width or self.width
			local height = math_floor(self.height * (width/self.width))
			return width, height
		else
			return self.width, self.height
		end
	end
end

local function image_draw(self, x, y, width, height, r, g, b, a, force_same_res_render, flags)
	width, height = image_measure(self, width, height)

	local id = string.format("%f_%f", width, height)
	local texture = self.textures[id]

	-- no texture with same width and height has been loaded
	if texture == nil then
		if ({next(self.textures)})[2] == nil or force_same_res_render or force_same_res_render == nil then
			-- try and load the texture
			local func = RENDERER_LOAD_FUNCS[self.type]
			if func then
				if self.type == "rgba" then
					width, height = self.width, self.height
				end
				texture = func(self.contents, width, height)
			end

			if texture == nil then
				self.textures[id] = INVALID_TEXTURE
				error("failed to load texture for " .. width .. "x" .. height, 2)
			else
				-- client.log("loaded svg ", self.name, " for ", width, "x", height)
				self.textures[id] = texture
			end
		else
			--right now we just choose a random texture (determined by the pairs order aka unordered)
			--todo: select the texture with the highest or closest resolution?
			texture = ({next(self.textures)})[2]
		end
	end

	if texture == nil or texture == INVALID_TEXTURE then
		return
	elseif a == nil or a > 0 then
		renderer.texture(texture, x, y, width, height, r or 255, g or 255, b or 255, a or 255, flags or "f")
	end

	return width, height
end

local image_mt = {
	__index = {
		measure = image_measure,
		draw = image_draw
	}
}

--
-- functions for loading images
--

local function load_png(contents)
	if contents:sub(1, 8) ~= PNG_MAGIC then
		error("Invalid magic", 2)
		return
	end

	local ihdr_raw = contents:sub(13, 30)
	if ihdr_raw:len() < 17 then
		error("Incomplete data", 2)
		return
	end

	local ihdr = cast(png_ihdr_t, cast("const uint8_t *", cast("const char*", ihdr_raw)))

	if ffi.string(ihdr.type, 4) ~= "IHDR" then
		error("Invalid chunk type, expected IHDR", 2)
		return
	end

	local width = bit.bswap(ihdr.width)
	local height = bit.bswap(ihdr.height)

	if width <= 0 or height <= 0 then
		error("Invalid width or height", 2)
		return
	end

	return setmetatable({
		type = "png",
		width = width,
		height = height,
		contents = contents,
		textures = {}
	}, image_mt)
end

local function load_jpg(contents)
	local buffer = ffi.cast("const uint8_t *", ffi.cast("const char *", contents))
	local len_remaining = contents:len()

	local width, height

	if contents:sub(1, 4) == JPG_MAGIC_1 or contents:sub(1, 12) == JPG_MAGIC_2 then
		local got_soi, got_sos = false, false

		-- read segments until we find a SOF0 header (containing width/height)
		while len_remaining > 0 do
			local segment = ffi.cast(jpg_segment_t, buffer)
			local typ = ffi.string(segment.type, 2)

			buffer = buffer + 2
			len_remaining = len_remaining - 2

			if typ == JPG_SEGMENT_SOI then
				got_soi = true
			elseif not got_soi then
				error("expected SOI segment", 2)
			elseif typ == JPG_SEGMENT_SOS or typ == JPG_SEGMENT_EOI then
				if typ == JPG_SEGMENT_SOS then
					got_sos = true
				end
				break
			else
				-- endian convert of the size (be -> le)
				local size = bswap_16(segment.size)

				if typ == JPG_SEGMENT_SOF0 then
					local sof0 = cast(jpg_segment_sof0_t, buffer)

					height = bswap_16(sof0.height)
					width = bswap_16(sof0.width)

					if width <= 0 or height <= 0 then
						error("Invalid width or height")
						return
					end
				end

				buffer = buffer + size
				len_remaining = len_remaining - size
			end
		end

		if not got_soi then
			error("Incomplete image, missing SOI segment", 2)
			return
		elseif not got_sos then
			error("Incomplete image, missing SOS segment", 2)
			return
		elseif width == nil then
			error("Incomplete image, missing SOF0 segment", 2)
			return
		end
	else
		error("Invalid magic", 2)
		return
	end

	return setmetatable({
		type = "jpg",
		width = width,
		height = height,
		contents = contents,
		textures = {}
	}, image_mt)
end

local function load_svg(contents)
	-- try and find <svg> tag

	local match = contents:match("<svg(.*)>.*</svg>")
	if match == nil then
		error("Invalid svg, missing <svg> tag", 2)
		return
	end

	match = match:gsub("\r\n", ""):gsub("\n", "")

	-- parse tag contents
	local in_quote = false
	local key, value = "", ""

	local attributes = {}

	local offset = 1
	while true do
		local chr = match:sub(offset, offset)

		if chr == "" then
			break
		end

		if in_quote then
			-- text inside quotation marks
			if chr == "\"" then
				in_quote = false
				attributes[key:gsub("\t", ""):lower()] = value
				key, value = "", ""
			else
				value = value .. chr
			end
		else
			-- normal text, not inside quotes
			if chr == ">" then
				break
			elseif chr == "=" then
				if match:sub(offset, offset+1) == "=\"" then
					in_quote = true
					offset = offset + 1
				end
			elseif chr == " " then
				key = ""
			else
				key = key .. chr
			end
		end

		offset = offset + 1
	end

	-- heuristics to find valid image width and height
	local width, height

	if attributes["width"] ~= nil then
		width = tonumber((attributes["width"]:gsub("px$", ""):gsub("pt$", ""):gsub("mm$", "")))

		if width ~= nil and 0 >= width then
			width = nil
		end
	end

	if attributes["height"] ~= nil then
		height = tonumber((attributes["height"]:gsub("px$", ""):gsub("pt$", ""):gsub("mm$", "")))

		if height ~= nil and 0 >= height then
			height = nil
		end
	end

	if width == nil or height == nil and attributes["viewbox"] ~= nil then
		local x, y, w, h = attributes["viewbox"]:match("^%s*([%d.]*) ([%d.]*) ([%d.]*) ([%d.]*)%s*$")

		width, height = tonumber(width), tonumber(height)

		if width ~= nil and height ~= nil and (0 >= width or 0 >= height) then
			width, height = nil, nil
		end
	end

	local self = setmetatable({
		type = "svg",
		contents = contents,
		textures = {}
	}, image_mt)

	if width ~= nil and height ~= nil and width > 0 and height > 0 then
		self.width, self.height = width, height
	end

	return self
end

local function load_rgba(contents, width, height)
	if width == nil or height == nil or width <= 0 or height <= 0 then
		error("Invalid size: width and height are required and have to be greater than zero.")
		return
	end

	local size = width*height*4
	if contents:len() ~= size then
		error("invalid buffer length, expected width*height*4", 2)
		return
	end

	-- load texture
	local texture = renderer.load_rgba(contents, width, height)
	if texture == nil then
		return
	end

	return setmetatable({
		type = "rgba",
		width = width,
		height = height,
		contents = contents,
		textures = {[string.format("%f_%f", width, height)] = texture}
	}, image_mt)
end

local function load_image(contents)
	if type(contents) == "table" then
		if getmetatable(contents) == image_mt then
			return error("trying to load an existing image")
		else
			local result = {}
			for key, value in pairs(contents) do
				result[key] = load_image(value)
			end
			return result
		end
	else
		-- try and determine type etc by looking for magic value
		if type(contents) == "string" then
			if contents:sub(1, 8) == PNG_MAGIC then
				return load_png(contents)
			elseif contents:sub(1, 4) == JPG_MAGIC_1 or contents:sub(1, 12) == JPG_MAGIC_2 then
				return load_jpg(contents)
			elseif contents:match("^%s*%<%?xml") ~= nil then
				return load_svg(contents)
			else
				return error("Failed to determine image type")
			end
		end
	end
end

local panorama_images = setmetatable({},  {__mode = "k"})
local function get_panorama_image(path)
	if panorama_images[path] == nil then
		local path_cleaned = string_gsub(string_gsub(string_gsub(string_gsub(string_gsub(path, "%z", ""), "%c", ""), "\\", "/"), "%.%./", ""), "^/+", "")
		local contents = engine_read_file("materials/panorama/images/" .. path_cleaned)

		if contents then
			local image = load_image(contents)

			panorama_images[path] = image
		else
			panorama_images[path] = false
		end
	end

	if panorama_images[path] then
		return panorama_images[path]
	end
end

local weapon_icons = setmetatable({}, {__mode = "k"})
local function get_weapon_icon(weapon_name)
	if weapon_icons[weapon_name] == nil then
		local weapon_name_cleaned
		local typ = type(weapon_name)

		if typ == "table" and weapon_name.console_name ~= nil then
			weapon_name_cleaned = weapon_name.console_name
		elseif typ == "number" then
			local weapon = csgo_weapons[weapon_name]
			if weapon == nil then
				weapon_icons[weapon_name] = false
				return
			end
			weapon_name_cleaned = weapon.console_name
		elseif typ == "string" then
			weapon_name_cleaned = tostring(weapon_name)
		elseif weapon_name ~= nil then
			weapon_icons[weapon_name] = nil
			return
		else
			return
		end

		weapon_name_cleaned = string_gsub(string_gsub(weapon_name_cleaned, "^weapon_", ""), "^item_", "")

		local image = get_panorama_image("icons/equipment/" .. weapon_name_cleaned .. ".svg")
		weapon_icons[weapon_name] = image or false
	end

	if weapon_icons[weapon_name] then
		return weapon_icons[weapon_name]
	end
end

local steam_avatars = {}
local function get_steam_avatar(steamid3_or_steamid64, size)
	local cache_key = string.format("%s_%d", steamid3_or_steamid64, size or 32)

	if steam_avatars[cache_key] == nil then
		local func
		if size == nil then
			func = native_ISteamFriends_GetSmallFriendAvatar
		elseif size > 64 then
			func = native_ISteamFriends_GetLargeFriendAvatar
		elseif size > 32 then
			func = native_ISteamFriends_GetMediumFriendAvatar
		else
			func = native_ISteamFriends_GetSmallFriendAvatar
		end

		local steamid
		if type(steamid3_or_steamid64) == "string" then
			steamid = 76500000000000000ULL + tonumber(steamid3_or_steamid64:sub(4, -1))
		elseif type(steamid3_or_steamid64) == "number" then
			steamid = 76561197960265728ULL + steamid3_or_steamid64
		else
			return
		end

		local handle = func(native_ISteamFriends, steamid)

		if handle > 0 then
			local width = uintbuffer(1)
			local height = uintbuffer(1)
			if native_ISteamUtils_GetImageSize(native_ISteamUtils, handle, width, height) then
				if width[0] > 0 and height[0] > 0 then
					local rgba_buffer_size = width[0]*height[0]*4
					local rgba_buffer = charbuffer(rgba_buffer_size)

					if native_ISteamUtils_GetImageRGBA(native_ISteamUtils, handle, rgba_buffer, rgba_buffer_size) then
						steam_avatars[cache_key] = load_rgba(ffi.string(rgba_buffer, rgba_buffer_size), width[0], height[0])
					end
				end
			end
		elseif handle ~= -1 then
			steam_avatars[cache_key] = false
		end
	end

	if steam_avatars[cache_key] then
		return steam_avatars[cache_key]
	end
end

return {
	load = load_image,
	load_png = load_png,
	load_jpg = load_jpg,
	load_svg = load_svg,
	load_rgba = load_rgba,
	get_weapon_icon = get_weapon_icon,
	get_panorama_image = get_panorama_image,
	get_steam_avatar = get_steam_avatar
}
local inspect ={
	_VERSION = 'inspect.lua 3.1.0',
	_URL		 = 'http://github.com/kikito/inspect.lua',
	_DESCRIPTION = 'human-readable representations of tables',
	_LICENSE = [[
		MIT LICENSE

		Copyright (c) 2013 Enrique Garca Cota

		Permission is hereby granted, free of charge, to any person obtaining a
		copy of this software and associated documentation files (the
		"Software"), to deal in the Software without restriction, including
		without limitation the rights to use, copy, modify, merge, publish,
		distribute, sublicense, and/or sell copies of the Software, and to
		permit persons to whom the Software is furnished to do so, subject to
		the following conditions:

		The above copyright notice and this permission notice shall be included
		in all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	]]
}

local tostring = tostring

inspect.KEY			 = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})

local function rawpairs(t)
	return next, t, nil
end

-- Apostrophizes the string if it has quotes, but not aphostrophes
-- Otherwise, it returns a regular quoted string
local function smartQuote(str)
	if str:match('"') and not str:match("'") then
		return "'" .. str .. "'"
	end
	return '"' .. str:gsub('"', '\\"') .. '"'
end

-- \a => '\\a', \0 => '\\0', 31 => '\31'
local shortControlCharEscapes = {
	["\a"] = "\\a",	["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
	["\r"] = "\\r",	["\t"] = "\\t", ["\v"] = "\\v"
}
local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
for i=0, 31 do
	local ch = string.char(i)
	if not shortControlCharEscapes[ch] then
		shortControlCharEscapes[ch] = "\\"..i
		longControlCharEscapes[ch]	= string.format("\\%03d", i)
	end
end

local function escape(str)
	return (str:gsub("\\", "\\\\")
						 :gsub("(%c)%f[0-9]", longControlCharEscapes)
						 :gsub("%c", shortControlCharEscapes))
end

local function isIdentifier(str)
	return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
end

local function isSequenceKey(k, sequenceLength)
	return type(k) == 'number'
		 and 1 <= k
		 and k <= sequenceLength
		 and math.floor(k) == k
end

local defaultTypeOrders = {
	['number']	 = 1, ['boolean']	= 2, ['string'] = 3, ['table'] = 4,
	['function'] = 5, ['userdata'] = 6, ['thread'] = 7
}

local function sortKeys(a, b)
	local ta, tb = type(a), type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if ta == tb and (ta == 'string' or ta == 'number') then return a < b end

	local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
	-- Two default types are compared according to the defaultTypeOrders table
	if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
	elseif dta		 then return true	-- default types before custom ones
	elseif dtb		 then return false -- custom types after default ones
	end

	-- custom types are sorted out alphabetically
	return ta < tb
end

-- For implementation reasons, the behavior of rawlen & # is "undefined" when
-- tables aren't pure sequences. So we implement our own # operator.
local function getSequenceLength(t)
	local len = 1
	local v = rawget(t,len)
	while v ~= nil do
		len = len + 1
		v = rawget(t,len)
	end
	return len - 1
end

local function getNonSequentialKeys(t)
	local keys, keysLength = {}, 0
	local sequenceLength = getSequenceLength(t)
	for k,_ in rawpairs(t) do
		if not isSequenceKey(k, sequenceLength) then
			keysLength = keysLength + 1
			keys[keysLength] = k
		end
	end
	table.sort(keys, sortKeys)
	return keys, keysLength, sequenceLength
end

local function countTableAppearances(t, tableAppearances)
	tableAppearances = tableAppearances or {}

	if type(t) == 'table' then
		if not tableAppearances[t] then
			tableAppearances[t] = 1
			for k,v in rawpairs(t) do
				countTableAppearances(k, tableAppearances)
				countTableAppearances(v, tableAppearances)
			end
			countTableAppearances(getmetatable(t), tableAppearances)
		else
			tableAppearances[t] = tableAppearances[t] + 1
		end
	end

	return tableAppearances
end

local copySequence = function(s)
	local copy, len = {}, #s
	for i=1, len do copy[i] = s[i] end
	return copy, len
end

local function makePath(path, ...)
	local keys = {...}
	local newPath, len = copySequence(path)
	for i=1, #keys do
		newPath[len + i] = keys[i]
	end
	return newPath
end

local function processRecursive(process, item, path, visited)
	if item == nil then return nil end
	if visited[item] then return visited[item] end

	local processed = process(item, path)
	if type(processed) == 'table' then
		local processedCopy = {}
		visited[item] = processedCopy
		local processedKey

		for k,v in rawpairs(processed) do
			processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
			if processedKey ~= nil then
				processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
			end
		end

		local mt	= processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
		if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field
		setmetatable(processedCopy, mt)
		processed = processedCopy
	end
	return processed
end



-------------------------------------------------------------------

local Inspector = {}
local Inspector_mt = {__index = Inspector}

function Inspector:puts(...)
	local args	 = {...}
	local buffer = self.buffer
	local len		= #buffer
	for i=1, #args do
		len = len + 1
		buffer[len] = args[i]
	end
end

function Inspector:down(f)
	self.level = self.level + 1
	f()
	self.level = self.level - 1
end

function Inspector:tabify()
	self:puts(self.newline, string.rep(self.indent, self.level))
end

function Inspector:alreadyVisited(v)
	return self.ids[v] ~= nil
end

function Inspector:getId(v)
	local id = self.ids[v]
	if not id then
		local tv = type(v)
		id							= (self.maxIds[tv] or 0) + 1
		self.maxIds[tv] = id
		self.ids[v]		 = id
	end
	return tostring(id)
end

function Inspector:putKey(k)
	if isIdentifier(k) then return self:puts(k) end
	self:puts("[")
	self:putValue(k)
	self:puts("]")
end

function Inspector:putTable(t)
	if t == inspect.KEY or t == inspect.METATABLE then
		self:puts(tostring(t))
	elseif self:alreadyVisited(t) then
		self:puts('<table ', self:getId(t), '>')
	elseif self.level >= self.depth then
		self:puts('{...}')
	else
		if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end

		local nonSequentialKeys, nonSequentialKeysLength, sequenceLength = getNonSequentialKeys(t)
		local mt								= getmetatable(t)

		self:puts('{')
		self:down(function()
			local count = 0
			for i=1, sequenceLength do
				if count > 0 then self:puts(',') end
				self:puts(' ')
				self:putValue(t[i])
				count = count + 1
			end

			for i=1, nonSequentialKeysLength do
				local k = nonSequentialKeys[i]
				if count > 0 then self:puts(',') end
				self:tabify()
				self:putKey(k)
				self:puts(' = ')
				self:putValue(t[k])
				count = count + 1
			end

			if type(mt) == 'table' then
				if count > 0 then self:puts(',') end
				self:tabify()
				self:puts('<metatable> = ')
				self:putValue(mt)
			end
		end)

		if nonSequentialKeysLength > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }
			self:tabify()
		elseif sequenceLength > 0 then -- array tables have one extra space before closing }
			self:puts(' ')
		end

		self:puts('}')
	end
end

function Inspector:putValue(v)
	local tv = type(v)

	if tv == 'string' then
		self:puts(smartQuote(escape(v)))
	elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
				 tv == 'cdata' or tv == 'ctype' then
		self:puts(tostring(v))
	elseif tv == 'table' then
		self:putTable(v)
	else
		self:puts('<', tv, ' ', self:getId(v), '>')
	end
end

-------------------------------------------------------------------

function inspect.inspect(root, options)
	options			 = options or {}

	local depth	 = options.depth	 or math.huge
	local newline = options.newline or '\n'
	local indent	= options.indent	or '	'
	local process = options.process

	if process then
		root = processRecursive(process, root, {}, {})
	end

	local inspector = setmetatable({
		depth						= depth,
		level						= 0,
		buffer					 = {},
		ids							= {},
		maxIds					 = {},
		newline					= newline,
		indent					 = indent,
		tableAppearances = countTableAppearances(root)
	}, Inspector_mt)

	inspector:putValue(root)

	return table.concat(inspector.buffer)
end

setmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })

return inspect
local js = panorama.loadstring([[
	return {
		localize: (str, params) => {
			if(params == null)
				return $.Localize(str)

			var panel = $.CreatePanel("Panel", $.GetContextPanel(), "")

			for(key in params) {
				panel.SetDialogVariable(key, params[key])
			}

			var result = $.Localize(str, panel)

			panel.DeleteAsync(0.0)

			return result
		},
		language: () => {
			return $.Language()
		}
	}
]])()

local localize_cache = {}
local function localize(str, params)
	if str == nil then return "" end

	if localize_cache[str] == nil then
		localize_cache[str] = {}
	end

	local params_key = params ~= nil and json.stringify(params) or true
	if localize_cache[str][params_key] == nil then
		localize_cache[str][params_key] = js.localize(str, params)
	end

	return localize_cache[str][params_key]
end

return setmetatable({
	localize = localize,
	language = js.language
}, {
	__call = function(tbl, ...)
		return localize(...)
	end
})
local md5 = {
}

-- bit lib implementions
local char, byte, format, rep, sub = string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
	local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
	return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
	local v=0
	for i=1, #s do
		v = v * 256 + byte(s, i)
	end
	return v
end

-- convert raw string to little-endian int
local function str2lei(s)
	local v=0
	for i = #s,1,-1 do
		v = v*256 + byte(s, i)
	end
	return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
	local o, r = 1, {}
	local args = {...}
	for i=1, #args do
		table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
		o = o + args[i]
	end
	return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
	0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
	0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
	0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
	0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
	0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
	0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
	0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
	0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
	0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
	0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
	0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
	0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
	0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
	0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
	a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
	-- be *very* careful that left shift does not cause rounding!
	return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
	local a,b,c,d=A,B,C,D
	local t=CONSTS

	a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
	d=z(f,d,a,b,c,X[ 1],12,t[ 2])
	c=z(f,c,d,a,b,X[ 2],17,t[ 3])
	b=z(f,b,c,d,a,X[ 3],22,t[ 4])
	a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
	d=z(f,d,a,b,c,X[ 5],12,t[ 6])
	c=z(f,c,d,a,b,X[ 6],17,t[ 7])
	b=z(f,b,c,d,a,X[ 7],22,t[ 8])
	a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
	d=z(f,d,a,b,c,X[ 9],12,t[10])
	c=z(f,c,d,a,b,X[10],17,t[11])
	b=z(f,b,c,d,a,X[11],22,t[12])
	a=z(f,a,b,c,d,X[12], 7,t[13])
	d=z(f,d,a,b,c,X[13],12,t[14])
	c=z(f,c,d,a,b,X[14],17,t[15])
	b=z(f,b,c,d,a,X[15],22,t[16])

	a=z(g,a,b,c,d,X[ 1], 5,t[17])
	d=z(g,d,a,b,c,X[ 6], 9,t[18])
	c=z(g,c,d,a,b,X[11],14,t[19])
	b=z(g,b,c,d,a,X[ 0],20,t[20])
	a=z(g,a,b,c,d,X[ 5], 5,t[21])
	d=z(g,d,a,b,c,X[10], 9,t[22])
	c=z(g,c,d,a,b,X[15],14,t[23])
	b=z(g,b,c,d,a,X[ 4],20,t[24])
	a=z(g,a,b,c,d,X[ 9], 5,t[25])
	d=z(g,d,a,b,c,X[14], 9,t[26])
	c=z(g,c,d,a,b,X[ 3],14,t[27])
	b=z(g,b,c,d,a,X[ 8],20,t[28])
	a=z(g,a,b,c,d,X[13], 5,t[29])
	d=z(g,d,a,b,c,X[ 2], 9,t[30])
	c=z(g,c,d,a,b,X[ 7],14,t[31])
	b=z(g,b,c,d,a,X[12],20,t[32])

	a=z(h,a,b,c,d,X[ 5], 4,t[33])
	d=z(h,d,a,b,c,X[ 8],11,t[34])
	c=z(h,c,d,a,b,X[11],16,t[35])
	b=z(h,b,c,d,a,X[14],23,t[36])
	a=z(h,a,b,c,d,X[ 1], 4,t[37])
	d=z(h,d,a,b,c,X[ 4],11,t[38])
	c=z(h,c,d,a,b,X[ 7],16,t[39])
	b=z(h,b,c,d,a,X[10],23,t[40])
	a=z(h,a,b,c,d,X[13], 4,t[41])
	d=z(h,d,a,b,c,X[ 0],11,t[42])
	c=z(h,c,d,a,b,X[ 3],16,t[43])
	b=z(h,b,c,d,a,X[ 6],23,t[44])
	a=z(h,a,b,c,d,X[ 9], 4,t[45])
	d=z(h,d,a,b,c,X[12],11,t[46])
	c=z(h,c,d,a,b,X[15],16,t[47])
	b=z(h,b,c,d,a,X[ 2],23,t[48])

	a=z(i,a,b,c,d,X[ 0], 6,t[49])
	d=z(i,d,a,b,c,X[ 7],10,t[50])
	c=z(i,c,d,a,b,X[14],15,t[51])
	b=z(i,b,c,d,a,X[ 5],21,t[52])
	a=z(i,a,b,c,d,X[12], 6,t[53])
	d=z(i,d,a,b,c,X[ 3],10,t[54])
	c=z(i,c,d,a,b,X[10],15,t[55])
	b=z(i,b,c,d,a,X[ 1],21,t[56])
	a=z(i,a,b,c,d,X[ 8], 6,t[57])
	d=z(i,d,a,b,c,X[15],10,t[58])
	c=z(i,c,d,a,b,X[ 6],15,t[59])
	b=z(i,b,c,d,a,X[13],21,t[60])
	a=z(i,a,b,c,d,X[ 4], 6,t[61])
	d=z(i,d,a,b,c,X[11],10,t[62])
	c=z(i,c,d,a,b,X[ 2],15,t[63])
	b=z(i,b,c,d,a,X[ 9],21,t[64])

	return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
				 bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
	self.pos = self.pos + #s
	s = self.buf .. s
	for ii = 1, #s - 63, 64 do
		local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
		assert(#X == 16)
		X[0] = table.remove(X,1) -- zero based!
		self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
	end
	self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
	return self
end

local function md5_finish(self)
	local msgLen = self.pos
	local padLen = 56 - msgLen % 64

	if msgLen % 64 > 56 then padLen = padLen + 64 end

	if padLen == 0 then padLen = 64 end

	local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
	md5_update(self, s)

	assert(self.pos % 64 == 0)
	return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
	return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
					 pos = 0,
					 buf = '',
					 update = md5_update,
					 finish = md5_finish }
end

function md5.tohex(s)
	return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
	return md5.new():update(s):finish()
end

function md5.sumhexa(s)
	return md5.tohex(md5.sum(s))
end

return md5
local ffi = require "ffi"

local string_match, string_len, string_gsub, string_gmatch, string_byte = string.match, string.len, string.gsub, string.gmatch, string.byte
local cast, typeof, ffi_string = ffi.cast, ffi.typeof, ffi.string

local pGetModuleHandle_sig = client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B") or error("Couldn't find signature #1")
local pGetProcAddress_sig = client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05") or error("Couldn't find signature #2")

local jmp_ecx = client.find_signature("engine.dll", "\xFF\xE1")

local pGetProcAddress = cast("uint32_t**", cast("uint32_t", pGetProcAddress_sig) + 2)[0][0]
local fnGetProcAddress = cast("uint32_t(__fastcall*)(unsigned int, unsigned int, uint32_t, const char*)", jmp_ecx)

local pGetModuleHandle = cast("uint32_t**", cast("uint32_t", pGetModuleHandle_sig) + 2)[0][0]
local fnGetModuleHandle = cast("uint32_t(__fastcall*)(unsigned int, unsigned int, const char*)", jmp_ecx)

local function proc_bind(module_name, function_name, typedef)
	local ctype = typeof(typedef)
	local module_handle = fnGetModuleHandle(pGetModuleHandle, 0, module_name)
	local proc_address = fnGetProcAddress(pGetProcAddress, 0, module_handle, function_name)
	local call_fn = cast(ctype, jmp_ecx)

	return function(...)
		return call_fn(proc_address, 0, ...)
	end
end

local ulong_arr = typeof("unsigned long[?]")
local char_ptr = typeof("const char*")
local char_arr = typeof("const char[?]")
local ushort_ptr = typeof("unsigned short*")
local ushort_arr = typeof("unsigned short[?]")

local function to_wchar(str)
	local size = string_len(str)+1
	local buffer = ushort_arr(size)

	local i = 0
	for c in string_gmatch(str, ".") do
		buffer[i] = string_byte(c)

		i = i + 1
	end

	return cast(ushort_ptr, buffer)
end

local native_CreateFileW = proc_bind("kernel32.dll", "CreateFileW", "void*(__fastcall*)(unsigned int, unsigned int, const wchar_t*, unsigned long, unsigned long, void*, unsigned long, unsigned long, void*)")
local native_CloseHandle = proc_bind("kernel32.dll", "CloseHandle", "bool(__fastcall*)(unsigned int, unsigned int, void*)")
local native_WriteFile = proc_bind("kernel32.dll", "WriteFile", "bool(__fastcall*)(unsigned int, unsigned int, void*, const char*, unsigned long, unsigned long*, unsigned long*)")
local native_ReadFile = proc_bind("kernel32.dll", "ReadFile", "bool(__fastcall*)(unsigned int, unsigned int, void*, const char*, unsigned long, unsigned long*, unsigned long*)")
local native_PeekNamedPipe = proc_bind("kernel32.dll", "PeekNamedPipe", "bool(__fastcall*)(unsigned int, unsigned int, void*, void*, unsigned long, unsigned long*, unsigned long*, unsigned long*)")
local native_GetLastError = proc_bind("kernel32.dll", "GetLastError", "unsigned long(__fastcall*)(unsigned int, unsigned int)")
local native_GetFileType = proc_bind("kernel32.dll", "GetFileType", "unsigned long(__fastcall*)(unsigned int, unsigned int, void*)")

local GENERIC_READ = 0x80000000
local GENERIC_WRITE = 0x40000000
local GENERIC_READ_WRITE = bit.bor(GENERIC_READ, GENERIC_WRITE)

local CREATE_NEW = 1
local OPEN_EXISTING = 3

local FILE_NORMAL_DELETE_ON_CLOSE = 0x04000080
local FILE_ATTRIBUTE_NORMAL = 0x80

local FILE_TYPE_PIPE = 0x0003

local INVALID_HANDLE_VALUE = ffi.cast("void*", -1)

-- set up metatable
local named_pipe_mt = {}

-- store private data for open pipes here
local open_pipes = {}

--
-- GetLastError and nice formatting
--

local ERROR_CODES = {
	[0x02] = "File not found",
	[0x03] = "Path not found",
	[0x05] = "Access denied",
	[0x50] = "File exists",
	[0x6D] = "Broken pipe",
	[0xE6] = "Bad pipe",
	[0xE7] = "Pipe busy"
}

local function get_last_error()
	local err = native_GetLastError()

	return ERROR_CODES[err] or tostring(err)
end

--
-- open new named pipe
--

local function open_pipe(path)
	if type(path) ~= "string" then
		return error("Invalid path, expected string", 2)
	elseif not string_match(path, "^\\\\%?\\pipe\\") then
		return error("Invalid path, expected \\\\?\\pipe\\", 2)
	end

	local path_wchar = to_wchar(path)
	local handle = native_CreateFileW(path_wchar, GENERIC_READ_WRITE, 0, nil, OPEN_EXISTING, 0, nil)

	if handle == INVALID_HANDLE_VALUE then
		return error("Failed to open pipe: " .. get_last_error())
	elseif native_GetFileType(handle) ~= FILE_TYPE_PIPE then
		native_CloseHandle(handle)
		return error("Failed to open pipe: Invalid file type")
	end

	-- tbl returned to the user
	local tbl = setmetatable({
		path = path
	}, named_pipe_mt)

	-- store stuff hidden from user here
	open_pipes[tbl] = {
		handle = handle,
		open = true
	}

	return tbl
end

local function close_pipe(self)
	local open_pipe = open_pipes[self]
	if open_pipe == nil then
		return error("Invalid pipe")
	end

	open_pipes[self] = nil
	if not native_CloseHandle(open_pipe.handle) then
		return error("Failed to close pipe: " .. get_last_error())
	end
end

local function write_pipe(self, data)
	local open_pipe = open_pipes[self]
	if open_pipe == nil then
		return error("Invalid pipe")
	end

	data = tostring(data) or ""

	local bytes_written = ulong_arr(1)
	local len = string_len(data)

	if native_WriteFile(open_pipe.handle, data, len, bytes_written, nil) then
		return tonumber(bytes_written[0])
	else
		return error("Failed to write: " .. get_last_error())
	end
end

local function read_pipe(self, size)
	if size ~= nil then
		if type(size) ~= "number" then
			return error("Invalid size, expected number or nil", 2)
		elseif 0 > size then
			return error("Invalid size", 2)
		end
	end

	local open_pipe = open_pipes[self]
	if open_pipe == nil then
		return error("Invalid pipe")
	end

	local bytes_available = ulong_arr(1)
	if native_PeekNamedPipe(open_pipe.handle, nil, 0, nil, bytes_available, nil) then
		local avail = bytes_available[0]

		if size == nil and avail > 0 then
			-- size wasn't set, read all thats available
			size = avail
		elseif size ~= nil and size > avail then
			-- size was set but not enough data is available. read nothing
			size = nil
		end

		if size ~= nil then
			local out_buffer = char_arr(size)
			local bytes_read = ulong_arr(1)

			local read_success = native_ReadFile(open_pipe.handle, out_buffer, size, bytes_read, nil)

			if read_success and bytes_read[0] == size then
				return ffi_string(out_buffer, size)
			else
				return error("Failed to read: " .. get_last_error())
			end
		end
	else
		return error("Failed to peek: " .. get_last_error())
	end
end

-- set up index table
named_pipe_mt.__index = {
	close = close_pipe,
	read = read_pipe,
	write = write_pipe
}

-- close all open pipes on shutdown
client.set_event_callback("shutdown", function()
	for key, _ in pairs(open_pipes) do
		pcall(close_pipe, key)
	end
end)

return {
	open_pipe = open_pipe
}
--
-- auto-generated by build script
--

--region Setup

-- table mapping lib name -> inlined library
local libraries = {}

-- table mapping lib name -> return value, with fallback to calling the library
local return_values = setmetatable({}, {
	__index = function(tbl, key)
		tbl[key] = libraries[key]()

		return tbl[key]
	end
})

--endregion

--region Framework
libraries["Framework"] = function()
	--region Setup
  local errorMessage = {
  	invalidInstantiationType = "Attempted to instantiate %s, but it's a type of %s and does not support instances.",
  	invalidClass = "Attempted to reference an invalid class. Classes must be setup with their respective functions before being used.",
  	invalidClassFormat = "Attempted to setup a class from a non-table input. Input must be a table.",
  	classAlreadyExists = "Attempted to setup %s, but it has already been setup.",
  	abstractContractViolated = "%s has the abstract method '%s' but does not implement it. Please override all abstract methods.",
  	interfaceContractViolated = "%s has the interface method '%s' but does not implement it. Please implement all interface methods.",
  	invalidAbstractParent = "%s has the parent %s of type %s, but abstracts may only have other abstracts or interfaces as parents.",
  	invalidEnumParent = "%s has the parent %s of type %s, but enums may only have other enums or interfaces as parents.",
  	invalidInterfaceParent = "%s has the parent %s of type %s, but interfaces may only inherit other interfaces.",
  	invalidInterfaceMember = "%s has declared the non-function member '%s'. Interfaces may only declare empty functions.",
  	calledAbstractMethod = "Attempted to call abstract method.",
  	invalidFieldsType = "Attempted to create an object on '%s' where its fields is not a table."
  }
  
  --- @vararg string
  local function die(...)
  	error(string.format(...), 2)
  end
  
  local classtype = {
  	class = 1,
  	abstract = 2,
  	enum = 3,
  	interface = 4,
  	exception = 5
  }
  
  local classtypeName = {
  	[1] = "class",
  	[2] = "abstract",
  	[3] = "enum",
  	[4] = "interface",
  	[5] = "exception"
  }
  
  local instantiable = {
  	[classtype.class] = true,
  	[classtype.exception] = true
  }
  
  --- @type Exception
  local activeException
  --endregion
  
  --region Declarations
  --- @generic T
  --- @class Class
  --- @field __classid number
  --- @field __classtype number
  --- @field __classname string
  --- @field __parent Class|T
  --- @field __instanceid number
  --- @field __init fun(self: T): void
  --- @field __setup fun(self: T): void
  local Class = {
  	__classid = classtype.class,
  	__classtype = classtype.class,
  	__classname = "Nyx/Class"
  }
  
  --- Do not override this method.
  --- @generic T
  --- @param fields T
  --- @return T
  function Class:__constructor(fields)
  	return setmetatable(fields or {}, self)
  end
  
  --- Called when the class is first initialized.
  --- @return void
  function Class:__setup() end
  
  --- Called when the class is instantiated as an object.
  --- @return void
  function Class:__init() end
  
  --- Serializes the object for data transfer.
  --- @param serializeTableFields boolean
  --- @return table
  function Class:__serialize(serializeTableFields)
  	local serialized = {}
  
  	for field, value in pairs(self) do repeat
  		if string.sub(field, 1, 2) == "__" then
  			break
  		end
  
  		local typeof = type(value)
  
  		if typeof == "function" or typeof == "userdata" or typeof == "thread" then
  			break
  		end
  
  		if serializeTableFields and typeof == "table" then
  			value = Class.__serialize(value)
  		end
  
  		serialized[field] = value
  	until true end
  
  	return serialized
  end
  
  --- @class Abstract : Class
  local Abstract = {
  	__classid = classtype.abstract,
  	__classtype = classtype.abstract,
  	__classname = "Nyx/Abstract",
  	__parent = Class
  }
  
  --- @return void
  function Abstract:__constructor()
  	error(string.format(errorMessage.invalidInstantiationType, self.__classname, classtypeName[classtype.abstract]), 6)
  end
  
  --- @class Enum : Class
  --- @field __map table<string, string>
  local Enum = {
  	__classid = classtype.enum,
  	__classtype = classtype.enum,
  	__classname = "Nyx/Enum",
  	__parent = Class,
  	__map = {}
  }
  
  --- @return void
  function Enum:__constructor()
  	die(errorMessage.invalidInstantiationType, self.__classname, classtypeName[classtype.enum])
  end
  
  --- @param value any
  --- @return boolean
  function Enum:valid(value)
  	return self[value] ~= nil
  end
  
  --- @param lookup string
  --- @param caseInsensitive
  --- @return any
  function Enum:value(lookup, caseInsensitive)
  	if caseInsensitive ~= true then
  		return self[lookup]
  	end
  
  	return self[string.upper(string.upper(lookup))]
  end
  
  --- @param lookup string
  function Enum:name(lookup)
  	for member, value in pairs(self) do
  		if lookup == value then
  			return member
  		end
  	end
  end
  
  --- @return table
  function Enum:names()
  	local result = {}
  
  	for member, value in pairs(self) do repeat
  		if string.sub(member, 1, 2) == "__" then
  			break
  		end
  
  		if type(value) == "function" then
  			break
  		end
  
  		table.insert(result, member)
  	until true end
  
  	return result
  end
  
  --- @return table
  function Enum:values()
  	local result = {}
  
  	for member, value in pairs(self) do repeat
  		if string.sub(member, 1, 2) == "__" then
  			break
  		end
  
  		if type(value) == "function" then
  			break
  		end
  
  		result[member] = value
  	until true end
  
  	return result
  end
  
  --- @class Interface : Class
  local Interface = {
  	__classid = classtype.interface,
  	__classtype = classtype.interface,
  	__classname = "Nyx/Interface",
  	__parent = Class
  }
  
  --- @class Exception : Class
  --- @field __errorMessageFormat string
  --- @field code number
  --- @field message string
  local Exception = {
  	__classid = classtype.exception,
  	__classtype = classtype.exception,
  	__classname = "Nyx/Exception",
  	__parent = Class,
  	__errorMessageFormat = "Uncaught %s [%s]: %s"
  }
  
  --- @param code number
  --- @param message string
  function Exception:throw(code, message)
  	local e = setmetatable({
  		code = code,
  		message = message
  	}, self)
  
  	activeException = e
  
  	error(string.format(
  		self.__errorMessageFormat,
  		self.__classname,
  		code,
  		message
  	), 3)
  end
  --endregion
  
  --region Main locals
  --- @type Class[]
  local inheritance = {
  	[classtype.class] = {
  		[classtype.class] = Class
  	},
  	[classtype.abstract] = {
  		[classtype.class] = Class,
  		[classtype.abstract] = Abstract
  	},
  	[classtype.enum] = {
  		[classtype.class] = Class,
  		[classtype.enum] = Enum
  	},
  	[classtype.interface] = {
  		[classtype.class] = Class,
  		[classtype.interface] = Interface
  	},
  	[classtype.exception] = {
  		[classtype.class] = Class,
  		[classtype.interface] = Exception
  	}
  }
  
  --- @type Class[]
  local classes = {
  	[Class.__classname] = Class,
  	[Abstract.__classname] = Abstract,
  	[Enum.__classname] = Enum,
  	[Interface.__classname] = Interface,
  	[Exception.__classname] = Exception
  }
  
  local latestClassId = #inheritance + 1
  local latestInstanceId = 1
  --endregion
  
  --region Functions
  --- @param c Class
  local function validateInstantiable(c)
  	if instantiable[c.__classtype] == nil then
  		die(errorMessage.invalidInstantiationType, c.__classname, classtypeName[c.__classtype])
  	end
  end
  
  --- @param c Class
  local function validateClassExists(c)
  	if c.__classid == nil then
  		error(errorMessage.invalidClass, 4)
  	end
  end
  
  --- @param c table|Class
  local function validateValidClassFormat(c)
  	if type(c) ~= "table" then
  		die(errorMessage.invalidClassFormat)
  	end
  
  	if c.__classid ~= nil then
  		die(errorMessage.classAlreadyExists, c.__classname)
  	end
  end
  
  --- @param c Class
  local function assignInstanceId(c)
  	c.__instanceid = latestInstanceId
  
  	latestInstanceId = latestInstanceId + 1
  end
  
  ---  @param identifier string
  --- @param c Class
  local function assignClassMetadata(identifier, c)
  	c.__classname = identifier
  	c.__classid = latestClassId
  
  	latestClassId = latestClassId + 1
  
  	classes[identifier] = c
  end
  
  --- @param parent Class
  --- @param fallback Class
  --- @return Class
  local function assignParent(parent, fallback)
  	if parent ~= nil then
  		validateClassExists(parent)
  	else
  		parent = fallback
  	end
  
  	return parent
  end
  
  --- @param class Class
  --- @param parent Class
  local function assignClassInheritance(class, parent)
  	class.__parent = parent
  	class.__index = class
  
  	--- @type Class[]
  	local linearTree = {
  		[1] = class
  	}
  
  	local recurseParent = parent
  	local i = 2
  
  	while recurseParent ~= nil do
  		linearTree[i] = recurseParent
  
  		recurseParent = recurseParent.__parent
  		i = i + 1
  	end
  
  	local inheritanceTree = {}
  
  	for i = 1, #linearTree do
  		local iterateClass = linearTree[i]
  
  		for member, value in pairs(iterateClass) do repeat
  			if class[member] ~= nil then
  				break
  			end
  
  			class[member] = value
  		until true end
  
  		inheritanceTree[iterateClass.__classid] = iterateClass
  	end
  
  	inheritance[class.__classid] = inheritanceTree
  end
  
  --- @param c Class
  local function validateAbstractContract(c)
  	for member, value in pairs(c) do repeat
  		if type(value) ~= "function" then
  			break
  		end
  
  		local status, message = pcall(value)
  
  		if status == false and string.find(message, errorMessage.calledAbstractMethod) ~= nil then
  			die(errorMessage.abstractContractViolated, c.__classname, member)
  		end
  	until true end
  end
  
  --- @param c Class
  local function validateInterfaceMembers(c)
  	for member, value in pairs(c) do
  		if type(value) ~= "function" then
  			die(errorMessage.invalidInterfaceMember, c.__classname, member)
  		end
  	end
  end
  
  --- @param c Class
  --- @param parent Class
  local function validateInterfaceContract(c, parent, identifier)
  	for member, _ in pairs(parent) do
  		if c[member] == nil and string.sub(member, 1, 2) ~= "__" then
  			die(errorMessage.interfaceContractViolated, identifier, member)
  		end
  	end
  end
  --endregion
  
  --region Global functions
  --- @generic T
  --- @param identifier string
  --- @param self T|Class
  --- @param parent Class|nil
  --- @return T
  local function class(identifier, self, parent)
  	validateValidClassFormat(self)
  
  	if parent ~= nil and parent.__classtype == classtype.interface then
  		validateInterfaceContract(self, parent, identifier)
  	end
  
  	parent = assignParent(parent, Class)
  
  	assignClassMetadata(identifier, self)
  	assignClassInheritance(self, parent)
  
  	if parent.__classtype == classtype.abstract then
  		-- todo validateAbstractContract(self)
  	end
  
  	if self.__setup ~= nil then
  		self.__setup(self)
  	end
  
  	self.__classtype = classtype.class
  
  	return self
  end
  
  --- @generic T
  --- @param identifier string
  --- @param self T|Abstract
  --- @param parent Abstract|Interface|nil
  --- @return T
  local function abstract(identifier, self, parent)
  	validateValidClassFormat(self)
  
  	if parent ~= nil and parent.__classtype == classtype.interface then
  		validateInterfaceContract(self, parent, identifier)
  	end
  
  	parent = assignParent(parent, Abstract)
  
  	if parent.__classtype ~= classtype.abstract and parent.__classtype ~= classtype.interface then
  		die(errorMessage.invalidAbstractParent, identifier, parent.__classname, classtypeName[parent.__classtype])
  	end
  
  	assignClassMetadata(identifier, self)
  	assignClassInheritance(self, parent)
  
  	if self.__setup ~= nil then
  		self.__setup(self)
  	end
  
  	self.__classtype = classtype.abstract
  
  	return self
  end
  
  --- @generic T
  --- @param identifier string
  --- @param self T|Enum
  --- @param parent Interface|Enum|nil
  --- @return T
  local function enum(identifier, self, parent)
  	validateValidClassFormat(self)
  
  	if parent ~= nil and parent.__classtype == classtype.interface then
  		validateInterfaceContract(self, parent, identifier)
  	end
  
  	parent = assignParent(parent, Enum)
  
  	if parent.__classtype ~= classtype.enum and parent.__classtype ~= classtype.interface then
  		die(errorMessage.invalidEnumParent, identifier, parent.__classname, classtypeName[parent.__classtype])
  	end
  
  	assignClassMetadata(identifier, self)
  	assignClassInheritance(self, parent)
  
  	if self.__setup ~= nil then
  		self.__setup(self)
  	end
  
  	self.__classtype = classtype.enum
  
  	return self
  end
  
  --- @generic T
  --- @param identifier string
  --- @param self T|Interface
  --- @param parent Interface|nil
  --- @return T
  local function interface(identifier, self, parent)
  	validateValidClassFormat(self)
  	validateInterfaceMembers(self)
  
  	parent = assignParent(parent, Interface)
  
  	if parent.__classtype ~= classtype.interface then
  		die(errorMessage.invalidInterfaceParent, identifier, parent.__classname, classtypeName[parent.__classtype])
  	end
  
  	assignClassMetadata(identifier, self)
  	assignClassInheritance(self, parent)
  
  	if self.__setup ~= nil then
  		self.__setup(self)
  	end
  
  	self.__classtype = classtype.interface
  
  	return self
  end
  
  --- @generic T
  --- @param identifier string
  --- @param self T|Exception
  --- @param parent Class|nil
  --- @return T
  local function exception(identifier, self, parent)
  	validateValidClassFormat(self)
  
  	if parent ~= nil and parent.__classtype == classtype.interface then
  		validateInterfaceContract(self, parent, identifier)
  	end
  
  	parent = assignParent(parent, Exception)
  
  	assignClassMetadata(identifier, self)
  	assignClassInheritance(self, parent)
  
  	if parent.__classtype == classtype.abstract then
  		-- todo validateAbstractContract(self)
  	end
  
  	if self.__setup ~= nil then
  		self.__setup(self)
  	end
  
  	self.__classtype = classtype.exception
  
  	return self
  end
  
  --- @generic T
  --- @param self T|Class
  --- @param fields T|Class|table|nil
  --- @return T
  local function new(self, fields)
  	validateClassExists(self)
  
  	if fields ~= nil and type(fields) ~= "table" then
  		die(errorMessage.invalidFieldsType, self.__classname)
  	end
  
  	local o = self:__constructor(fields)
  
  	assignInstanceId(o)
  
  	if o.__init ~= nil then
  		o.__init(o)
  	end
  
  	return o
  end
  
  local function void()
  	error(errorMessage.calledAbstractMethod, 2)
  end
  
  --- @param a Class
  --- @param b Class
  --- @return boolean
  local function is(a, b)
  	return a.__instanceid ~= nil and b.__instanceid ~= nil and a.__instanceid == b.__instanceid
  end
  
  --- @param a any|Class
  --- @return boolean
  local function isClass(a)
  	return type(a) == "table" and a.__classid ~= nil
  end
  
  --- @param a Class
  --- @return boolean
  local function isInstance(a)
  	return type(a) == "table" and a.__instanceid ~= nil
  end
  
  --- @param a Class
  --- @param b Class
  --- @return boolean
  local function instanceOf(a, b)
  	if (type(a) == "table" and a.__classid == nil) or type(a) ~= "table" then
  		return false
  	end
  
  	if (type(b) == "table" and b.__classid == nil) or type(a) ~= "table" then
  		return false
  	end
  
  	return inheritance[a.__classid][b.__classid] ~= nil
  end
  
  --- @param value any|Class
  --- @return string
  local function typeOf(value)
  	local valueType = type(value)
  
  	if valueType == "table" and value.__classname ~= nil then
  		return value.__classname
  	end
  
  	return valueType
  end
  
  --- @generic T
  --- @param object T|Class
  --- @return T|Class
  local function clone(object)
  	validateInstantiable(object)
  
  	--- @type Class
  	local class = classes[object.__classname]
  	local clone = new(class, class:__serialize(true))
  
  	for member, value in pairs(object) do
  		clone[member] = value
  	end
  
  	assignInstanceId(clone)
  
  	return clone
  end
  
  --- @generic T
  --- @param object Class
  --- @param to T
  --- @return T
  local function map(object, to)
  	validateInstantiable(object)
  	validateInstantiable(to)
  
  	local clone = new(to, object:__serialize(true))
  
  	assignInstanceId(clone)
  
  	return clone
  end
  
  --- @param try fun()
  --- @param catch fun(e: Exception)
  local function try(try, catch)
  	local status, message = pcall(try)
  
  	if catch ~= nil then
  		if activeException ~= nil then
  			catch(activeException)
  		elseif status == false then
  			activeException = setmetatable({}, Exception)
  			activeException.code = 0
  			activeException.message = message
  
  			catch(activeException)
  		end
  	end
  
  	activeException = nil
  end
  
  --- @param e Exception
  --- @param code number|nil
  local function caught(e, code)
  	return instanceOf(activeException, e) and code ~= nil and true or activeException.code == code
  end
  
  --- @param exception Exception|nil
  --- @vararg string
  local function throw(exception, ...)
  	if exception == nil then
  		exception = Exception
  	end
  
  	--- @type Exception
  	local e = setmetatable({
  		code = 0,
  		message = string.format(...)
  	}, exception)
  
  	activeException = e
  
  	error(string.format(
  		e.__errorMessageFormat,
  		e.__classname,
  		e.code,
  		e.message
  	), 2)
  end
  
  --- @param a Class
  --- @return Class[]
  local function getInheritance(a)
  	return inheritance[a.__classid]
  end
  
  --- @generic T
  --- @param t T
  --- @return T
  local function copyTable(t)
  	local c = {}
  
  	for k, v in pairs(t) do
  		c[k] = v
  	end
  
  	return c
  end
  
  --- Sorted pairs iteration.
  --- @generic K, V
  --- @param t table<K, V>|V[]
  --- @param order fun(a: V, b: V): boolean
  --- @return fun(t: table<K, V>): K, V
  local function spairs(t, order)
  	-- Collect the keys.
  	local keys = {}
  
  	for k in pairs(t) do
  		keys[#keys + 1] = k
  	end
  
  	-- If order function given, sort by it by passing the table and keys a, b.
  	-- Otherwise just sort the keys.
  	if order then
  		table.sort(keys, function(a, b)
  			return order(t[a], t[b])
  		end)
  	else
  		table.sort(keys)
  	end
  
  	local i = 0
  
  	-- Return the iterator function.
  	return function()
  		i = i + 1
  
  		if keys[i] then
  			return keys[i], t[keys[i]]
  		end
  	end
  end
  
  --- @vararg string
  --- @return void
  local function sprintf(...)
  	print(string.format(...))
  end
  
  --- @param classname string
  --- @return Class
  local function getClass(classname)
  	return classes[classname]
  end
  
  --- @return void
  local function dumpClasses()
  	for _, class in spairs(classes, function(a, b)
  		return a.__classid < b.__classid
  	end) do
  		print(string.format(
  				"[%s] %s",
  				class.__classid,
  				class.__classname
  		))
  	end
  end
  --endregion
  
  return {
  	class = class,
  	abstract = abstract,
  	enum = enum,
  	interface = interface,
  	exception = exception,
  	new = new,
  	clone = clone,
  	map = map,
  	void = void,
  	is = is,
  	isClass = isClass,
  	isInstance = isInstance,
  	instanceOf = instanceOf,
  	typeOf = typeOf,
  	try = try,
  	caught = caught,
  	throw = throw,
  	getInheritance = getInheritance,
  	copyTable = copyTable,
  	spairs = spairs,
  	sprintf = sprintf,
  	getClass = getClass,
  	dumpClasses = dumpClasses
  }
end
package.preload["gamesense/Nyx/Framework"] = function() return return_values["Framework"] end
--endregion

--region IEntity
libraries["IEntity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region IEntity
  --- @class IEntity : Interface
  --- @field silentDeath boolean
  local IEntity = {}
  
  --- @return number
  function IEntity:getEid() end
  
  --- @param eid number
  --- @return void
  function IEntity:setEid(eid) end
  
  --- @return string[]
  function IEntity:getTypes() end
  
  --- @return void
  function IEntity:onSpawn() end
  
  --- @return void
  function IEntity:onDeath() end
  
  --- @param entity IEntity
  --- @return void
  function IEntity:addChild(entity) end
  
  --- @return IEntity[]
  function IEntity:getChildren() end
  
  --- @return IEntity
  function IEntity:getParent() end
  
  --- @return number
  function IEntity:getRenderType() end
  
  --- @return Vector3
  function IEntity:getOrigin() end
  
  --- @return void
  function IEntity:thinkFrame() end
  
  --- @return void
  function IEntity:thinkTick() end
  
  return Nyx.interface(
  	"Nyx/IEntity",
  	IEntity
  )
  --endregion
end
package.preload["gamesense/Nyx/IEntity"] = function() return return_values["IEntity"] end
--endregion

--region Timer
libraries["Timer"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Timer
  --- @class Timer : Class
  --- @field startedAt number
  --- @field pausedAt number
  local Timer = {}
  
  --- @return Timer
  function Timer:new()
  	return Nyx.new(self)
  end
  
  --- @param realtime number
  --- @return Timer
  function Timer:newFrom(realtime)
  	return Nyx.new(self, {
  		startedAt = realtime
  	})
  end
  
  --- @return number
  function Timer:get()
  	if self.startedAt == nil then
  		return 0
  	end
  
  	if self.pausedAt ~= nil then
  		return self.pausedAt - self.startedAt
  	end
  
  	return globals.realtime() - self.startedAt
  end
  
  --- @param time number
  --- @return boolean
  function Timer:elapsed(time)
  	return self:get() >= time
  end
  
  --- @return boolean
  function Timer:hasStarted()
  	return self.startedAt ~= nil
  end
  
  --- @return boolean
  function Timer:isPaused()
  	return self.pausedAt ~= nil
  end
  
  --- @return Timer
  function Timer:start()
  	self.startedAt = globals.realtime()
  
  	return self
  end
  
  --- @return Timer
  function Timer:startAndElapse()
  	self.startedAt = 0
  
  	return self
  end
  
  --- @return Timer
  function Timer:stop()
  	self.startedAt = nil
  	self.pausedAt = nil
  
  	return self
  end
  
  --- @return Timer
  function Timer:restart()
  	self:stop()
  	self:start()
  
  	return self
  end
  
  --- @return Timer
  function Timer:pause()
  	self.pausedAt = globals.realtime()
  
  	return self
  end
  
  --- @return Timer
  function Timer:unpause()
  	self.startedAt = (self.startedAt and self.startedAt or 0) + (globals.realtime() - self.pausedAt)
  	self.pausedAt = nil
  
  	return self
  end
  
  return Nyx.class(
  	"Nyx/Timer",
  	Timer
  )
  --endregion
end
package.preload["gamesense/Nyx/Timer"] = function() return return_values["Timer"] end
--endregion

--region RenderMode
libraries["RenderMode"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region RenderMode
  --- @class RenderMode : Enum
  local RenderMode = {
  	NONE = 1,
  	WORLD = 2,
  	UI = 3
  }
  
  return Nyx.enum(
  	"Nyx/RenderMode",
  	RenderMode
  )
  --endregion
end
package.preload["gamesense/Nyx/RenderMode"] = function() return return_values["RenderMode"] end
--endregion

--region VectorsAngles
libraries["VectorsAngles"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region ffi
  local ffi = require "ffi"
  local lineGoesThroughSmoke
  
  do
  	local match = client.find_signature("client_panorama.dll", "\x55\x8B\xEC\x83\xEC\x08\x8B\x15\xCC\xCC\xCC\xCC\x0F\x57")
  
  	if match ~= nil then
  		lineGoesThroughSmoke = ffi.cast(ffi.typeof("bool(__thiscall*)(float, float, float, float, float, float, short)"), match)
  	end
  end
  --endregion
  
  --region Angle
  --- @class Angle : Class
  --- @field p number
  --- @field y number
  local Angle = {}
  
  --- @return Angle
  function Angle:new(p, y)
  	return Nyx.new(self, {
  		p = p or 0,
  		y = y or 0
  	})
  end
  
  --- @param self Angle
  --- @return Angle
  function Angle.__tostring(self)
  	return string.format("%s, %s", self.p, self.y)
  end
  
  --- @param self Angle
  --- @return Angle
  function Angle.__concat(self)
  	return string.format("%s, %s", self.p, self.y)
  end
  
  --- @param a1 Angle|number
  --- @param a2 Angle|number
  --- @return Angle
  function Angle.__add(a1, a2)
  	local x1, y1
  
  	if type(a1) ~= "number" then
  		x1, y1 = a1.p, a1.y
  	else
  		x1, y1 = a1, a1
  	end
  
  	local x2, y2
  
  	if type(a2) ~= "number" then
  		x2, y2 = a2.p, a2.y
  	else
  		x2, y2 = a2, a2
  	end
  
  	return Angle:new(
  		x1 + x2,
  		y1 + y2
  	)
  end
  
  --- @param a1 Angle|number
  --- @param a2 Angle|number
  --- @return Angle
  function Angle.__sub(a1, a2)
  	local x1, y1
  
  	if type(a1) ~= "number" then
  		x1, y1 = a1.p, a1.y
  	else
  		x1, y1 = a1, a1
  	end
  
  	local x2, y2
  
  	if type(a2) ~= "number" then
  		x2, y2 = a2.p, a2.y
  	else
  		x2, y2 = a2, a2
  	end
  
  	return Angle:new(
  		x1 - x2,
  		y1 - y2
  	)
  end
  
  --- @param a1 Angle|number
  --- @param a2 Angle|number
  --- @return Angle
  function Angle.__mul(a1, a2)
  	local x1, y1
  
  	if type(a1) ~= "number" then
  		x1, y1 = a1.p, a1.y
  	else
  		x1, y1 = a1, a1
  	end
  
  	local x2, y2
  
  	if type(a2) ~= "number" then
  		x2, y2 = a2.p, a2.y
  	else
  		x2, y2 = a2, a2
  	end
  
  	return Angle:new(
  		x1 * x2,
  		y1 * y2
  	)
  end
  
  --- @param a1 Angle|number
  --- @param a2 Angle|number
  --- @return Angle
  function Angle.__div(a1, a2)
  	local x1, y1
  
  	if type(a1) ~= "number" then
  		x1, y1 = a1.p, a1.y
  	else
  		x1, y1 = a1, a1
  	end
  
  	local x2, y2
  
  	if type(a2) ~= "number" then
  		x2, y2 = a2.p, a2.y
  	else
  		x2, y2 = a2, a2
  	end
  
  	return Angle:new(
  		x1 / x2,
  		y1 / y2
  	)
  end
  
  --- @param self Angle
  --- @return Angle
  function Angle.__unm(self)
  	return Angle:new(
  		-self.p,
  		-self.y
  	)
  end
  
  --- @param p number
  --- @param y number
  --- @return Angle
  function Angle:set(p, y)
  	self.p = (p or self.p)
  	self.y = (y or self.y)
  
  	return self
  end
  
  --- @param p number
  --- @param y number
  --- @return Angle
  function Angle:offset(p, y)
  	self.p = self.p + (p or 0)
  	self.y = self.y + (y or 0)
  
  	return self
  end
  
  --- @param a2 Angle
  --- @return Angle
  function Angle:setFromAngle(a2)
  	self.p = a2.p
  	self.y = a2.y
  
  	return self
  end
  
  --- @return Angle
  function Angle:clone()
  	return Angle:new(
  		self.p,
  		self.y
  	)
  end
  
  --- @return number, number
  function Angle:unpack()
  	return self.p, self.y
  end
  
  --- @return Angle
  function Angle:normalize()
  	local pitch = self.p
  
  	if pitch < -89 then
  		pitch = -89
  	elseif pitch > 89 then
  		pitch = 89
  	end
  
  	local yaw = self.y
  
  	while yaw > 180 do
  		yaw = yaw - 360
  	end
  
  	while yaw < -180 do
  		yaw = yaw + 360
  	end
  
  	self.p = pitch
  	self.y = yaw
  
  	return self
  end
  
  --- @param a2 Angle
  --- @return Angle
  function Angle:getDiff(a2)
  	return (a2 - self):normalize()
  end
  
  --- @param a2 Angle
  --- @return Angle
  function Angle:getAbsDiff(a2)
  	local diff = self:getDiff(a2)
  
  	diff.p = math.abs(diff.p)
  	diff.y = math.abs(diff.y)
  
  	return diff
  end
  
  --- @param a2 Angle
  --- @param speed number
  --- @return Angle
  function Angle:lerp(a2, speed)
  	local delta = self:getDiff(a2)
  
  	if delta.p > speed then
  		delta.p = delta.p + speed
  	elseif delta.p < -speed then
  		delta.p = delta.p - speed
  	else
  		delta.p = a2.p
  	end
  
  	if delta.y > speed then
  		delta.y = delta.y + speed
  	elseif delta.y < -speed then
  		delta.y = delta.y - speed
  	else
  		delta.y = a2.y
  	end
  
  	self.p = delta.p
  	self.y = delta.y
  
  	return self
  end
  
  --- @return number
  function Angle:getStartDegrees()
  	local degrees = self.y
  
  	degrees = degrees > 180 and degrees - 360 or degrees
  
  	return degrees + 180
  end
  
  --- @return number
  function Angle:getBearing()
  	local yaw = 180 - self.y + 90
  	local degrees = (yaw % 360 + 360) % 360
  
  	degrees = degrees > 180 and degrees - 360 or degrees
  
  	return math.floor(degrees + 180 + 0.5)
  end
  
  --- @return string
  function Angle:getCardinalDirection()
  	local bearing = self:getBearing()
  
  	if ((bearing >= 315 and bearing <= 360) or (bearing >= 0 and bearing <= 45)) then
  		return "North"
  	elseif (bearing >= 45 and bearing <= 135) then
  		return "East"
  	elseif (bearing >= 135 and bearing <= 225) then
  		return "South"
  	else
  		return "West"
  	end
  end
  
  --- @return boolean
  function Angle:isAtCardinalDirection()
  	local bearing = self:getBearing()
  
  	return bearing == 0 or bearing == 90 or bearing == 180 or bearing == 270 or bearing == 360
  end
  
  --- @param bearing number
  --- @return boolean
  function Angle.isBearingAtCardinalDirection(bearing)
  	return bearing == 0 or bearing == 90 or bearing == 180 or bearing == 270 or bearing == 360
  end
  
  --- @param bearing number
  --- @return string
  function Angle.getBearingCardinalDirection(bearing)
  	if ((bearing >= 315 and bearing <= 360) or (bearing >= 0 and bearing <= 45)) then
  		return "North"
  	elseif (bearing >= 45 and bearing <= 135) then
  		return "East"
  	elseif (bearing >= 135 and bearing <= 225) then
  		return "South"
  	else
  		return "West"
  	end
  end
  --endregion
  
  --region Vector2
  --- @class Vector2 : Class
  --- @field x number
  --- @field y number
  local Vector2 = {}
  
  --- @param x number
  --- @param y number
  --- @return Vector2
  function Vector2:new(x, y)
  	return Nyx.new(self, {
  		x = x or 0,
  		y = y or 0
  	})
  end
  
  --- @param t Vector2|table
  --- @return Vector2
  function Vector2:newFromTable(t)
  	return Nyx.new(self, t)
  end
  
  --- @param self Vector2
  --- @return Vector2
  function Vector2.__tostring(self)
  	return string.format("%s, %s", self.x, self.y)
  end
  
  --- @param self Vector2
  --- @return Vector2
  function Vector2.__concat(self)
  	return string.format("%s, %s", self.x, self.y)
  end
  
  --- @param self Vector2
  --- @return Vector2
  function Vector2.__unm(self)
  	return Vector2:new(
  		-self.x,
  		-self.y
  	)
  end
  
  --- @return Vector2
  function Vector2:unm()
  	self.x = -self.x
  	self.y = -self.y
  end
  
  --- @param v1 Vector2|number
  --- @param v2 Vector2|number
  --- @return Vector2
  function Vector2.__add(v1, v2)
  	local x1, y1
  
  	if type(v1) ~= "number" then
  		x1, y1 = v1.x, v1.y
  	else
  		x1, y1 = v1, v1
  	end
  
  	local x2, y2
  
  	if type(v2) ~= "number" then
  		x2, y2 = v2.x, v2.y
  	else
  		x2, y2 = v2, v2
  	end
  
  	return Vector2:new(
  		x1 + x2,
  		y1 + y2
  	)
  end
  
  --- @param v1 Vector2|number
  --- @param v2 Vector2|number
  --- @return Vector2
  function Vector2.__sub(v1, v2)
  	local x1, y1
  
  	if type(v1) ~= "number" then
  		x1, y1 = v1.x, v1.y
  	else
  		x1, y1 = v1, v1
  	end
  
  	local x2, y2
  
  	if type(v2) ~= "number" then
  		x2, y2 = v2.x, v2.y
  	else
  		x2, y2 = v2, v2
  	end
  
  	return Vector2:new(
  		x1 - x2,
  		y1 - y2
  	)
  end
  
  --- @param v1 Vector2|number
  --- @param v2 Vector2|number
  --- @return Vector2
  function Vector2.__mul(v1, v2)
  	local x1, y1
  
  	if type(v1) ~= "number" then
  		x1, y1 = v1.x, v1.y
  	else
  		x1, y1 = v1, v1
  	end
  
  	local x2, y2
  
  	if type(v2) ~= "number" then
  		x2, y2 = v2.x, v2.y
  	else
  		x2, y2 = v2, v2
  	end
  
  	return Vector2:new(
  		x1 * x2,
  		y1 * y2
  	)
  end
  
  --- @param v1 Vector2|number
  --- @param v2 Vector2|number
  --- @return Vector2
  function Vector2.__div(v1, v2)
  	local x1, y1
  
  	if type(v1) ~= "number" then
  		x1, y1 = v1.x, v1.y
  	else
  		x1, y1 = v1, v1
  	end
  
  	local x2, y2
  
  	if type(v2) ~= "number" then
  		x2, y2 = v2.x, v2.y
  	else
  		x2, y2 = v2, v2
  	end
  
  	return Vector2:new(
  		x1 / x2,
  		y1 / y2
  	)
  end
  
  --- @return Vector2
  function Vector2:nullify()
  	self.x = 0
  	self.y = 0
  
  	return self
  end
  
  --- @param x number
  --- @param y number
  --- @return Vector2
  function Vector2:set(x, y)
  	self.x = (x or self.x)
  	self.y = (y or self.y)
  
  	return self
  end
  
  --- @param v2 Vector2
  --- @return Vector2
  function Vector2:setFromVector(v2)
  	self.x = v2.x
  	self.y = v2.y
  
  	return self
  end
  
  --- @param x number
  --- @param y number
  --- @return Vector2
  function Vector2:offset(x, y)
  	self.x = self.x + (x or 0)
  	self.y = self.y + (y or 0)
  
  	return self
  end
  
  --- @param v2 Vector2
  --- @return Vector2
  function Vector2:offsetByVector(v2)
  	self.x = self.x + v2.x
  	self.y = self.y + v2.y
  
  	return self
  end
  
  --- @return Vector2
  function Vector2:abs()
  	self.x = math.abs(self.x)
  	self.y = math.abs(self.y)
  
  	return self
  end
  
  --- @return Vector2
  function Vector2:clone()
  	return Vector2:new(self.x, self.y)
  end
  
  --- @return number, number
  function Vector2:unpack()
  	return self.x, self.y
  end
  
  --- @return number
  function Vector2:getLengthSq()
  	return (self.x * self.x) + (self.y * self.y)
  end
  
  --- @return number
  function Vector2:getLength()
  	return math.sqrt(self:getLengthSq())
  end
  
  --- @return Vector2
  function Vector2:normalize()
  	local length = self:getLength()
  
  	if length ~= 0 then
  		self.x = self.x / length
  		self.y = self.y / length
  	else
  		self.x = 0
  		self.y = 0
  	end
  
  	return self
  end
  
  --- @param rotationAngle Angle
  --- @param extension number
  --- @return Vector2
  function Vector2:rotate(rotationAngle, extension)
  	self = self + rotationAngle:getForward() * extension
  
  	return self
  end
  
  --- @param v2 Vector2
  --- @return Vector2
  function Vector2:getDiff(v2)
  	return (v2 - self):normalize()
  end
  
  --- @param v2 Vector2
  --- @return number
  function Vector2:getDotProduct(v2)
  	return (self.x * v2.x) + (self.y * v2.y)
  end
  
  --- @param v2 Vector2
  --- @return number
  function Vector2:getDistance(v2)
  	return (v2 - self):getLength()
  end
  
  --- @param v2 Vector2
  --- @return Vector2
  function Vector2:getDimensions(v2)
  	return (self - v2):abs()
  end
  
  --- @return number
  function Vector2:getMagnitude()
  	return math.sqrt(
  		math.pow(self.x, 2) +
  			math.pow(self.y, 2)
  	)
  end
  
  --- @param v2 Vector2
  --- @param pct number
  --- @return Vector2
  function Vector2:getLerp(v2, pct)
  	return self + (v2 - self) * pct
  end
  
  --- @param v2 Vector2
  --- @param pct number
  --- @return Vector2
  function Vector2:lerp(v2, pct)
  	local lerp = self:getLerp(v2, pct)
  
  	self.x = lerp.x
  	self.y = lerp.y
  
  	return self
  end
  
  --- @param v2 Vector2
  --- @return Angle
  function Vector2:getAngle(v2)
  	local delta = Vector2:new(v2.x - self.x, v2.y - self.y)
  
  	return Angle:new(0, math.deg(math.atan2(delta.y, delta.x)))
  end
  
  --- @param pos1 Vector2
  --- @param pos2 Vector2
  --- @param pos3 Vector2
  --- @param color Color
  --- @return Vector2
  function Vector2:drawTriangle(pos1, pos2, pos3, color)
  	renderer.triangle(pos1.x, pos1.y, pos2.x, pos2.y, pos3.x, pos3.y, color.r, color.g, color.b, color.a)
  
  	return self
  end
  
  --- @param dimensions Vector2
  --- @param color Color
  --- @param center boolean
  --- @return Vector2
  function Vector2:drawRectangle(dimensions, color, center)
  	local x, y = self.x, self.y
  
  	if center then
  		x = x - dimensions.x / 2
  		y = y - dimensions.y / 2
  	end
  
  	renderer.rectangle(x, y, dimensions.x, dimensions.y, color.r, color.g, color.b, color.a)
  
  	return self
  end
  
  --- @param textureId number
  --- @param dimensions Vector2
  --- @param color Color
  --- @param center boolean
  --- @param flags string
  --- @return Vector2
  function Vector2:drawTexture(textureId, dimensions, color, center, flags)
  	flags = flags or "f"
  
  	local x, y = self.x, self.y
  
  	if center then
  		x = x - dimensions.x / 2
  		y = y - dimensions.y / 2
  	end
  
  	renderer.texture(
  		textureId, x, y,
  		dimensions.x, dimensions.y,
  		color.r, color.g, color.b, color.a,
  		flags
  	)
  
  	return self
  end
  
  --- @param dimensions Vector2
  --- @param color1 Color
  --- @param color2 Color
  --- @param horizontal boolean
  --- @param center boolean
  --- @return Vector3
  function Vector2:drawGradient(dimensions, color1, color2, horizontal, center)
  	local x, y = self.x, self.y
  
  	if center then
  		x = x - dimensions.x / 2
  		y = y - dimensions.y / 2
  	end
  
  	renderer.gradient(
  		x, y,
  		dimensions.x, dimensions.y,
  		color1.r, color1.g, color1.b, color1.a,
  		color2.r, color2.g, color2.b, color2.a,
  		horizontal
  	)
  
  	return self
  end
  
  --- @param rayEnd Vector2
  --- @param color Color
  --- @return Vector2
  function Vector2:drawLine(rayEnd, color)
  	renderer.load_png(
  		self.x, self.y,
  		rayEnd.x, rayEnd.y,
  		color.r, color.g, color.b, color.a
  	)
  
  	return self
  end
  
  --- @param color Color
  --- @param flags string
  --- @param maxWidth number
  --- @param text string
  --- @return Vector2
  function Vector2:drawText(color, flags, maxWidth, text)
  	renderer.text(
  		self.x, self.y,
  		color.r, color.g, color.b, color.a,
  		flags, maxWidth, text
  	)
  
  	return self
  end
  
  --- @param radius number
  --- @param color Color
  --- @param startDegrees number
  --- @param percentage number
  --- @return Vector2
  function Vector2:drawCircle(radius, color, startDegrees, percentage)
  	renderer.circle(
  		self.x, self.y,
  		color.r, color.g, color.b, color.a,
  		radius,
  		startDegrees or 0,
  		percentage or 1
  	)
  
  	return self
  end
  
  --- @param radius number
  --- @param thickness number
  --- @param color Color
  --- @param startDegrees number
  --- @param percentage number
  --- @return Vector2
  function Vector2:drawCircleOutline(radius, thickness, color, startDegrees, percentage)
  	renderer.circle_outline(
  		self.x, self.y,
  		color.r, color.g, color.b, color.a,
  		radius,
  		startDegrees or 0,
  		percentage or 1,
  		thickness
  	)
  
  	return self
  end
  
  Nyx.class(
  	"Nyx/Vector2",
  	Vector2
  )
  --endregion
  
  --region Vector3
  --- @class Vector3 : Vector2
  --- @field z number
  local Vector3 = {}
  
  --- @param x number
  --- @param y number
  --- @param z number
  --- @return Vector3
  function Vector3:new(x, y, z)
  	return Nyx.new(self, {
  		x = x or 0,
  		y = y or 0,
  		z = z or 0
  	})
  end
  
  --- @param t Vector3|table
  --- @return Vector3
  function Vector3:newFromTable(t)
  	return Nyx.new(self, t)
  end
  
  --- @param self Vector3
  --- @return Vector3
  function Vector3.__tostring(self)
  	return string.format("%s, %s, %s", self.x, self.y, self.z)
  end
  
  --- @param self Vector3
  --- @return Vector3
  function Vector3.__concat(self)
  	return string.format("%s, %s, %s", self.x, self.y, self.z)
  end
  
  --- @param self Vector3
  --- @return Vector3
  function Vector3.__unm(self)
  	return Vector3:new(
  		-self.x,
  		-self.y,
  		-self.z
  	)
  end
  
  --- @param v1 Vector3|number
  --- @param v2 Vector3|number
  --- @return Vector3
  function Vector3.__add(v1, v2)
  	local x1, y1, z1
  
  	if type(v1) ~= "number" then
  		x1, y1, z1 = v1.x, v1.y, v1.z
  	else
  		x1, y1, z1 = v1, v1, v1
  	end
  
  	local x2, y2, z2
  
  	if type(v2) ~= "number" then
  		x2, y2, z2 = v2.x, v2.y, v2.z
  	else
  		x2, y2, z2 = v2, v2, v2
  	end
  
  	return Vector3:new(
  		x1 + x2,
  		y1 + y2,
  		z1 + z2
  	)
  end
  
  --- @param v1 Vector3|number
  --- @param v2 Vector3|number
  --- @return Vector3
  function Vector3.__sub(v1, v2)
  	local x1, y1, z1
  
  	if type(v1) ~= "number" then
  		x1, y1, z1 = v1.x, v1.y, v1.z
  	else
  		x1, y1, z1 = v1, v1, v1
  	end
  
  	local x2, y2, z2
  
  	if type(v2) ~= "number" then
  		x2, y2, z2 = v2.x, v2.y, v2.z
  	else
  		x2, y2, z2 = v2, v2, v2
  	end
  
  	return Vector3:new(
  		x1 - x2,
  		y1 - y2,
  		z1 - z2
  	)
  end
  
  --- @param v1 Vector3|number
  --- @param v2 Vector3|number
  --- @return Vector3
  function Vector3.__mul(v1, v2)
  	local x1, y1, z1
  
  	if type(v1) ~= "number" then
  		x1, y1, z1 = v1.x, v1.y, v1.z
  	else
  		x1, y1, z1 = v1, v1, v1
  	end
  
  	local x2, y2, z2
  
  	if type(v2) ~= "number" then
  		x2, y2, z2 = v2.x, v2.y, v2.z
  	else
  		x2, y2, z2 = v2, v2, v2
  	end
  
  	return Vector3:new(
  		x1 * x2,
  		y1 * y2,
  		z1 * z2
  	)
  end
  
  --- @param v1 Vector3|number
  --- @param v2 Vector3|number
  --- @return Vector3
  function Vector3.__div(v1, v2)
  	local x1, y1, z1
  
  	if type(v1) ~= "number" then
  		x1, y1, z1 = v1.x, v1.y, v1.z
  	else
  		x1, y1, z1 = v1, v1, v1
  	end
  
  	local x2, y2, z2
  
  	if type(v2) ~= "number" then
  		x2, y2, z2 = v2.x, v2.y, v2.z
  	else
  		x2, y2, z2 = v2, v2, v2
  	end
  
  	return Vector3:new(
  		x1 / x2,
  		y1 / y2,
  		z1 / z2
  	)
  end
  
  --- @param x number
  --- @param y number
  --- @param z number
  --- @return Vector3
  function Vector3:set(x, y, z)
  	self.x = (x or self.x)
  	self.y = (y or self.y)
  	self.z = (z or self.z)
  
  	return self
  end
  
  --- @param v2 Vector3
  --- @return Vector3
  function Vector3:setFromVector(v2)
  	self.x = v2.x
  	self.y = v2.y
  	self.z = v2.z
  
  	return self
  end
  
  --- @param x number
  --- @param y number
  --- @param z number
  --- @return Vector3
  function Vector3:offset(x, y, z)
  	self.x = self.x + (x or 0)
  	self.y = self.y + (y or 0)
  	self.z = self.z + (z or 0)
  
  	return self
  end
  
  --- @param v2 Vector3
  --- @return Vector3
  function Vector3:offsetByVector(v2)
  	self.x = self.x + v2.x
  	self.y = self.y + v2.y
  	self.z = self.z + v2.z
  
  	return self
  end
  
  --- @return Vector3
  function Vector3:abs()
  	self.x = math.abs(self.x)
  	self.y = math.abs(self.y)
  	self.z = math.abs(self.z)
  
  	return self
  end
  
  --- @return Vector3
  function Vector3:clone()
  	return Vector3:new(self.x, self.y, self.z)
  end
  
  --- @return number, number
  function Vector3:unpack()
  	return self.x, self.y, self.z
  end
  
  --- @param precision number
  --- @return Vector3
  function Vector3:round(precision)
  	local mult = 10 ^ (precision or 0)
  
  	self.x = math.floor(self.x * mult + 0.5) / mult
  	self.y = math.floor(self.y * mult + 0.5) / mult
  	self.z = math.floor(self.z * mult + 0.5) / mult
  
  	return self
  end
  
  --- @return number
  function Vector3:getLengthSq()
  	return (self.x * self.x) + (self.y * self.y) + (self.z * self.z)
  end
  
  --- @return number
  function Vector3:getLength()
  	return math.sqrt(self:getLengthSq())
  end
  
  --- @return Vector3
  function Vector3:normalize()
  	local length = self:getLength()
  
  	if length ~= 0 then
  		self.x = self.x / length
  		self.y = self.y / length
  		self.z = self.z / length
  	else
  		self.x = 0
  		self.y = 0
  		self.z = 1
  	end
  
  	return self
  end
  
  --- @param rotationAngle Angle
  --- @param extension number
  --- @return Vector3
  function Vector3:rotate(rotationAngle, extension)
  	self = self + rotationAngle:getForward() * (extension or 1)
  
  	return self
  end
  
  --- @param v2 Vector3
  --- @return Vector3
  function Vector3:getDiff(v2)
  	return (v2 - self):normalize()
  end
  
  --- @param v2 Vector3
  --- @return number
  function Vector3:getDotProduct(v2)
  	return (self.x * v2.x) + (self.y * v2.y) + (self.z * v2.z)
  end
  
  --- @param v2 Vector3
  --- @return Vector3
  function Vector3:getCrossProduct(v2)
  	return Vector3:new(
  		(self.y * v2.z) - (self.z * v2.y),
  		(self.z * v2.x) - (self.x * v2.z),
  		(self.x * v2.y) - (self.y * v2.x)
  	)
  end
  
  --- @param v2 Vector3
  --- @return number
  function Vector3:getDistance(v2)
  	return (v2 - self):getLength()
  end
  
  --- @return Vector2|nil
  function Vector3:getVector2()
  	local x, y  = renderer.world_to_screen(self.x, self.y, self.z)
  
  	if x == nil then
  		return nil
  	end
  
  	return Vector2:new(x, y)
  end
  
  --- @param v2 Vector3
  --- @return Vector3
  function Vector3:getDimensions(v2)
  	return (self - v2):abs()
  end
  
  --- @return number
  function Vector3:getMagnitude()
  	return math.sqrt(
  		math.pow(self.x, 2) +
  			math.pow(self.y, 2) +
  			math.pow(self.z, 2)
  	)
  end
  
  --- @param v2 Vector3
  --- @param pct number
  --- @return Vector3
  function Vector3:getLerp(v2, pct)
  	return self + (v2 - self) * pct
  end
  
  --- @param v2 Vector3
  --- @param pct number
  --- @return Vector3
  function Vector3:lerp(v2, pct)
  	local lerp = self:getLerp(v2, pct)
  
  	self.x = lerp.x
  	self.y = lerp.y
  	self.z = lerp.z
  
  	return self
  end
  
  --- @param v2 Vector3
  --- @return Angle
  function Vector3:getAngle(v2)
  	local delta = Vector3:new(v2.x - self.x, v2.y - self.y, v2.z - self.z)
  
  	return Angle:new(
  		math.deg(math.atan2(-delta.z, math.sqrt(delta.x * delta.x + delta.y * delta.y))),
  		math.deg(math.atan2(delta.y, delta.x))
  	)
  end
  
  --- @param v2 Vector3
  --- @param skipEid number
  --- @return Vector3, number, number
  function Vector3:getTraceLine(v2, skipEid)
  	local fraction, eid = client.trace_line(
  		skipEid or -1,
  		self.x, self.y, self.z,
  		v2.x, v2.y, v2.z
  	)
  
  	return self:getLerp(v2, fraction), fraction, eid
  end
  
  --- @param angle Angle
  --- @param skipEid number
  --- @return Vector3, number, number
  function Vector3:getTraceAngle(angle, skipEid)
  	return self:getTraceLine(
  		self + angle:getForward() * 60000,
  		skipEid
  	)
  end
  
  --- @param v2 Vector3
  --- @param eid number
  --- @return number|nil, number
  function Vector3:getTraceBullet(v2, eid)
  	return client.trace_bullet(
  		eid,
  		self.x, self.y, self.z,
  		v2.x, v2.y, v2.z
  	)
  end
  
  --- @param rayStart Vector3
  --- @param rayEnd Vector3
  --- @return Vector3
  function Vector3:getClosestRayPoint(rayStart, rayEnd)
  	local direction = rayEnd - rayStart
  	local length = direction:getLength()
  
  	direction:normalize()
  
  	local rayAlong = (self - rayStart):getDotProduct(direction)
  
  	if rayAlong < 0 then
  		return rayStart
  	elseif rayAlong > length then
  		return rayEnd
  	end
  
  	return rayStart + direction * rayAlong
  end
  
  --- @param rayEnd Vector3
  --- @param m number
  --- @param n number
  function Vector3:getInternalRayDivision(rayEnd, m, n)
  	return Vector3:new((self.x * n + rayEnd.x * m) / (m + n),
  		(self.y * n + rayEnd.y * m) / (m + n),
  		(self.z * n + rayEnd.z * m) / (m + n))
  end
  
  --- @param rayEnd Vector3
  --- @param segments number
  --- @return Vector3[]
  function Vector3:getRaySegmented(rayEnd, segments)
  	local segmentedRay = {}
  
  	for i = 1, segments do
  		segmentedRay[i] = self:getInternalRayDivision(rayEnd, i, segments - i)
  	end
  
  	return segmentedRay
  end
  
  --- @param rayEnd Vector3
  --- @param ratio number
  --- @return Vector3
  function Vector3:getRayDivided(rayEnd, ratio)
  	return (self * ratio + rayEnd) / (1 + ratio)
  end
  
  --- @param rayEnd Vector3
  --- @param accuracy number
  --- @return Vector3|nil, Vector3|nil
  function Vector3:getScreenRay(rayEnd, accuracy)
  	accuracy = accuracy or 128
  
  	--- @type Vector3[]
  	local segments = {}
  	local step = self:getDistance(rayEnd) / accuracy
  	local direction = self:getAngle(rayEnd):getForward()
  
  	for i = 1, accuracy do
  		segments[i] = self + (direction * (step * i))
  	end
  
  	local srcScreenPosition
  	local dstScreenPosition
  	local srcInScreen = false
  	local dstInScreen = false
  
  	for i = 1, #segments do
  		srcScreenPosition = segments[i]:getVector2()
  
  		if srcScreenPosition ~= nil then
  			srcInScreen = true
  
  			break
  		end
  	end
  
  	for i = #segments, 1, -1 do
  		dstScreenPosition = segments[i]:getVector2()
  
  		if dstScreenPosition ~= nil then
  			dstInScreen = true
  
  			break
  		end
  	end
  
  	print(dstInScreen)
  
  	if srcInScreen and dstInScreen then
  		return srcScreenPosition, dstScreenPosition
  	end
  end
  
  --- @param rayEnd Vector3
  --- @return boolean
  function Vector3:getLineGoesThroughSmoke(rayEnd)
  	if lineGoesThroughSmoke == nil then
  		error("Unsafe scripts must be allowed in order to use Vector3:getLineGoesThroughSmoke.")
  	end
  
  	return lineGoesThroughSmoke(
  		self.x, self.y, self.z,
  		rayEnd.x, rayEnd.y, rayEnd.z,
  		1
  	)
  end
  
  --- Returns true if v2 is closer to v1 than v3; within tolerance if specified.
  --- @param v2 Vector3
  --- @param v3 Vector3
  --- @param tolerance number
  function Vector3:isClosest(v2, v3, tolerance)
  	return self:getDistance(v2) < self:getDistance(v3) - tolerance
  end
  
  --- Returns true if v2 is in front of v1 compared to v3; within tolerance if specified.
  --- @param v2 Vector3
  --- @param v3 Vector3
  function Vector3:isInFront(v2, v3)
  
  	-- todo
  	local v2Distance = self:getDistance(v2)
  	local v3Distance = self:getDistance(v3)
  	local v2v3Distance = v2:getDistance(v3)
  
  	return v2Distance < v3Distance and v2Distance < v2v3Distance
  end
  
  --- @param dimensions Vector2
  --- @param color Color
  --- @param center boolean
  --- @return Vector3
  function Vector3:drawRectangle(dimensions, color, center)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawRectangle(dimensions, color, center)
  	end
  
  	return self
  end
  
  --- @param textureId number
  --- @param dimensions Vector2
  --- @param color Color
  --- @param center boolean
  --- @field flags string
  --- @return Vector3
  function Vector3:drawTexture(textureId, dimensions, color, center, flags)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawTexture(textureId, dimensions, color, center, flags)
  	end
  
  	return self
  end
  
  --- @param rayEnd Vector2
  --- @param color Color
  --- @param accuracy number
  --- @return Vector3
  function Vector3:drawLine(rayEnd, color, accuracy)
  	local rayStart2, rayEnd2 = self:getScreenRay(rayEnd, accuracy)
  
  	if rayStart2 ~= nil then
  		rayStart2:drawLine(rayEnd2, color)
  	end
  
  	return self
  end
  
  --- @param dimensions Vector2
  --- @param color1 Color
  --- @param color2 Color
  --- @param horizontal boolean
  --- @param center boolean
  --- @return Vector3
  function Vector3:drawGradient(dimensions, color1, color2, horizontal, center)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawGradient(dimensions, color1, color2, horizontal, center)
  	end
  
  	return self
  end
  
  
  --- @param color Color
  --- @param flags string
  --- @param maxWidth number
  --- @param text string
  --- @return Vector3
  function Vector3:drawText(color, flags, maxWidth, text)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawText(color, flags, maxWidth, text)
  	end
  end
  
  --- @param radius number
  --- @param color Color
  --- @param startDegrees number
  --- @param percentage number
  --- @return Vector3
  function Vector3:drawCircle(radius, color, startDegrees, percentage)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawCircle(radius, color, startDegrees, percentage)
  	end
  
  	return self
  end
  
  --- @param radius number
  --- @param thickness number
  --- @param color Color
  --- @param startDegrees number
  --- @param percentage number
  --- @return Vector3
  function Vector3:drawCircleOutline(radius, thickness, color, startDegrees, percentage)
  	local self2 = self:getVector2()
  
  	if self2 ~= nil then
  		self2:drawCircleOutline(radius, thickness, color, startDegrees, percentage)
  	end
  
  	return self
  end
  
  Nyx.class(
  	"Nyx/Vector3",
  	Vector3,
  	Vector2
  )
  --endregion
  
  --region AngleToVector
  --- @return Vector3
  function Angle:getForward()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(cp * cy, cp * sy, -sp)
  end
  
  --- @return Vector3
  function Angle:getBackward()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(cp * cy, cp * sy, -sp):__unm()
  end
  
  --- @return Vector3
  function Angle:getLeft()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(sp * cy * -1 + sy, sp * sy * -1 + -1 * cy, -1 * cp):__unm()
  end
  
  --- @return Vector3
  function Angle:getRight()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(sp * cy * -1 + sy, sp * sy * -1 + -1 * cy, -1 * cp)
  end
  
  --- @return Vector3
  function Angle:getUp()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(sp * cy + sy, sp * sy + cy * -1, cp)
  end
  
  --- @return Vector3
  function Angle:getDown()
  	local sp = math.sin(math.rad(self.p))
  	local cp = math.cos(math.rad(self.p))
  	local sy = math.sin(math.rad(self.y))
  	local cy = math.cos(math.rad(self.y))
  
  	return Vector3:new(sp * cy + sy, sp * sy + cy * -1, cp):__unm()
  end
  
  --- @param v1 Vector3
  --- @param v2 Vector3
  --- @return number
  function Angle:getFov(v1, v2)
  	local delta = v1:getDiff(v2)
  
  	return math.max(0.0, math.deg(math.acos(self:getForward():getDotProduct(delta) / delta:getLength())))
  end
  
  Nyx.class(
  	"Nyx/Angle",
  	Angle
  )
  --endregion
  
  return {
  	Angle = Angle,
  	Vector2 = Vector2,
  	Vector3 = Vector3
  }
end
package.preload["gamesense/Nyx/VectorsAngles"] = function() return return_values["VectorsAngles"] end
--endregion

--region Color
libraries["Color"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Color
  --- @class Color : Class
  --- @field r number
  --- @field g number
  --- @field b number
  --- @field h number
  --- @field s number
  --- @field l number
  --- @field a number
  local Color = {
  	IS_WHITE = 0,
  	IS_BLACK = 1
  }
  
  --- @return Color
  function Color:new()
  	return Nyx.new(self, {
  		r = 255,
  		g = 255,
  		b = 255,
  		h = 0,
  		s = 1,
  		l = 1,
  		a = 255
  	})
  end
  
  --- @param r number
  --- @param g number
  --- @param b number
  --- @param a number
  --- @return Color
  function Color:rgba(r, g, b, a)
  	return Nyx.new(self, {
  		r = r or 255,
  		g = g or 255,
  		b = b or 255,
  		a = a or 255
  	}):updateHslSpace()
  end
  
  --- @param h number
  --- @param s number
  --- @param l number
  --- @param a number
  --- @return Color
  function Color:hsla(h, s, l, a)
  	return Nyx.new(self, {
  		h = h or 0,
  		s = s or 1,
  		l = l or 1,
  		a = a or 255
  	}):updateRgbSpace()
  end
  
  --- @param fields Color
  --- @return Color
  function Color:newWithFields(fields)
  	return Nyx.new(self, fields)
  end
  
  --- @return Color
  function Color:clone()
  	return Color:newWithFields({
  		r = self.r,
  		g = self.g,
  		b = self.b,
  		h = self.h,
  		s = self.s,
  		l = self.l,
  		a = self.a
  	})
  end
  
  --- @return number, number, number, number
  function Color:unpack()
  	return self.r, self.g, self.b, self.a
  end
  
  --- @param p number
  --- @param q number
  --- @param t number
  --- @return number
  function Color.hueToRgb(p, q, t)
  	if t < 0 then
  		t = t + 1
  	end
  
  	if t > 1 then
  		t = t - 1
  	end
  
  	if t < 1 / 6 then
  		return p + (q - p) * 6 * t
  	end
  
  	if t < 1 / 2 then
  		return q
  	end
  
  	if t < 2 / 3 then
  		return p + (q - p) * (2 / 3 - t) * 6
  	end
  
  	return p
  end
  
  --- @return Color
  function Color:updateRgbSpace()
  	local r, g, b
  
  	if self.s == 0 then
  		r, g, b = self.l, self.l, self.l
  	else
  		local q = 0
  
  		if self.l < 0.5 then
  			q = self.l * (1 + self.s)
  		else
  			q = self.l + self.s - self.l * self.s
  		end
  
  		local p = 2 * self.l - q
  		local h = self.h / 360
  
  		r = Color.hueToRgb(p, q, h + 1 / 3)
  		g = Color.hueToRgb(p, q, h)
  		b = Color.hueToRgb(p, q, h - 1 / 3)
  	end
  
  	self.r = r * 255
  	self.g = g * 255
  	self.b = b * 255
  
  	return self
  end
  
  --- @return Color
  function Color:updateHslSpace()
  	local r, g, b = self.r / 255, self.g / 255, self.b / 255
  	local max, min = math.max(r, g, b), math.min(r, g, b)
  	local h, s, l
  
  	l = (max + min) / 2
  
  	if max == min then
  		h, s = 0, 0
  	else
  		local d = max - min
  
  		if l > 0.5 then
  			s = d / (2 - max - min)
  		else
  			s = d / (max + min)
  		end
  
  		if max == r then
  			h = (g - b) / d
  
  			if g < b then
  				h = h + 6
  			end
  		elseif max == g then
  			h = (b - r) / d + 2
  		elseif max == b then
  			h = (r - g) / d + 4
  		end
  
  		h = (h / 6) * 360
  	end
  
  	self.h, self.s, self.l = h, s, l or 255
  
  	return self
  end
  
  --- @param r number
  --- @return Color
  function Color:setRed(r)
  	self.r = r
  
  	return self:updateHslSpace()
  end
  
  --- @param g number
  --- @return Color
  function Color:setGreen(g)
  	self.g = g
  
  	return self:updateHslSpace()
  end
  
  --- @param b number
  --- @return Color
  function Color:setBlue(b)
  	self.b = b
  
  	return self:updateHslSpace()
  end
  
  --- @param h number
  --- @return Color
  function Color:setHue(h)
  	self.h = h
  
  	return self:updateRgbSpace()
  end
  
  --- @param l number
  --- @return Color
  function Color:setSaturation(l)
  	self.l = l
  
  	return self:updateRgbSpace()
  end
  
  --- @param l number
  --- @return Color
  function Color:setLightness(l)
  	self.l = l
  
  	return self:updateRgbSpace()
  end
  
  --- @param a number
  --- @return Color
  function Color:setA(a)
  	self.a = a
  
  	return self
  end
  
  --- @param r number
  --- @param g number
  --- @param b number
  --- @param a number
  --- @return Color
  function Color:set(r, g, b, a)
  	self.r = r
  	self.g = g
  	self.b = b
  	self.a = a
  
  	return self:updateHslSpace()
  end
  
  --- Returns 0 for white, and 1 for black depending on whether a colour is most visible against white or black.
  --- @param tolerance number
  --- @return number
  function Color:getContrast(tolerance)
  	if self.r * 0.213 + self.g * 0.715 + self.b * 0.072 < (tolerance or 150) then
  		return Color.IS_WHITE
  	end
  
  	return Color.IS_BLACK
  end
  
  --- @param amount number
  --- @return Color
  function Color:shiftHue(amount)
  	self.h = (self.h + amount) % 360
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:shiftSaturation(amount)
  	self.s = math.min(1, math.max(0, self.s + amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:shiftLightness(amount)
  	self.l = math.min(1, math.max(0, self.l + amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:lighten(amount)
  	self.l = math.min(1, math.max(0, self.l + amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:darken(amount)
  	self.l = math.min(1, math.max(0, self.l - amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:saturate(amount)
  	self.s = math.min(1, math.max(0, self.s + amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:desaturate(amount)
  	self.s = math.min(1, math.max(0, self.s - amount))
  
  	return self:updateRgbSpace()
  end
  
  --- @param amount number
  --- @return Color
  function Color:fadeIn(amount)
  	self.a = math.min(255, self.a + amount)
  
  	return self
  end
  
  --- @param amount number
  --- @return Color
  function Color:fadeOut(amount)
  	self.a = math.max(0, self.a - amount)
  
  	return self
  end
  
  return Nyx.class(
  	"Nyx/Color",
  	Color
  )
  --endregion
end
package.preload["gamesense/Nyx/Color"] = function() return return_values["Color"] end
--endregion

--region Client
libraries["Client"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  local Color = require "gamesense/Nyx/Color"
  
  --region SteamID
  local native_ConnectToGlobalUser = vtable_bind("steamclient.dll", "SteamClient017", 2, "int(__thiscall*)(void*, int)")
  local native_GetISteamUser = vtable_bind("steamclient.dll", "SteamClient017", 5, "int*(__thiscall*)(void*, int, int, const char*)")
  
  local native_GetSteamID = vtable_thunk(2, "uint64_t*(__thiscall*)(void*)")
  
  local hsteampipe = 1
  local hsteamuser = native_ConnectToGlobalUser(hsteampipe)
  local isteamuser = native_GetISteamUser(hsteamuser, hsteampipe, "SteamUser017")
  local steamid64 = tostring(native_GetSteamID(isteamuser)[0]):gsub("ULL$", "")
  --endregion
  
  --region Client
  --- @class Client : Class
  --- @field baseColor Color
  local Client = {
  	baseColor = Color:rgba(255, 255, 255, 255)
  }
  
  --- @return string
  function Client.getSteam64()
  	return steamid64
  end
  
  --- @return Vector3
  function Client.getCameraOrigin()
  	return VectorsAngles.Vector3:new(client.camera_position())
  end
  
  --- @return Vector3
  function Client.getEyeOrigin()
  	return VectorsAngles.Vector3:new(client.eye_position())
  end
  
  --- @return Angle
  function Client.getCameraAngles()
  	return VectorsAngles.Angle:new(client.camera_angles())
  end
  
  --- @return Vector2
  function Client.getScreenDimensions()
  	return VectorsAngles.Vector2:new(client.screen_size())
  end
  
  --- @return Vector2
  function Client.getScreenDimensionsCenter()
  	return VectorsAngles.Vector2:new(client.screen_size()) / 2
  end
  
  --- @return Vector3, number, number
  function Client.getCameraTrace()
  	local cameraPosition = Client.getCameraOrigin()
  
  	return cameraPosition:getTraceLine(
  		cameraPosition + Client.getCameraAngles():getForward() * 60000,
  		entity.get_local_player()
  	)
  end
  
  --- @param color Color
  --- @param text string
  function Client.indicator(color, text)
  	color = color or Client.baseColor
  
  	renderer.indicator(color.r, color.g, color.b, color.a, text)
  end
  
  return Nyx.abstract(
  	"Nyx/Client",
  	Client
  )
  --endregion
end
package.preload["gamesense/Nyx/Client"] = function() return return_values["Client"] end
--endregion

--region Engine
libraries["Engine"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local IEntity = require "gamesense/Nyx/IEntity"
  local Timer = require "gamesense/Nyx/Timer"
  local RenderMode = require "gamesense/Nyx/RenderMode"
  local Client = require "gamesense/Nyx/Client"
  
  --region EngineException
  --- @class EngineException : Exception
  local EngineException = {
  	ENTITY_INVALID_TYPE = 1
  }
  
  --- @param givenInput any
  --- @return void
  function EngineException:entityInvalidType(givenInput)
  	self:throw(EngineException.ENTITY_INVALID_TYPE, string.format(
  		"EntityManager was given an input of the type %s, but expected %s.",
  		Nyx.typeOf(givenInput),
  		Nyx.typeOf(IEntity)
  	))
  end
  
  Nyx.exception(
  	"Nyx/EngineException",
  	EngineException
  )
  --endregion
  
  --region Engine
  --- @class Engine : Class
  --- @field sortedEntities IEntity[]
  --- @field unsortedEntities IEntity[]
  --- @field entitiesByType table<string, IEntity[]>
  --- @field latestEid number
  --- @field tickInterval number
  --- @field tickTimer Timer
  local Engine = {
  	latestEid = 0,
  	tickInterval = 1
  }
  
  --- @return Engine
  function Engine:new()
  	return Nyx.new(self)
  end
  
  --- @return void
  function Engine:__init()
  	self.sortedEntities = {}
  	self.unsortedEntities = {}
  	self.entitiesByType = {}
  	self.tickTimer = Timer:new():start()
  
  	client.set_event_callback("paint", function()
  		self:processEntities()
  	end)
  end
  
  --- @param entity IEntity
  --- @return void
  function Engine:setupEntityTypes(entity)
  	if Nyx.instanceOf(entity, IEntity) == false then
  		EngineException:entityInvalidType(entity)
  	end
  
  	for _, type in pairs(entity:getTypes()) do
  		if self.entitiesByType[type] == nil then
  			self.entitiesByType[type] = {}
  		end
  	end
  end
  
  --- @generic T
  --- @param entityClass T|IEntity
  --- @return T[]
  function Engine:getAll(entityClass)
  	return self.entitiesByType[entityClass.__classid]
  end
  
  --- @return void
  function Engine:removeAllEntities()
  	for _, entity in pairs(self.sortedEntities) do
  		self:removeEntity(entity, true)
  	end
  
  	self.latestEid = 0
  end
  
  --- @param entity IEntity
  --- @return void
  function Engine:addEntity(entity)
  	if Nyx.instanceOf(entity, IEntity) == false then
  		EngineException:entityInvalidType(entity)
  	end
  
  	local eid = self.latestEid + 1
  
  	entity:setEid(eid)
  	entity:onSpawn()
  
  	if entity:getRenderMode() == RenderMode.NONE then
  		self.unsortedEntities[eid] = entity
  	else
  		self.sortedEntities[eid] = entity
  	end
  
  	self.latestEid = eid
  
  	for _, type in pairs(entity:getTypes()) do
  		self.entitiesByType[type][eid] = entity
  	end
  end
  
  --- @param entity IEntity
  --- @param silent boolean
  --- @return void
  function Engine:removeEntity(entity, silent)
  	local eid = entity:getEid()
  
  	if entity:getRenderMode() == RenderMode.NONE then
  		self.unsortedEntities[eid] = nil
  	else
  		self.sortedEntities[eid] = nil
  	end
  
  	for _, type in pairs(entity:getTypes()) do
  		self.entitiesByType[type][eid] = nil
  	end
  
  	if silent ~= true then
  		entity:onDeath()
  	end
  
  	self:removeChildrenOfEntity(entity, silent)
  end
  
  --- @param entity IEntity
  --- @param silent boolean
  --- @return void
  function Engine:removeChildrenOfEntity(entity, silent)
  	for _, child in pairs(entity:getChildren()) do
  		self:removeEntity(child, silent)
  	end
  end
  
  --- @return void
  function Engine:processEntities()
  	renderer.indicator(255, 255, 200, 255, string.format(
  		"%s total ents", self.latestEid
  	))
  
  	if self.tickTimer:elapsed(self.tickInterval) then
  		self:processEntitiesTickFrame()
  		self.tickTimer:restart()
  	else
  		self:processEntitiesFrame()
  	end
  end
  
  --- @return void
  function Engine:processEntitiesFrame()
  	local cameraPosition = Client.getCameraOrigin()
  
  	for _, entity in Nyx.spairs(self.sortedEntities, function(a, b)
  		return Engine.sortEntities(a, b, cameraPosition)
  	end) do
  		entity:thinkFrame()
  
  		for _, activity in pairs(entity:getActivities()) do
  			if activity:think() == true then
  				entity:killActivity(activity)
  			end
  		end
  	end
  
  	for _, entity in pairs(self.unsortedEntities) do
  		entity:thinkFrame()
  
  		for _, activity in pairs(entity:getActivities()) do
  			if activity:think() == true then
  				entity:killActivity(activity)
  			end
  		end
  	end
  end
  
  --- @return void
  function Engine:processEntitiesTickFrame()
  	local cameraPosition = Client.getCameraOrigin()
  
  	for _, entity in Nyx.spairs(self.sortedEntities, function(a, b)
  		return Engine.sortEntities(a, b, cameraPosition)
  	end) do
  		entity:thinkFrame()
  		entity:thinkTick()
  
  		for _, activity in pairs(entity:getActivities()) do
  			if activity:think() == true then
  				entity:killActivity(activity)
  			end
  		end
  	end
  
  	for _, entity in pairs(self.unsortedEntities) do
  		entity:thinkFrame()
  		entity:thinkTick()
  
  		for _, activity in pairs(entity:getActivities()) do
  			if activity:think() == true then
  				entity:killActivity(activity)
  			end
  		end
  	end
  end
  
  --- Sorts entities for rendering in the following order:
  --- Order WORLD render entities by their distance from far-to-close,
  --- and implicitly order no-render and UI-render entities last.
  --- Result will be how you expect a 2D3D engine to render Z-depth on all materials, GUI, and text.
  --- @param a IEntity
  --- @param b IEntity
  --- @param cameraPosition Vector3
  --- @return boolean
  function Engine.sortEntities(a, b, cameraPosition)
  	return
  	(a:getRenderType() == RenderMode.WORLD and a:getOrigin():getDistance(cameraPosition) or 0) >
  		(b:getRenderType() == RenderMode.WORLD and b:getOrigin():getDistance(cameraPosition) or 0)
  end
  
  return Nyx.class(
  	"Nyx/Engine",
  	Engine
  )
  --endregion
end
package.preload["gamesense/Nyx/Engine"] = function() return return_values["Engine"] end
--endregion

--region AbstractEntity
libraries["AbstractEntity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local IEntity = require "gamesense/Nyx/IEntity"
  local Engine = require "gamesense/Nyx/Engine"
  
  --region AbstractEntity
  --- @class AbstractEntity : IEntity
  --- @field eid number
  --- @field parent IEntity
  --- @field children IEntity[]
  --- @field origin Vector2
  --- @field renderType number Render types: 0 - none, 1 - UI, 2 - World
  local AbstractEntity = {
  	renderType = 0
  }
  
  --- @return void
  function AbstractEntity:__setup()
  	Engine:setupEntityTypes(self)
  end
  
  --- @return void
  function AbstractEntity:__init()
  	self.children = {}
  	self.availableActivities = {}
  	self.activeActivities = {}
  
  	Engine:addEntity(self)
  end
  
  --- @return void
  function AbstractEntity:getEid()
  	return self.eid
  end
  
  --- @param eid number
  --- @return void
  function AbstractEntity:setEid(eid)
  	self.eid = eid
  end
  
  --- @return string[]
  function AbstractEntity:getTypes()
  	local types = {}
  
  	for _, class in pairs(Nyx.getInheritance(self)) do
  		table.insert(types, class.__classid)
  	end
  
  	return types
  end
  
  --- @return void
  function AbstractEntity:onSpawn() end
  
  --- @return void
  function AbstractEntity:onDeath() end
  
  --- @param entity IEntity
  --- @return void
  function AbstractEntity:addChild(entity)
  	table.insert(self.children, entity)
  end
  
  --- @return IEntity[]
  function AbstractEntity:getChildren()
  	return self.children
  end
  
  --- @return IEntity
  function AbstractEntity:getParent()
  	return self.parent
  end
  
  --- @param entity IEntity
  --- @return void
  function AbstractEntity:setParent(entity)
  	self.parent = entity
  end
  
  --- @return Vector3
  function AbstractEntity:getOrigin()
  	return self.origin
  end
  
  --- @return void
  function AbstractEntity:thinkFrame() end
  
  --- @return void
  function AbstractEntity:thinkTick() end
  
  --- @param silent boolean
  --- @return void
  function AbstractEntity:kill(silent)
  	Engine:removeEntity(self, silent)
  end
  
  --- @return number
  function AbstractEntity:getRenderType()
  	return self.renderType
  end
  
  return Nyx.abstract(
  	"Nyx/AbstractEntity",
  	AbstractEntity,
  	IEntity
  )
  --endregion
end
package.preload["gamesense/Nyx/AbstractEntity"] = function() return return_values["AbstractEntity"] end
--endregion

--region Activity
libraries["Activity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Activity
  --- @class Activity : Class
  --- @field entity IEntity
  --- @field name string
  --- @field startCallback fun(self: IEntity): void
  --- @field callback fun(self: IEntity): boolean @ return true to stop activity.
  local Activity = {}
  
  --- @param entity IEntity
  --- @param name string
  --- @param startCallback fun(self: IEntity): void
  --- @param callback fun(self: IEntity): boolean @ return true to stop activity.
  --- @return Activity
  function Activity:new(entity, name, startCallback, callback)
  	return Nyx.new(self, {
  		entity = entity,
  		name = name,
  		startCallback = startCallback,
  		callback = callback
  	})
  end
  
  --- @return void
  function Activity:start()
  	self.startCallback(self.entity)
  end
  
  --- @return void
  function Activity:think()
  	self.callback(self.entity)
  end
  
  return Nyx.class(
  	"Nyx/Activity",
  	Activity
  )
  --endregion
end
package.preload["gamesense/Nyx/Activity"] = function() return return_values["Activity"] end
--endregion

--region Animate
libraries["Animate"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Animate
  --- @class Animate : Abstract
  local Animate = {}
  
  --- @param current number
  --- @param target number
  --- @param time number
  --- @return number
  function Animate.lerp(current, target, time)
      return (1 - time) * current + time * target
  end
  
  --- @param current number
  --- @param target number
  --- @param speed number
  --- @return number
  function Animate.lerpSmooth(current, target, speed)
      return current + (target - current) * speed * self.world:delta()
  end
  
  --- @param val number
  --- @param freq number
  --- @param amp number
  --- @param timer Timer|nil
  --- @return number
  function Animate.float(val, freq, amp, timer)
      return val + math.sin(timer and timer:get() or globals.realtime() * math.pi * freq) * amp * self.world:delta()
  end
  
  return Nyx.abstract(
  	"Nyx/Animate",
  	Animate
  )
  --endregion
end
package.preload["gamesense/Nyx/Animate"] = function() return return_values["Animate"] end
--endregion

--region Benchmark
libraries["Benchmark"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Benchmark
  --- @class Benchmark : Abstract
  local Benchmark = {}
  
  --- @param callback fun(): void
  --- @param iterations number
  function Benchmark.run(callback, iterations)
      local start = client.timestamp()
  
      for _ = 1, (iterations or 100000) do
          callback()
      end
  
      print(string.format("Benchmark completed. Execution time: %.10fs", client.timestamp() - start))
  end
  
  return Nyx.abstract(
      "Nyx/Benchmark",
      Benchmark
  )
  --endregion
end
package.preload["gamesense/Nyx/Benchmark"] = function() return return_values["Benchmark"] end
--endregion

--region WeaponClasses
libraries["WeaponClasses"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region WeaponClasses
  --- @class WeaponClasses : Enum
  local WeaponClasses = {
  	CAK47 = "AK47",
  	CDeagle = "Desert Eagle",
  	CKnife = "Knife",
  	CKnifeGG = "Knife GG",
  	CWeaponAUG = "AUG",
  	CWeaponAWP = "AWP",
  	CWeaponBizon = "Bizon",
  	CWeaponElite = "Elite",
  	CWeaponFamas = "Famas",
  	CWeaponFiveSeven = "Fiveseven",
  	CWeaponG3SG1 = "G3SG1",
  	CWeaponGalilAR = "Galil",
  	CWeaponGlock = "Glock",
  	CWeaponHKP2000 = "P2000",
  	CWeaponM249 = "M249",
  	CWeaponM4A1 = "M4A1",
  	CWeaponMAC10 = "Mac10",
  	CWeaponMag7 = "Mag7",
  	CWeaponMP7 = "MP7",
  	CWeaponMP9 = "MP9",
  	CWeaponNegev = "Negev",
  	CWeaponNOVA = "Nova",
  	CWeaponP228 = "P228",
  	CWeaponP250 = "P250",
  	CWeaponP90 = "P90",
  	CWeaponSawedoff = "Sawedoff",
  	CWeaponSCAR20 = "Scar20",
  	CWeaponSSG08 = "SSG08",
  	CWeaponSG556 = "SG556",
  	CWeaponTaser = "Taser",
  	CWeaponTaser = "Zeus",
  	CWeaponTec9 = "Tec9",
  	CWeaponUMP45 = "Ump45",
  	CWeaponXM1014 = "Xm1014",
  	CDecoyGrenade = "Decoy",
  	CFlashbang = "Flash",
  	CHEGrenade = "Grenade",
  	CSmokeGrenade = "Smoke",
  	CIncendiaryGrenade = "Incendiary",
  	CMolotovGrenade = "Molotov",
  	CSensorGrenade = "Sensor",
  	CSnowball = "Snowball",
  	CTablet = "Tablet",
  	CItem_Healthshot = "Healthshot",
  	CBreachCharge = "Breach charge",
  	CC4 = "C4",
  	CFists = "Fists",
  	CEconEntity = "Econ",
  	CItemCash = "Cash",
  	CItemDogtags = "Dogtags",
  	CMelee = "Melee",
  	CBumpMine = "Bump mine"
  }
  
  return Nyx.enum(
  	"Nyx/WeaponClasses",
  	WeaponClasses
  )
  --endregion
end
package.preload["gamesense/Nyx/WeaponClasses"] = function() return return_values["WeaponClasses"] end
--endregion

--region Panorama
libraries["Panorama"] = function()
	return panorama.open()
end
package.preload["gamesense/Nyx/Panorama"] = function() return return_values["Panorama"] end
--endregion

--region Player
libraries["Player"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  local Angle, _, Vector3 = VectorsAngles.Angle, VectorsAngles.Vector2, VectorsAngles.Vector3
  local WeaponClasses = require "gamesense/Nyx/WeaponClasses"
  local Panorama = require "gamesense/Nyx/Panorama"
  
  --region Player
  --- @class Player : Class
  --- @field eid number
  local Player = {}
  
  --- @param eid number
  --- @return Player
  function Player:new(eid)
  	return Nyx.new(self, {
  		eid = eid
  	})
  end
  
  --- Instantiate an object of Player.
  --- @param uid number
  --- @return Player
  function Player:newFromUserid(uid)
  	return Player:new(client.userid_to_entindex(uid))
  end
  
  --- @return boolean
  function Player.exists(eid)
  	return entity.get_classname(eid) ~= nil
  end
  
  --- @return Player
  function Player.getLocalPlayer()
  	return Player:new(entity.get_local_player())
  end
  
  --- @return number
  function Player.getLocalPlayerEid()
  	return entity.get_local_player()
  end
  
  --- @param searchFilter fun(player: Player): boolean
  --- @return Player[]
  function Player.findAll(searchFilter)
  	local players = {}
  	local playerResource = entity.get_player_resource()
  
  	for i = 1, globals.maxplayers() do repeat
  		if entity.get_prop(playerResource, "m_bConnected", i) ~= 1 then
  			break
  		end
  
  		local player = Player:new(i)
  
  		if searchFilter == nil or searchFilter(player) then
  			players[i] = player
  		end
  	until true end
  
  	return players
  end
  
  --- @param searchFilter fun(player: Player): boolean
  --- @return fun(t: table<number, Player>): number, Player
  function Player.find(searchFilter)
  	local players = {}
  	local playerResource = entity.get_player_resource()
  	local insertIndex = 1
  
  	for eid = 1, globals.maxplayers() do repeat
  		if entity.get_prop(playerResource, "m_bConnected", eid) ~= 1 then
  			break
  		end
  
  		if entity.get_origin(eid) == nil then
  			break
  		end
  
  		local player = Player:new(eid)
  
  		if searchFilter == nil or searchFilter(player) then
  			players[insertIndex] = player
  			insertIndex = insertIndex + 1
  		end
  	until true end
  
  	return players
  end
  
  --- @return any
  function Player:getProperty(property)
  	return entity.get_prop(self and self.eid or entity.get_local_player(), property)
  end
  
  --- @return any
  function Player:setProperty(property, value)
  	return entity.set_prop(self and self.eid or entity.get_local_player(), property, value)
  end
  
  --- @return string
  function Player:getSteam64()
  	return Panorama.GameStateAPI.GetPlayerXuidStringFromEntIndex(self and self.eid or entity.get_local_player())
  end
  
  --- @return string
  function Player:getName()
  	return entity.get_player_name(self and self.eid or entity.get_local_player())
  end
  
  --- @param player Player
  --- @return boolean
  function Player:is(player)
  	return self and self.eid or entity.get_local_player() == player.eid
  end
  
  --- @return boolean
  function Player:isLocalPlayer()
  	return self and self.eid or entity.get_local_player() == entity.get_local_player()
  end
  
  --- @return boolean
  function Player:isEnemy()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iTeamNum") ~= entity.get_prop(entity.get_local_player(), "m_iTeamNum")
  end
  
  --- @return boolean
  function Player:isTeammate()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iTeamNum") == entity.get_prop(entity.get_local_player(), "m_iTeamNum")
  end
  
  --- @param player Player
  --- @return boolean
  function Player:isEnemyOf(player)
  	return self:m_iTeamNum() ~= player:m_iTeamNum()
  end
  
  --- @param player Player
  --- @return boolean
  function Player:isTeammateOf(player)
  	return self:m_iTeamNum() == player:m_iTeamNum()
  end
  
  --- @return boolean
  function Player:isSpectator()
  	return self:m_iTeamNum() == 1
  end
  
  --- @return boolean
  function Player:isTerrorist()
  	return self:m_iTeamNum() == 2
  end
  
  --- @return boolean
  function Player:isCounterTerrorist()
  	return self:m_iTeamNum() == 3
  end
  
  --- @return boolean
  function Player:isDormant()
  	return entity.is_dormant(self and self.eid or entity.get_local_player())
  end
  
  --- @return Vector3
  function Player:getOrigin()
  	return Vector3:new(entity.get_origin(self and self.eid or entity.get_local_player()))
  end
  
  --- @class PlayerEspBoundariesStruct
  --- @field public tl Vector3
  --- @field public br Vector3
  --- @return PlayerEspBoundariesStruct
  function Player:getEspBounds()
  	local x1, y1, x2, y2, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return { tl = Vector3:new(x1, y1, 0, true), br = Vector3:new(x2, y2, 0, true) }
  end
  
  --- @return Vector3
  function Player:getEspTopLeft()
  	local x1, y1, _, _, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x1, y1, 0, true)
  end
  
  --- @return Vector3
  function Player:getEspTopRight()
  	local _, y1, x2, _, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x2, y1, 0, true)
  end
  
  --- @return Vector3
  function Player:getEspTopCenter()
  	local x1, y1, x2, _, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x1 / 2 + x2 / 2, y1, 0, true)
  end
  
  --- @return Vector3
  function Player:getEspBottomLeft()
  	local x1, _, _, y2, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x1, y2, 0, true)
  end
  
  --- @return Vector3
  function Player:getEspBottomRight()
  	local _, _, x2, y2, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x2, y2, 0, true)
  end
  
  --- @return Vector3
  function Player:getEspBottomCenter()
  	local x1, _, x2, y2, a = entity.get_bounding_box(self and self.eid or entity.get_local_player())
  
  	if a == 0 then
  		return nil
  	end
  
  	return Vector3:new(x1 / 2 + x2 / 2, y2, 0, true)
  end
  
  --- @return Vector3
  function Player:getEyePosition()
  	if self and self.eid or entity.get_local_player() == entity.get_local_player() then
  		return Vector3:new(client.eye_position())
  	end
  
  	local eyePosition = Vector3:new(entity.get_origin(self and self.eid or entity.get_local_player()))
  	local duckAmount = entity.get_prop(self and self.eid or entity.get_local_player(), "m_flDuckAmount") or 0
  
  	eyePosition.z = eyePosition.z + 46 + (1 - duckAmount) * 18
  
  	return eyePosition
  end
  
  --- @return Angle
  function Player:getCameraAngles()
  	if self and self.eid or entity.get_local_player() == entity.get_local_player() == false then
  		error("Cannot get camera angles of other clients.")
  	end
  
  	return Angle:new(client.camera_angles())
  end
  
  --- @param hitbox number
  --- @return Vector3
  function Player:getHitboxPosition(hitbox)
  	return Vector3:new(entity.hitbox_position(self and self.eid or entity.get_local_player(), hitbox))
  end
  
  --- @param hitboxes table<number, number>
  --- @return table<number, Vector3:new_c>
  function Player:getHitboxPositions(hitboxes)
  	local result = {}
  
  	if hitboxes ~= nil then
  		for _, hitbox in pairs(hitboxes) do
  			table.insert(result, self:getHitboxPosition(hitbox))
  		end
  	else
  		for i = 0, 18 do
  			result[i] = self:getHitboxPosition(i)
  		end
  	end
  
  	return result
  end
  
  --- @return number
  function Player:getSteamId()
  	return entity.get_steam64(self and self.eid or entity.get_local_player())
  end
  
  --- @return boolean
  function Player:isBot()
  	return self and self:getSteamId() == "0" or false
  end
  
  --- @return string
  function Player:getWeaponClass()
  	return entity.get_classname(entity.get_player_weapon(self and self.eid or entity.get_local_player()))
  end
  
  --- @return string
  function Player:getWeaponName()
  	return WeaponClasses[entity.get_classname(entity.get_player_weapon(self and self.eid or entity.get_local_player()))]
  end
  
  --- @return boolean
  function Player:isAlive()
  	return entity.is_alive(self and self.eid or entity.get_local_player())
  end
  
  --- @return string
  function Player:getTeamName()
  	local team = self:m_iTeamNum()
  
  	if team == 0 or team == nil then
  		return "None"
  	elseif team == 1 then
  		return "Spectator"
  	elseif team == 2 then
  		return "Terrorist"
  	elseif team == 3 then
  		return "Counter-Terrorist"
  	end
  end
  
  --- @return boolean
  function Player:isHoldingWeapon(className)
  	return self:getWeaponClass() == className
  end
  
  --- @return boolean
  function Player:isHoldingWeapons(classNames)
  	local weapon = self:getWeaponClass()
  
  	for _, class_name in pairs(classNames) do
  		if weapon == class_name then
  			return true
  		end
  	end
  
  	return false
  end
  
  --- @return number
  function Player:getKdRatio()
  	local kills = self:m_iKills()
  	local deaths = self:m_iDeaths()
  
  	if deaths == 0 then
  		return 0
  	end
  
  	return kills / deaths
  end
  
  --- @return any
  function Player:m_iPing()
  	return entity.get_prop(entity.get_player_resource(), "m_iPing", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iAssists()
  	return entity.get_prop(entity.get_player_resource(), "m_iAssists", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iDeaths()
  	return entity.get_prop(entity.get_player_resource(), "m_iDeaths", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_bConnected()
  	return entity.get_prop(entity.get_player_resource(), "m_bConnected", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iTeam()
  	return entity.get_prop(entity.get_player_resource(), "m_iTeam", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iPendingTeam()
  	return entity.get_prop(entity.get_player_resource(), "m_iPendingTeam", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_bAlive()
  	return entity.get_prop(entity.get_player_resource(), "m_bAlive", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iHealth()
  	return entity.get_prop(entity.get_player_resource(), "m_iHealth", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iKills()
  	return entity.get_prop(entity.get_player_resource(), "m_iKills", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCoachingTeam()
  	return entity.get_prop(entity.get_player_resource(), "m_iCoachingTeam", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_hostageRescueX()
  	return entity.get_prop(entity.get_player_resource(), "m_hostageRescueX", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_hostageRescueY()
  	return entity.get_prop(entity.get_player_resource(), "m_hostageRescueY", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_hostageRescueZ()
  	return entity.get_prop(entity.get_player_resource(), "m_hostageRescueZ", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMVPs()
  	return entity.get_prop(entity.get_player_resource(), "m_iMVPs", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iArmor()
  	return entity.get_prop(entity.get_player_resource(), "m_iArmor", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_bHasDefuser()
  	return entity.get_prop(entity.get_player_resource(), "m_bHasDefuser", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_bHasHelmet()
  	return entity.get_prop(entity.get_player_resource(), "m_bHasHelmet", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iScore()
  	return entity.get_prop(entity.get_player_resource(), "m_iScore", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCompetitiveRanking()
  	return entity.get_prop(entity.get_player_resource(), "m_iCompetitiveRanking", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCompetitiveWins()
  	return entity.get_prop(entity.get_player_resource(), "m_iCompetitiveWins", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCompetitiveRankType()
  	return entity.get_prop(entity.get_player_resource(), "m_iCompetitiveRankType", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCompTeammateColor()
  	return entity.get_prop(entity.get_player_resource(), "m_iCompTeammateColor", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iLifetimeStart()
  	return entity.get_prop(entity.get_player_resource(), "m_iLifetimeStart", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iLifetimeEnd()
  	return entity.get_prop(entity.get_player_resource(), "m_iLifetimeEnd", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_bControllingBot()
  	return entity.get_prop(entity.get_player_resource(), "m_bControllingBot", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iControlledPlayer()
  	return entity.get_prop(entity.get_player_resource(), "m_iControlledPlayer", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iControlledByPlayer()
  	return entity.get_prop(entity.get_player_resource(), "m_iControlledByPlayer", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iBotDifficulty()
  	return entity.get_prop(entity.get_player_resource(), "m_iBotDifficulty", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_szClan()
  	return entity.get_prop(entity.get_player_resource(), "m_szClan", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iTotalCashSpent()
  	return entity.get_prop(entity.get_player_resource(), "m_iTotalCashSpent", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iGunGameLevel()
  	return entity.get_prop(entity.get_player_resource(), "m_iGunGameLevel", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iCashSpentThisRound()
  	return entity.get_prop(entity.get_player_resource(), "m_iCashSpentThisRound", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nEndMatchNextMapVotes()
  	return entity.get_prop(entity.get_player_resource(), "m_nEndMatchNextMapVotes", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nActiveCoinRank()
  	return entity.get_prop(entity.get_player_resource(), "m_nActiveCoinRank", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nMusicID()
  	return entity.get_prop(entity.get_player_resource(), "m_nMusicID", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nPersonaDataPublicLevel()
  	return entity.get_prop(entity.get_player_resource(), "m_nPersonaDataPublicLevel", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nPersonaDataPublicCommendsLeader()
  	return entity.get_prop(entity.get_player_resource(), "m_nPersonaDataPublicCommendsLeader", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nPersonaDataPublicCommendsTeacher()
  	return entity.get_prop(entity.get_player_resource(), "m_nPersonaDataPublicCommendsTeacher", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_nPersonaDataPublicCommendsFriendly()
  	return entity.get_prop(entity.get_player_resource(), "m_nPersonaDataPublicCommendsFriendly", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_Kills_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_Kills_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_5k_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_5k_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_4k_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_4k_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_3k_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_3k_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_Damage_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_Damage_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_EquipmentValue_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_EquipmentValue_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_KillReward_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_KillReward_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_LiveTime_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_LiveTime_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_Deaths_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_Deaths_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_Assists_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_Assists_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_HeadShotKills_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_HeadShotKills_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_Objective_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_Objective_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_CashEarned_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_CashEarned_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_iMatchStats_UtilityDamage_Total()
  	return entity.get_prop(entity.get_player_resource(), "m_iMatchStats_UtilityDamage_Total", self and self.eid or entity.get_local_player())
  end
  
  --- @return any
  function Player:m_flAnimTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flAnimTime")
  end
  
  --- @return any
  function Player:m_flSimulationTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flSimulationTime")
  end
  
  --- @return any
  function Player:m_cellbits()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_cellbits")
  end
  
  --- @return any
  function Player:m_cellX()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_cellX")
  end
  
  --- @return any
  function Player:m_cellY()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_cellY")
  end
  
  --- @return any
  function Player:m_cellZ()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_cellZ")
  end
  
  --- @return Vector3
  function Player:m_vecOrigin()
  	local x, _, _ = entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecOrigin")
  
  	if x == nil then
  		return nil
  	end
  
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecOrigin"))
  end
  
  --- @return Vector3
  function Player:m_vecAbsOrigin()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecAbsOrigin"))
  end
  
  --- @return any
  function Player:m_nModelIndex()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nModelIndex")
  end
  
  --- @return Vector3
  function Player:m_vecMins()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecMins"))
  end
  
  --- @return Vector3
  function Player:m_vecMaxs()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecMaxs"))
  end
  
  --- @return any
  function Player:m_nSolidType()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nSolidType")
  end
  
  --- @return any
  function Player:m_usSolidFlags()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_usSolidFlags")
  end
  
  --- @return any
  function Player:m_nSurroundType()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nSurroundType")
  end
  
  --- @return any
  function Player:m_triggerBloat()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_triggerBloat")
  end
  
  --- @return Vector3
  function Player:m_vecSpecifiedSurroundingMins()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecSpecifiedSurroundingMins"))
  end
  
  --- @return Vector3
  function Player:m_vecSpecifiedSurroundingMaxs()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecSpecifiedSurroundingMaxs"))
  end
  
  --- @return any
  function Player:m_nRenderFX()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nRenderFX")
  end
  
  --- @return any
  function Player:m_nRenderMode()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nRenderMode")
  end
  
  --- @return any
  function Player:m_fEffects()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fEffects")
  end
  
  --- @return any
  function Player:m_clrRender()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_clrRender")
  end
  
  --- @return any
  function Player:m_iTeamNum()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iTeamNum")
  end
  
  --- @return any
  function Player:m_iPendingTeamNum()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iPendingTeamNum")
  end
  
  --- @return any
  function Player:m_CollisionGroup()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_CollisionGroup")
  end
  
  --- @return any
  function Player:m_flElasticity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flElasticity")
  end
  
  --- @return any
  function Player:m_flShadowCastDistance()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flShadowCastDistance")
  end
  
  --- @return any
  function Player:m_hOwnerEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hOwnerEntity")
  end
  
  --- @return any
  function Player:m_hEffectEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hEffectEntity")
  end
  
  --- @return any
  function Player:m_iParentAttachment()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iParentAttachment")
  end
  
  --- @return any
  function Player:m_iName()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iName")
  end
  
  --- @return Angle
  function Player:m_angRotation()
  	return Angle:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_angRotation"))
  end
  
  --- @return any
  function Player:m_iTextureFrameIndex()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iTextureFrameIndex")
  end
  
  --- @return any
  function Player:m_bSimulatedEveryTick()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bSimulatedEveryTick")
  end
  
  --- @return any
  function Player:m_bAnimatedEveryTick()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bAnimatedEveryTick")
  end
  
  --- @return any
  function Player:m_bAlternateSorting()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bAlternateSorting")
  end
  
  --- @return any
  function Player:m_bSpotted()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bSpotted")
  end
  
  --- @return any
  function Player:m_bSpottedByMask()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bSpottedByMask")
  end
  
  --- @return any
  function Player:m_bIsAutoaimTarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsAutoaimTarget")
  end
  
  --- @return any
  function Player:m_fadeMinDist()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fadeMinDist")
  end
  
  --- @return any
  function Player:m_fadeMaxDist()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fadeMaxDist")
  end
  
  --- @return any
  function Player:m_flFadeScale()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFadeScale")
  end
  
  --- @return any
  function Player:m_nMinCPULevel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nMinCPULevel")
  end
  
  --- @return any
  function Player:m_nMaxCPULevel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nMaxCPULevel")
  end
  
  --- @return any
  function Player:m_nMinGPULevel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nMinGPULevel")
  end
  
  --- @return any
  function Player:m_nMaxGPULevel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nMaxGPULevel")
  end
  
  --- @return any
  function Player:m_flUseLookAtAngle()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flUseLookAtAngle")
  end
  
  --- @return any
  function Player:m_flLastMadeNoiseTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flLastMadeNoiseTime")
  end
  
  --- @return any
  function Player:m_flMaxFallVelocity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flMaxFallVelocity")
  end
  
  --- @return any
  function Player:m_bEligibleForScreenHighlight()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bEligibleForScreenHighlight")
  end
  
  --- @return any
  function Player:m_nForceBone()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nForceBone")
  end
  
  --- @return Vector3
  function Player:m_vecForce()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecForce"))
  end
  
  --- @return any
  function Player:m_nSkin()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nSkin")
  end
  
  --- @return any
  function Player:m_nBody()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nBody")
  end
  
  --- @return any
  function Player:m_nHitboxSet()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nHitboxSet")
  end
  
  --- @return any
  function Player:m_flModelScale()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flModelScale")
  end
  
  --- @return any
  function Player:m_flPoseParameter()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flPoseParameter")
  end
  
  --- @return any
  function Player:m_nSequence()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nSequence")
  end
  
  --- @return any
  function Player:m_flPlaybackRate()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flPlaybackRate")
  end
  
  --- @return any
  function Player:m_flEncodedController()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flEncodedController")
  end
  
  --- @return any
  function Player:m_bClientSideAnimation()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bClientSideAnimation")
  end
  
  --- @return any
  function Player:m_bClientSideFrameReset()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bClientSideFrameReset")
  end
  
  --- @return any
  function Player:m_bClientSideRagdoll()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bClientSideRagdoll")
  end
  
  --- @return any
  function Player:m_nNewSequenceParity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nNewSequenceParity")
  end
  
  --- @return any
  function Player:m_nResetEventsParity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nResetEventsParity")
  end
  
  --- @return any
  function Player:m_nMuzzleFlashParity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nMuzzleFlashParity")
  end
  
  --- @return any
  function Player:m_hLightingOrigin()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hLightingOrigin")
  end
  
  --- @return any
  function Player:m_flCycle()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flCycle")
  end
  
  --- @return any
  function Player:m_flFrozen()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFrozen")
  end
  
  --- @return any
  function Player:m_ScaleType()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_ScaleType")
  end
  
  --- @return any
  function Player:m_bSuppressAnimSounds()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bSuppressAnimSounds")
  end
  
  --- @return any
  function Player:m_nHighlightColorR()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nHighlightColorR")
  end
  
  --- @return any
  function Player:m_nHighlightColorG()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nHighlightColorG")
  end
  
  --- @return any
  function Player:m_nHighlightColorB()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nHighlightColorB")
  end
  
  --- @return any
  function Player:m_flexWeight()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flexWeight")
  end
  
  --- @return any
  function Player:m_blinktoggle()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_blinktoggle")
  end
  
  --- @return any
  function Player:m_viewtarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_viewtarget")
  end
  
  --- @return any
  function Player:m_flNextAttack()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flNextAttack")
  end
  
  --- @return any
  function Player:m_LastHitGroup()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_LastHitGroup")
  end
  
  --- @return any
  function Player:m_hActiveWeapon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hActiveWeapon")
  end
  
  --- @return any
  function Player:m_flTimeOfLastInjury()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flTimeOfLastInjury")
  end
  
  --- @return any
  function Player:m_hMyWeapons()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hMyWeapons")
  end
  
  --- @return any
  function Player:m_hMyWearables()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hMyWearables")
  end
  
  --- @return any
  function Player:m_nRelativeDirectionOfLastInjury()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nRelativeDirectionOfLastInjury")
  end
  
  --- @return any
  function Player:m_afPhysicsFlags()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_afPhysicsFlags")
  end
  
  --- @return any
  function Player:m_hVehicle()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hVehicle")
  end
  
  --- @return any
  function Player:m_hUseEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hUseEntity")
  end
  
  --- @return any
  function Player:m_hGroundEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hGroundEntity")
  end
  
  --- @return any
  function Player:m_iHealth()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iHealth")
  end
  
  --- @return any
  function Player:m_lifeState()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_lifeState")
  end
  
  --- @return any
  function Player:m_iAmmo()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iAmmo")
  end
  
  --- @return any
  function Player:m_iBonusProgress()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iBonusProgress")
  end
  
  --- @return any
  function Player:m_iBonusChallenge()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iBonusChallenge")
  end
  
  --- @return any
  function Player:m_flMaxspeed()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flMaxspeed")
  end
  
  --- @return any
  function Player:m_fFlags()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fFlags")
  end
  
  --- @return any
  function Player:m_iObserverMode()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iObserverMode")
  end
  
  --- @return any
  function Player:m_bActiveCameraMan()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bActiveCameraMan")
  end
  
  --- @return any
  function Player:m_bCameraManXRay()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bCameraManXRay")
  end
  
  --- @return any
  function Player:m_bCameraManOverview()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bCameraManOverview")
  end
  
  --- @return any
  function Player:m_bCameraManScoreBoard()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bCameraManScoreBoard")
  end
  
  --- @return any
  function Player:m_uCameraManGraphs()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_uCameraManGraphs")
  end
  
  --- @return any
  function Player:m_iCoachingTeam()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iCoachingTeam")
  end
  
  --- @return any
  function Player:m_hObserverTarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hObserverTarget")
  end
  
  --- @return any
  function Player:m_iFOV()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iFOV")
  end
  
  --- @return any
  function Player:m_iFOVStart()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iFOVStart")
  end
  
  --- @return any
  function Player:m_flFOVTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFOVTime")
  end
  
  --- @return any
  function Player:m_iDefaultFOV()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iDefaultFOV")
  end
  
  --- @return any
  function Player:m_hZoomOwner()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hZoomOwner")
  end
  
  --- @return any
  function Player:m_hViewModel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hViewModel")
  end
  
  --- @return any
  function Player:m_szLastPlaceName()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_szLastPlaceName")
  end
  
  --- @return Vector3
  function Player:m_vecLadderNormal()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecLadderNormal"))
  end
  
  --- @return any
  function Player:m_ladderSurfaceProps()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_ladderSurfaceProps")
  end
  
  --- @return any
  function Player:m_ubEFNoInterpParity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_ubEFNoInterpParity")
  end
  
  --- @return any
  function Player:m_iDeathPostEffect()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iDeathPostEffect")
  end
  
  --- @return any
  function Player:m_hPostProcessCtrl()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hPostProcessCtrl")
  end
  
  --- @return any
  function Player:m_hColorCorrectionCtrl()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hColorCorrectionCtrl")
  end
  
  --- @return any
  function Player:m_vphysicsCollisionState()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_vphysicsCollisionState")
  end
  
  --- @return any
  function Player:m_hViewEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hViewEntity")
  end
  
  --- @return any
  function Player:m_bShouldDrawPlayerWhileUsingViewEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bShouldDrawPlayerWhileUsingViewEntity")
  end
  
  --- @return any
  function Player:m_flDuckAmount()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flDuckAmount")
  end
  
  --- @return any
  function Player:m_flDuckSpeed()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flDuckSpeed")
  end
  
  --- @return any
  function Player:m_chAreaBits()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_chAreaBits")
  end
  
  --- @return any
  function Player:m_nWaterLevel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nWaterLevel")
  end
  
  --- @return any
  function Player:m_chAreaPortalBits()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_chAreaPortalBits")
  end
  
  --- @return any
  function Player:m_iHideHUD()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iHideHUD")
  end
  
  --- @return any
  function Player:m_flFOVRate()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFOVRate")
  end
  
  --- @return any
  function Player:m_bDucked()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bDucked")
  end
  
  --- @return any
  function Player:m_bDucking()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bDucking")
  end
  
  --- @return any
  function Player:m_flLastDuckTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flLastDuckTime")
  end
  
  --- @return any
  function Player:m_bInDuckJump()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bInDuckJump")
  end
  
  --- @return any
  function Player:m_nDuckTimeMsecs()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nDuckTimeMsecs")
  end
  
  --- @return any
  function Player:m_nDuckJumpTimeMsecs()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nDuckJumpTimeMsecs")
  end
  
  --- @return any
  function Player:m_nJumpTimeMsecs()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nJumpTimeMsecs")
  end
  
  --- @return any
  function Player:m_flFallVelocity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFallVelocity")
  end
  
  --- @return any
  function Player:m_viewPunchAngle()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_viewPunchAngle")
  end
  
  --- @return Angle
  function Player:m_aimPunchAngle()
  	return Angle:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_aimPunchAngle"))
  end
  
  --- @return any
  function Player:m_aimPunchAngleVel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_aimPunchAngleVel")
  end
  
  --- @return any
  function Player:m_bDrawViewmodel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bDrawViewmodel")
  end
  
  --- @return any
  function Player:m_bWearingSuit()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bWearingSuit")
  end
  
  --- @return any
  function Player:m_bPoisoned()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bPoisoned")
  end
  
  --- @return any
  function Player:m_flStepSize()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flStepSize")
  end
  
  --- @return any
  function Player:m_bAllowAutoMovement()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bAllowAutoMovement")
  end
  
  --- @return any
  function Player:m_flFriction()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFriction")
  end
  
  --- @return any
  function Player:m_fOnTarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fOnTarget")
  end
  
  --- @return any
  function Player:m_nTickBase()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nTickBase")
  end
  
  --- @return any
  function Player:m_nNextThinkTick()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nNextThinkTick")
  end
  
  --- @return any
  function Player:m_hLastWeapon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hLastWeapon")
  end
  
  --- @return Vector3
  function Player:m_vecBaseVelocity()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecBaseVelocity"))
  end
  
  --- @return Vector3
  function Player:m_vecVelocity()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecVelocity"))
  end
  
  --- @return any
  function Player:m_hConstraintEntity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hConstraintEntity")
  end
  
  --- @return Vector3
  function Player:m_vecConstraintCenter()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecConstraintCenter"))
  end
  
  --- @return any
  function Player:m_flConstraintRadius()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flConstraintRadius")
  end
  
  --- @return any
  function Player:m_flConstraintWidth()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flConstraintWidth")
  end
  
  --- @return any
  function Player:m_flConstraintSpeedFactor()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flConstraintSpeedFactor")
  end
  
  --- @return any
  function Player:m_bConstraintPastRadius()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bConstraintPastRadius")
  end
  
  --- @return any
  function Player:m_flDeathTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flDeathTime")
  end
  
  --- @return any
  function Player:m_flNextDecalTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flNextDecalTime")
  end
  
  --- @return any
  function Player:m_fForceTeam()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fForceTeam")
  end
  
  --- @return any
  function Player:m_flLaggedMovementValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flLaggedMovementValue")
  end
  
  --- @return any
  function Player:m_hTonemapController()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hTonemapController")
  end
  
  --- @return any
  function Player:m_flStamina()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flStamina")
  end
  
  --- @return any
  function Player:m_iDirection()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iDirection")
  end
  
  --- @return any
  function Player:m_iShotsFired()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iShotsFired")
  end
  
  --- @return any
  function Player:m_nNumFastDucks()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nNumFastDucks")
  end
  
  --- @return any
  function Player:m_bDuckOverride()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bDuckOverride")
  end
  
  --- @return any
  function Player:m_bPlayerDominated()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bPlayerDominated")
  end
  
  --- @return any
  function Player:m_bPlayerDominatingMe()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bPlayerDominatingMe")
  end
  
  --- @return any
  function Player:m_flVelocityModifier()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flVelocityModifier")
  end
  
  --- @return any
  function Player:m_iWeaponPurchasesThisRound()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iWeaponPurchasesThisRound")
  end
  
  --- @return any
  function Player:m_unActiveQuestId()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unActiveQuestId")
  end
  
  --- @return any
  function Player:m_nQuestProgressReason()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nQuestProgressReason")
  end
  
  --- @return any
  function Player:m_iWeaponPurchasesThisMatch()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iWeaponPurchasesThisMatch")
  end
  
  --- @return any
  function Player:m_EquippedLoadoutItemDefIndices()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_EquippedLoadoutItemDefIndices")
  end
  
  --- @return any
  function Player:m_iAddonBits()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iAddonBits")
  end
  
  --- @return any
  function Player:m_iPrimaryAddon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iPrimaryAddon")
  end
  
  --- @return any
  function Player:m_iSecondaryAddon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iSecondaryAddon")
  end
  
  --- @return any
  function Player:m_iThrowGrenadeCounter()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iThrowGrenadeCounter")
  end
  
  --- @return any
  function Player:m_bWaitForNoAttack()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bWaitForNoAttack")
  end
  
  --- @return any
  function Player:m_bIsRespawningForDMBonus()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsRespawningForDMBonus")
  end
  
  --- @return any
  function Player:m_iPlayerState()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iPlayerState")
  end
  
  --- @return any
  function Player:m_iAccount()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iAccount")
  end
  
  --- @return any
  function Player:m_iStartAccount()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iStartAccount")
  end
  
  --- @return any
  function Player:m_totalHitsOnServer()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_totalHitsOnServer")
  end
  
  --- @return any
  function Player:m_bInBombZone()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bInBombZone")
  end
  
  --- @return any
  function Player:m_bInBuyZone()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bInBuyZone")
  end
  
  --- @return any
  function Player:m_bInNoDefuseArea()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bInNoDefuseArea")
  end
  
  --- @return any
  function Player:m_bKilledByTaser()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bKilledByTaser")
  end
  
  --- @return any
  function Player:m_iMoveState()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMoveState")
  end
  
  --- @return any
  function Player:m_iClass()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iClass")
  end
  
  --- @return any
  function Player:m_ArmorValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_ArmorValue")
  end
  
  --- @return any
  function Player:m_bHasDefuser()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasDefuser")
  end
  
  --- @return any
  function Player:m_bNightVisionOn()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bNightVisionOn")
  end
  
  --- @return any
  function Player:m_bHasNightVision()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasNightVision")
  end
  
  --- @return any
  function Player:m_bInHostageRescueZone()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bInHostageRescueZone")
  end
  
  --- @return any
  function Player:m_bIsDefusing()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsDefusing")
  end
  
  --- @return any
  function Player:m_bIsGrabbingHostage()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsGrabbingHostage")
  end
  
  --- @return any
  function Player:m_iBlockingUseActionInProgress()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iBlockingUseActionInProgress")
  end
  
  --- @return any
  function Player:m_bIsScoped()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsScoped")
  end
  
  --- @return any
  function Player:m_bIsWalking()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsWalking")
  end
  
  --- @return any
  function Player:m_nIsAutoMounting()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nIsAutoMounting")
  end
  
  --- @return any
  function Player:m_bResumeZoom()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bResumeZoom")
  end
  
  --- @return any
  function Player:m_fImmuneToGunGameDamageTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fImmuneToGunGameDamageTime")
  end
  
  --- @return any
  function Player:m_bGunGameImmunity()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bGunGameImmunity")
  end
  
  --- @return any
  function Player:m_bHasMovedSinceSpawn()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasMovedSinceSpawn")
  end
  
  --- @return any
  function Player:m_bMadeFinalGunGameProgressiveKill()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bMadeFinalGunGameProgressiveKill")
  end
  
  --- @return any
  function Player:m_iGunGameProgressiveWeaponIndex()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iGunGameProgressiveWeaponIndex")
  end
  
  --- @return any
  function Player:m_iNumGunGameTRKillPoints()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iNumGunGameTRKillPoints")
  end
  
  --- @return any
  function Player:m_iNumGunGameKillsWithCurrentWeapon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iNumGunGameKillsWithCurrentWeapon")
  end
  
  --- @return any
  function Player:m_iNumRoundKills()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iNumRoundKills")
  end
  
  --- @return any
  function Player:m_fMolotovUseTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fMolotovUseTime")
  end
  
  --- @return any
  function Player:m_fMolotovDamageTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_fMolotovDamageTime")
  end
  
  --- @return any
  function Player:m_szArmsModel()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_szArmsModel")
  end
  
  --- @return any
  function Player:m_hCarriedHostage()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hCarriedHostage")
  end
  
  --- @return any
  function Player:m_hCarriedHostageProp()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hCarriedHostageProp")
  end
  
  --- @return any
  function Player:m_bIsRescuing()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsRescuing")
  end
  
  --- @return any
  function Player:m_flGroundAccelLinearFracLastTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flGroundAccelLinearFracLastTime")
  end
  
  --- @return any
  function Player:m_flGuardianTooFarDistFrac()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flGuardianTooFarDistFrac")
  end
  
  --- @return any
  function Player:m_flDetectedByEnemySensorTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flDetectedByEnemySensorTime")
  end
  
  --- @return any
  function Player:m_bCanMoveDuringFreezePeriod()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bCanMoveDuringFreezePeriod")
  end
  
  --- @return any
  function Player:m_isCurrentGunGameLeader()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_isCurrentGunGameLeader")
  end
  
  --- @return any
  function Player:m_rank()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_rank")
  end
  
  --- @return any
  function Player:m_isCurrentGunGameTeamLeader()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_isCurrentGunGameTeamLeader")
  end
  
  --- @return any
  function Player:m_passiveItems()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_passiveItems")
  end
  
  --- @return any
  function Player:m_unMusicID()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unMusicID")
  end
  
  --- @return any
  function Player:m_bIsPlayerGhost()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsPlayerGhost")
  end
  
  --- @return any
  function Player:m_bHasHelmet()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasHelmet")
  end
  
  --- @return any
  function Player:m_bHasHeavyArmor()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasHeavyArmor")
  end
  
  --- @return any
  function Player:m_nHeavyAssaultSuitCooldownRemaining()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nHeavyAssaultSuitCooldownRemaining")
  end
  
  --- @return any
  function Player:m_flFlashDuration()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFlashDuration")
  end
  
  --- @return any
  function Player:m_flFlashMaxAlpha()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flFlashMaxAlpha")
  end
  
  --- @return any
  function Player:m_iProgressBarDuration()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iProgressBarDuration")
  end
  
  --- @return any
  function Player:m_flProgressBarStartTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flProgressBarStartTime")
  end
  
  --- @return any
  function Player:m_hRagdoll()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hRagdoll")
  end
  
  --- @return any
  function Player:m_hPlayerPing()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hPlayerPing")
  end
  
  --- @return any
  function Player:m_cycleLatch()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_cycleLatch")
  end
  
  --- @return any
  function Player:m_unCurrentEquipmentValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unCurrentEquipmentValue")
  end
  
  --- @return any
  function Player:m_unRoundStartEquipmentValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unRoundStartEquipmentValue")
  end
  
  --- @return any
  function Player:m_unFreezetimeEndEquipmentValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unFreezetimeEndEquipmentValue")
  end
  
  --- @return any
  function Player:m_bIsControllingBot()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsControllingBot")
  end
  
  --- @return any
  function Player:m_bHasControlledBotThisRound()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHasControlledBotThisRound")
  end
  
  --- @return any
  function Player:m_bCanControlObservedBot()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bCanControlObservedBot")
  end
  
  --- @return any
  function Player:m_iControlledBotEntIndex()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iControlledBotEntIndex")
  end
  
  --- @return any
  function Player:m_bHud_MiniScoreHidden()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHud_MiniScoreHidden")
  end
  
  --- @return any
  function Player:m_bHud_RadarHidden()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHud_RadarHidden")
  end
  
  --- @return any
  function Player:m_nLastKillerIndex()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nLastKillerIndex")
  end
  
  --- @return any
  function Player:m_nLastConcurrentKilled()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nLastConcurrentKilled")
  end
  
  --- @return any
  function Player:m_nDeathCamMusic()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nDeathCamMusic")
  end
  
  --- @return any
  function Player:m_bIsLookingAtWeapon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsLookingAtWeapon")
  end
  
  --- @return any
  function Player:m_bIsHoldingLookAtWeapon()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsHoldingLookAtWeapon")
  end
  
  --- @return any
  function Player:m_iNumRoundKillsHeadshots()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iNumRoundKillsHeadshots")
  end
  
  --- @return any
  function Player:m_iMatchStats_Kills()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_Kills")
  end
  
  --- @return any
  function Player:m_iMatchStats_Damage()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_Damage")
  end
  
  --- @return any
  function Player:m_iMatchStats_EquipmentValue()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_EquipmentValue")
  end
  
  --- @return any
  function Player:m_iMatchStats_MoneySaved()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_MoneySaved")
  end
  
  --- @return any
  function Player:m_iMatchStats_KillReward()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_KillReward")
  end
  
  --- @return any
  function Player:m_iMatchStats_LiveTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_LiveTime")
  end
  
  --- @return any
  function Player:m_iMatchStats_Deaths()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_Deaths")
  end
  
  --- @return any
  function Player:m_iMatchStats_Assists()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_Assists")
  end
  
  --- @return any
  function Player:m_iMatchStats_HeadShotKills()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_HeadShotKills")
  end
  
  --- @return any
  function Player:m_iMatchStats_Objective()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_Objective")
  end
  
  --- @return any
  function Player:m_iMatchStats_CashEarned()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_CashEarned")
  end
  
  --- @return any
  function Player:m_iMatchStats_UtilityDamage()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_UtilityDamage")
  end
  
  --- @return any
  function Player:m_unTotalRoundDamageDealt()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_unTotalRoundDamageDealt")
  end
  
  --- @return any
  function Player:m_iMatchStats_EnemiesFlashed()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_iMatchStats_EnemiesFlashed")
  end
  
  --- @return any
  function Player:m_flLowerBodyYawTarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flLowerBodyYawTarget")
  end
  
  --- @return any
  function Player:m_bStrafing()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bStrafing")
  end
  
  --- @return any
  function Player:m_flThirdpersonRecoil()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flThirdpersonRecoil")
  end
  
  --- @return any
  function Player:m_bHideTargetID()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bHideTargetID")
  end
  
  --- @return any
  function Player:m_bIsSpawnRappelling()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_bIsSpawnRappelling")
  end
  
  --- @return Vector3
  function Player:m_vecSpawnRappellingRopeOrigin()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecSpawnRappellingRopeOrigin"))
  end
  
  --- @return any
  function Player:m_nSurvivalTeam()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_nSurvivalTeam")
  end
  
  --- @return any
  function Player:m_hSurvivalAssassinationTarget()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_hSurvivalAssassinationTarget")
  end
  
  --- @return Vector3
  function Player:m_vecAutomoveTargetEnd()
  	return Vector3:new(entity.get_prop(self and self.eid or entity.get_local_player(), "m_vecAutomoveTargetEnd"))
  end
  
  --- @return any
  function Player:m_flAutoMoveStartTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flAutoMoveStartTime")
  end
  
  --- @return any
  function Player:m_flAutoMoveTargetTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flAutoMoveTargetTime")
  end
  
  --- @return any
  function Player:m_flHealthShotBoostExpirationTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flHealthShotBoostExpirationTime")
  end
  
  --- @return any
  function Player:m_flLastExoJumpTime()
  	return entity.get_prop(self and self.eid or entity.get_local_player(), "m_flLastExoJumpTime")
  end
  
  return Nyx.class(
  	"Nyx/Player",
  	Player
  )
  --endregion
end
package.preload["gamesense/Nyx/Player"] = function() return return_values["Player"] end
--endregion

--region Entity
libraries["Entity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  local Angle, _, Vector3 = VectorsAngles.Angle, VectorsAngles.Vector2, VectorsAngles.Vector3
  
  --region Entity
  --- @class Entity : Class
  --- @field eid number
  --- @field classname string
  local Entity = {}
  
  --- @param fields Entity
  --- @return Entity
  function Entity:new(fields)
  	return Nyx.new(self, fields)
  end
  
  --- @param classnames string|string[]
  --- @return Entity
  function Entity.findOne(classnames)
  	if type(classnames) == "string" then
  		for _, eid in pairs(entity.get_all(classnames)) do
  			return Entity:new({
  				eid = eid,
  				classname = classnames
  			})
  		end
  	elseif type(classnames) == "table" then
  		for _, classname in pairs(classnames) do
  			for _, eid in pairs(entity.get_all(classname)) do
  				return Entity:new({
  					eid = eid,
  					classname = classnames
  				})
  			end
  		end
  	end
  
  	return nil
  end
  
  --- @param classnames string|string[]
  --- @return Entity[]|Entity
  function Entity.find(classnames)
  	local result = {}
  	local i = 1
  
  	if type(classnames) == "string" then
  		for _, eid in pairs(entity.get_all(classnames)) do
  			result[i] = Entity:new({
  				eid = eid,
  				classname = classnames
  			})
  
  			i = i + 1
  		end
  	elseif type(classnames) == "table" then
  		for _, classname in pairs(classnames) do
  			for _, eid in pairs(entity.get_all(classname)) do
  				result[i] = Entity:new({
  					eid = eid,
  					classname = classname
  				})
  
  				i = i + 1
  			end
  		end
  	end
  
  	return result
  end
  
  --- @return Vector3
  function Entity:getOrigin()
  	return Vector3:new(entity.get_origin(self.eid))
  end
  
  --- @return any
  function Entity:m_flAnimTime()
  	return entity.get_prop(self.eid, "m_flAnimTime")
  end
  
  --- @return any
  function Entity:m_flSimulationTime()
  	return entity.get_prop(self.eid, "m_flSimulationTime")
  end
  
  --- @return any
  function Entity:m_cellbits()
  	return entity.get_prop(self.eid, "m_cellbits")
  end
  
  --- @return any
  function Entity:m_cellX()
  	return entity.get_prop(self.eid, "m_cellX")
  end
  
  --- @return any
  function Entity:m_cellY()
  	return entity.get_prop(self.eid, "m_cellY")
  end
  
  --- @return any
  function Entity:m_cellZ()
  	return entity.get_prop(self.eid, "m_cellZ")
  end
  
  --- @return Vector3
  function Entity:m_vecOrigin()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecOrigin"))
  end
  
  --- @return any
  function Entity:m_nModelIndex()
  	return entity.get_prop(self.eid, "m_nModelIndex")
  end
  
  --- @return Vector3
  function Entity:m_vecMins()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecMins"))
  end
  
  --- @return Vector3
  function Entity:m_vecMaxs()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecMaxs"))
  end
  
  --- @return any
  function Entity:m_nSolidType()
  	return entity.get_prop(self.eid, "m_nSolidType")
  end
  
  --- @return any
  function Entity:m_usSolidFlags()
  	return entity.get_prop(self.eid, "m_usSolidFlags")
  end
  
  --- @return any
  function Entity:m_nSurroundType()
  	return entity.get_prop(self.eid, "m_nSurroundType")
  end
  
  --- @return any
  function Entity:m_triggerBloat()
  	return entity.get_prop(self.eid, "m_triggerBloat")
  end
  
  --- @return Vector3
  function Entity:m_vecSpecifiedSurroundingMins()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecSpecifiedSurroundingMins"))
  end
  
  --- @return Vector3
  function Entity:m_vecSpecifiedSurroundingMaxs()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecSpecifiedSurroundingMaxs"))
  end
  
  --- @return any
  function Entity:m_nRenderFX()
  	return entity.get_prop(self.eid, "m_nRenderFX")
  end
  
  --- @return any
  function Entity:m_nRenderMode()
  	return entity.get_prop(self.eid, "m_nRenderMode")
  end
  
  --- @return any
  function Entity:m_fEffects()
  	return entity.get_prop(self.eid, "m_fEffects")
  end
  
  --- @return any
  function Entity:m_clrRender()
  	return entity.get_prop(self.eid, "m_clrRender")
  end
  
  --- @return any
  function Entity:m_iTeamNum()
  	return entity.get_prop(self.eid, "m_iTeamNum")
  end
  
  --- @return any
  function Entity:m_iPendingTeamNum()
  	return entity.get_prop(self.eid, "m_iPendingTeamNum")
  end
  
  --- @return any
  function Entity:m_CollisionGroup()
  	return entity.get_prop(self.eid, "m_CollisionGroup")
  end
  
  --- @return any
  function Entity:m_flElasticity()
  	return entity.get_prop(self.eid, "m_flElasticity")
  end
  
  --- @return any
  function Entity:m_flShadowCastDistance()
  	return entity.get_prop(self.eid, "m_flShadowCastDistance")
  end
  
  --- @return any
  function Entity:m_hOwnerEntity()
  	return entity.get_prop(self.eid, "m_hOwnerEntity")
  end
  
  --- @return any
  function Entity:m_hEffectEntity()
  	return entity.get_prop(self.eid, "m_hEffectEntity")
  end
  
  --- @return any
  function Entity:m_iParentAttachment()
  	return entity.get_prop(self.eid, "m_iParentAttachment")
  end
  
  --- @return any
  function Entity:m_iName()
  	return entity.get_prop(self.eid, "m_iName")
  end
  
  --- @return Angle
  function Entity:m_angRotation()
  	return Angle:new(entity.get_prop(self.eid, "m_angRotation"))
  end
  
  --- @return any
  function Entity:m_iTextureFrameIndex()
  	return entity.get_prop(self.eid, "m_iTextureFrameIndex")
  end
  
  --- @return any
  function Entity:m_bSimulatedEveryTick()
  	return entity.get_prop(self.eid, "m_bSimulatedEveryTick")
  end
  
  --- @return any
  function Entity:m_bAnimatedEveryTick()
  	return entity.get_prop(self.eid, "m_bAnimatedEveryTick")
  end
  
  --- @return any
  function Entity:m_bAlternateSorting()
  	return entity.get_prop(self.eid, "m_bAlternateSorting")
  end
  
  --- @return any
  function Entity:m_bSpotted()
  	return entity.get_prop(self.eid, "m_bSpotted")
  end
  
  --- @return any
  function Entity:m_bIsAutoaimTarget()
  	return entity.get_prop(self.eid, "m_bIsAutoaimTarget")
  end
  
  --- @return any
  function Entity:m_fadeMinDist()
  	return entity.get_prop(self.eid, "m_fadeMinDist")
  end
  
  --- @return any
  function Entity:m_fadeMaxDist()
  	return entity.get_prop(self.eid, "m_fadeMaxDist")
  end
  
  --- @return any
  function Entity:m_flFadeScale()
  	return entity.get_prop(self.eid, "m_flFadeScale")
  end
  
  --- @return any
  function Entity:m_nMinCPULevel()
  	return entity.get_prop(self.eid, "m_nMinCPULevel")
  end
  
  --- @return any
  function Entity:m_nMaxCPULevel()
  	return entity.get_prop(self.eid, "m_nMaxCPULevel")
  end
  
  --- @return any
  function Entity:m_nMinGPULevel()
  	return entity.get_prop(self.eid, "m_nMinGPULevel")
  end
  
  --- @return any
  function Entity:m_nMaxGPULevel()
  	return entity.get_prop(self.eid, "m_nMaxGPULevel")
  end
  
  --- @return any
  function Entity:m_flUseLookAtAngle()
  	return entity.get_prop(self.eid, "m_flUseLookAtAngle")
  end
  
  --- @return any
  function Entity:m_flLastMadeNoiseTime()
  	return entity.get_prop(self.eid, "m_flLastMadeNoiseTime")
  end
  
  --- @return any
  function Entity:m_flMaxFallVelocity()
  	return entity.get_prop(self.eid, "m_flMaxFallVelocity")
  end
  
  --- @return any
  function Entity:m_bEligibleForScreenHighlight()
  	return entity.get_prop(self.eid, "m_bEligibleForScreenHighlight")
  end
  
  --- @return any
  function Entity:m_nForceBone()
  	return entity.get_prop(self.eid, "m_nForceBone")
  end
  
  --- @return Vector3
  function Entity:m_vecForce()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecForce"))
  end
  
  --- @return any
  function Entity:m_nSkin()
  	return entity.get_prop(self.eid, "m_nSkin")
  end
  
  --- @return any
  function Entity:m_nBody()
  	return entity.get_prop(self.eid, "m_nBody")
  end
  
  --- @return any
  function Entity:m_nHitboxSet()
  	return entity.get_prop(self.eid, "m_nHitboxSet")
  end
  
  --- @return any
  function Entity:m_flModelScale()
  	return entity.get_prop(self.eid, "m_flModelScale")
  end
  
  --- @return any
  function Entity:m_nSequence()
  	return entity.get_prop(self.eid, "m_nSequence")
  end
  
  --- @return any
  function Entity:m_flPlaybackRate()
  	return entity.get_prop(self.eid, "m_flPlaybackRate")
  end
  
  --- @return any
  function Entity:m_bClientSideAnimation()
  	return entity.get_prop(self.eid, "m_bClientSideAnimation")
  end
  
  --- @return any
  function Entity:m_bClientSideFrameReset()
  	return entity.get_prop(self.eid, "m_bClientSideFrameReset")
  end
  
  --- @return any
  function Entity:m_bClientSideRagdoll()
  	return entity.get_prop(self.eid, "m_bClientSideRagdoll")
  end
  
  --- @return any
  function Entity:m_nNewSequenceParity()
  	return entity.get_prop(self.eid, "m_nNewSequenceParity")
  end
  
  --- @return any
  function Entity:m_nResetEventsParity()
  	return entity.get_prop(self.eid, "m_nResetEventsParity")
  end
  
  --- @return any
  function Entity:m_nMuzzleFlashParity()
  	return entity.get_prop(self.eid, "m_nMuzzleFlashParity")
  end
  
  --- @return any
  function Entity:m_hLightingOrigin()
  	return entity.get_prop(self.eid, "m_hLightingOrigin")
  end
  
  --- @return any
  function Entity:m_flCycle()
  	return entity.get_prop(self.eid, "m_flCycle")
  end
  
  --- @return any
  function Entity:m_flFrozen()
  	return entity.get_prop(self.eid, "m_flFrozen")
  end
  
  --- @return any
  function Entity:m_ScaleType()
  	return entity.get_prop(self.eid, "m_ScaleType")
  end
  
  --- @return any
  function Entity:m_bSuppressAnimSounds()
  	return entity.get_prop(self.eid, "m_bSuppressAnimSounds")
  end
  
  --- @return any
  function Entity:m_nHighlightColorR()
  	return entity.get_prop(self.eid, "m_nHighlightColorR")
  end
  
  --- @return any
  function Entity:m_nHighlightColorG()
  	return entity.get_prop(self.eid, "m_nHighlightColorG")
  end
  
  --- @return any
  function Entity:m_nHighlightColorB()
  	return entity.get_prop(self.eid, "m_nHighlightColorB")
  end
  
  --- @return any
  function Entity:m_flPrevCycle()
  	return entity.get_prop(self.eid, "m_flPrevCycle")
  end
  
  --- @return any
  function Entity:m_flWeight()
  	return entity.get_prop(self.eid, "m_flWeight")
  end
  
  --- @return any
  function Entity:m_flWeightDeltaRate()
  	return entity.get_prop(self.eid, "m_flWeightDeltaRate")
  end
  
  --- @return any
  function Entity:m_nOrder()
  	return entity.get_prop(self.eid, "m_nOrder")
  end
  
  --- @return any
  function Entity:m_blinktoggle()
  	return entity.get_prop(self.eid, "m_blinktoggle")
  end
  
  --- @return any
  function Entity:m_viewtarget()
  	return entity.get_prop(self.eid, "m_viewtarget")
  end
  
  --- @return any
  function Entity:m_flNextAttack()
  	return entity.get_prop(self.eid, "m_flNextAttack")
  end
  
  --- @return any
  function Entity:m_LastHitGroup()
  	return entity.get_prop(self.eid, "m_LastHitGroup")
  end
  
  --- @return any
  function Entity:m_hActiveWeapon()
  	return entity.get_prop(self.eid, "m_hActiveWeapon")
  end
  
  --- @return any
  function Entity:m_flTimeOfLastInjury()
  	return entity.get_prop(self.eid, "m_flTimeOfLastInjury")
  end
  
  --- @return any
  function Entity:m_nRelativeDirectionOfLastInjury()
  	return entity.get_prop(self.eid, "m_nRelativeDirectionOfLastInjury")
  end
  
  --- @return any
  function Entity:m_lifeState()
  	return entity.get_prop(self.eid, "m_lifeState")
  end
  
  --- @return any
  function Entity:m_bPerformAvoidance()
  	return entity.get_prop(self.eid, "m_bPerformAvoidance")
  end
  
  --- @return any
  function Entity:m_bIsMoving()
  	return entity.get_prop(self.eid, "m_bIsMoving")
  end
  
  --- @return any
  function Entity:m_bFadeCorpse()
  	return entity.get_prop(self.eid, "m_bFadeCorpse")
  end
  
  --- @return any
  function Entity:m_iDeathPose()
  	return entity.get_prop(self.eid, "m_iDeathPose")
  end
  
  --- @return any
  function Entity:m_iDeathFrame()
  	return entity.get_prop(self.eid, "m_iDeathFrame")
  end
  
  --- @return any
  function Entity:m_bSpeedModActive()
  	return entity.get_prop(self.eid, "m_bSpeedModActive")
  end
  
  --- @return any
  function Entity:m_iSpeedModRadius()
  	return entity.get_prop(self.eid, "m_iSpeedModRadius")
  end
  
  --- @return any
  function Entity:m_iSpeedModSpeed()
  	return entity.get_prop(self.eid, "m_iSpeedModSpeed")
  end
  
  --- @return any
  function Entity:m_bImportanRagdoll()
  	return entity.get_prop(self.eid, "m_bImportanRagdoll")
  end
  
  --- @return any
  function Entity:m_flTimePingEffect()
  	return entity.get_prop(self.eid, "m_flTimePingEffect")
  end
  
  --- @return any
  function Entity:m_hOuter()
  	return entity.get_prop(self.eid, "m_hOuter")
  end
  
  --- @return any
  function Entity:m_ProviderType()
  	return entity.get_prop(self.eid, "m_ProviderType")
  end
  
  --- @return any
  function Entity:m_iReapplyProvisionParity()
  	return entity.get_prop(self.eid, "m_iReapplyProvisionParity")
  end
  
  --- @return any
  function Entity:m_iItemDefinitionIndex()
  	return entity.get_prop(self.eid, "m_iItemDefinitionIndex")
  end
  
  --- @return any
  function Entity:m_iEntityLevel()
  	return entity.get_prop(self.eid, "m_iEntityLevel")
  end
  
  --- @return any
  function Entity:m_iItemIDHigh()
  	return entity.get_prop(self.eid, "m_iItemIDHigh")
  end
  
  --- @return any
  function Entity:m_iItemIDLow()
  	return entity.get_prop(self.eid, "m_iItemIDLow")
  end
  
  --- @return any
  function Entity:m_iAccountID()
  	return entity.get_prop(self.eid, "m_iAccountID")
  end
  
  --- @return any
  function Entity:m_iEntityQuality()
  	return entity.get_prop(self.eid, "m_iEntityQuality")
  end
  
  --- @return any
  function Entity:m_bInitialized()
  	return entity.get_prop(self.eid, "m_bInitialized")
  end
  
  --- @return any
  function Entity:m_szCustomName()
  	return entity.get_prop(self.eid, "m_szCustomName")
  end
  
  --- @return any
  function Entity:m_iAttributeDefinitionIndex()
  	return entity.get_prop(self.eid, "m_iAttributeDefinitionIndex")
  end
  
  --- @return any
  function Entity:m_iRawValue32()
  	return entity.get_prop(self.eid, "m_iRawValue32")
  end
  
  --- @return any
  function Entity:m_iRawInitialValue32()
  	return entity.get_prop(self.eid, "m_iRawInitialValue32")
  end
  
  --- @return any
  function Entity:m_nRefundableCurrency()
  	return entity.get_prop(self.eid, "m_nRefundableCurrency")
  end
  
  --- @return any
  function Entity:m_bSetBonus()
  	return entity.get_prop(self.eid, "m_bSetBonus")
  end
  
  --- @return any
  function Entity:m_OriginalOwnerXuidLow()
  	return entity.get_prop(self.eid, "m_OriginalOwnerXuidLow")
  end
  
  --- @return any
  function Entity:m_OriginalOwnerXuidHigh()
  	return entity.get_prop(self.eid, "m_OriginalOwnerXuidHigh")
  end
  
  --- @return any
  function Entity:m_nFallbackPaintKit()
  	return entity.get_prop(self.eid, "m_nFallbackPaintKit")
  end
  
  --- @return any
  function Entity:m_nFallbackSeed()
  	return entity.get_prop(self.eid, "m_nFallbackSeed")
  end
  
  --- @return any
  function Entity:m_flFallbackWear()
  	return entity.get_prop(self.eid, "m_flFallbackWear")
  end
  
  --- @return any
  function Entity:m_nFallbackStatTrak()
  	return entity.get_prop(self.eid, "m_nFallbackStatTrak")
  end
  
  --- @return any
  function Entity:m_iPrimaryAmmoType()
  	return entity.get_prop(self.eid, "m_iPrimaryAmmoType")
  end
  
  --- @return any
  function Entity:m_iSecondaryAmmoType()
  	return entity.get_prop(self.eid, "m_iSecondaryAmmoType")
  end
  
  --- @return any
  function Entity:m_nViewModelIndex()
  	return entity.get_prop(self.eid, "m_nViewModelIndex")
  end
  
  --- @return any
  function Entity:m_bFlipViewModel()
  	return entity.get_prop(self.eid, "m_bFlipViewModel")
  end
  
  --- @return any
  function Entity:m_iWeaponOrigin()
  	return entity.get_prop(self.eid, "m_iWeaponOrigin")
  end
  
  --- @return any
  function Entity:m_iWeaponModule()
  	return entity.get_prop(self.eid, "m_iWeaponModule")
  end
  
  --- @return any
  function Entity:m_flNextPrimaryAttack()
  	return entity.get_prop(self.eid, "m_flNextPrimaryAttack")
  end
  
  --- @return any
  function Entity:m_flNextSecondaryAttack()
  	return entity.get_prop(self.eid, "m_flNextSecondaryAttack")
  end
  
  --- @return any
  function Entity:m_nNextThinkTick()
  	return entity.get_prop(self.eid, "m_nNextThinkTick")
  end
  
  --- @return any
  function Entity:m_flTimeWeaponIdle()
  	return entity.get_prop(self.eid, "m_flTimeWeaponIdle")
  end
  
  --- @return any
  function Entity:m_iViewModelIndex()
  	return entity.get_prop(self.eid, "m_iViewModelIndex")
  end
  
  --- @return any
  function Entity:m_iWorldModelIndex()
  	return entity.get_prop(self.eid, "m_iWorldModelIndex")
  end
  
  --- @return any
  function Entity:m_iWorldDroppedModelIndex()
  	return entity.get_prop(self.eid, "m_iWorldDroppedModelIndex")
  end
  
  --- @return any
  function Entity:m_iState()
  	return entity.get_prop(self.eid, "m_iState")
  end
  
  --- @return any
  function Entity:m_hOwner()
  	return entity.get_prop(self.eid, "m_hOwner")
  end
  
  --- @return any
  function Entity:m_iClip1()
  	return entity.get_prop(self.eid, "m_iClip1")
  end
  
  --- @return any
  function Entity:m_iClip2()
  	return entity.get_prop(self.eid, "m_iClip2")
  end
  
  --- @return any
  function Entity:m_iPrimaryReserveAmmoCount()
  	return entity.get_prop(self.eid, "m_iPrimaryReserveAmmoCount")
  end
  
  --- @return any
  function Entity:m_iSecondaryReserveAmmoCount()
  	return entity.get_prop(self.eid, "m_iSecondaryReserveAmmoCount")
  end
  
  --- @return any
  function Entity:m_hWeaponWorldModel()
  	return entity.get_prop(self.eid, "m_hWeaponWorldModel")
  end
  
  --- @return any
  function Entity:m_iNumEmptyAttacks()
  	return entity.get_prop(self.eid, "m_iNumEmptyAttacks")
  end
  
  --- @return any
  function Entity:m_weaponMode()
  	return entity.get_prop(self.eid, "m_weaponMode")
  end
  
  --- @return any
  function Entity:m_fAccuracyPenalty()
  	return entity.get_prop(self.eid, "m_fAccuracyPenalty")
  end
  
  --- @return any
  function Entity:m_fLastShotTime()
  	return entity.get_prop(self.eid, "m_fLastShotTime")
  end
  
  --- @return any
  function Entity:m_flRecoilIndex()
  	return entity.get_prop(self.eid, "m_flRecoilIndex")
  end
  
  --- @return any
  function Entity:m_hPrevOwner()
  	return entity.get_prop(self.eid, "m_hPrevOwner")
  end
  
  --- @return any
  function Entity:m_bBurstMode()
  	return entity.get_prop(self.eid, "m_bBurstMode")
  end
  
  --- @return any
  function Entity:m_flPostponeFireReadyTime()
  	return entity.get_prop(self.eid, "m_flPostponeFireReadyTime")
  end
  
  --- @return any
  function Entity:m_bReloadVisuallyComplete()
  	return entity.get_prop(self.eid, "m_bReloadVisuallyComplete")
  end
  
  --- @return any
  function Entity:m_bSilencerOn()
  	return entity.get_prop(self.eid, "m_bSilencerOn")
  end
  
  --- @return any
  function Entity:m_flDoneSwitchingSilencer()
  	return entity.get_prop(self.eid, "m_flDoneSwitchingSilencer")
  end
  
  --- @return any
  function Entity:m_iOriginalTeamNumber()
  	return entity.get_prop(self.eid, "m_iOriginalTeamNumber")
  end
  
  --- @return any
  function Entity:m_iIronSightMode()
  	return entity.get_prop(self.eid, "m_iIronSightMode")
  end
  
  --- @return any
  function Entity:m_zoomLevel()
  	return entity.get_prop(self.eid, "m_zoomLevel")
  end
  
  --- @return any
  function Entity:m_iBurstShotsRemaining()
  	return entity.get_prop(self.eid, "m_iBurstShotsRemaining")
  end
  
  --- @return Vector3
  function Entity:m_vecFinalDest()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecFinalDest"))
  end
  
  --- @return any
  function Entity:m_movementType()
  	return entity.get_prop(self.eid, "m_movementType")
  end
  
  --- @return any
  function Entity:m_flMoveTargetTime()
  	return entity.get_prop(self.eid, "m_flMoveTargetTime")
  end
  
  --- @return any
  function Entity:m_bRedraw()
  	return entity.get_prop(self.eid, "m_bRedraw")
  end
  
  --- @return any
  function Entity:m_bIsHeldByPlayer()
  	return entity.get_prop(self.eid, "m_bIsHeldByPlayer")
  end
  
  --- @return any
  function Entity:m_bPinPulled()
  	return entity.get_prop(self.eid, "m_bPinPulled")
  end
  
  --- @return any
  function Entity:m_fThrowTime()
  	return entity.get_prop(self.eid, "m_fThrowTime")
  end
  
  --- @return any
  function Entity:m_bLoopingSoundPlaying()
  	return entity.get_prop(self.eid, "m_bLoopingSoundPlaying")
  end
  
  --- @return any
  function Entity:m_flThrowStrength()
  	return entity.get_prop(self.eid, "m_flThrowStrength")
  end
  
  --- @return any
  function Entity:m_flDamage()
  	return entity.get_prop(self.eid, "m_flDamage")
  end
  
  --- @return any
  function Entity:m_DmgRadius()
  	return entity.get_prop(self.eid, "m_DmgRadius")
  end
  
  --- @return any
  function Entity:m_bIsLive()
  	return entity.get_prop(self.eid, "m_bIsLive")
  end
  
  --- @return any
  function Entity:m_hThrower()
  	return entity.get_prop(self.eid, "m_hThrower")
  end
  
  --- @return Vector3
  function Entity:m_vecVelocity()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecVelocity"))
  end
  
  --- @return any
  function Entity:m_fFlags()
  	return entity.get_prop(self.eid, "m_fFlags")
  end
  
  --- @return any
  function Entity:m_vInitialVelocity()
  	return entity.get_prop(self.eid, "m_vInitialVelocity")
  end
  
  --- @return any
  function Entity:m_nBounces()
  	return entity.get_prop(self.eid, "m_nBounces")
  end
  
  --- @return any
  function Entity:m_nExplodeEffectIndex()
  	return entity.get_prop(self.eid, "m_nExplodeEffectIndex")
  end
  
  --- @return any
  function Entity:m_nExplodeEffectTickBegin()
  	return entity.get_prop(self.eid, "m_nExplodeEffectTickBegin")
  end
  
  --- @return Vector3
  function Entity:m_vecExplodeEffectOrigin()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecExplodeEffectOrigin"))
  end
  
  --- @return any
  function Entity:m_flWaveHeight()
  	return entity.get_prop(self.eid, "m_flWaveHeight")
  end
  
  --- @return any
  function Entity:m_afPhysicsFlags()
  	return entity.get_prop(self.eid, "m_afPhysicsFlags")
  end
  
  --- @return any
  function Entity:m_hVehicle()
  	return entity.get_prop(self.eid, "m_hVehicle")
  end
  
  --- @return any
  function Entity:m_hUseEntity()
  	return entity.get_prop(self.eid, "m_hUseEntity")
  end
  
  --- @return any
  function Entity:m_hGroundEntity()
  	return entity.get_prop(self.eid, "m_hGroundEntity")
  end
  
  --- @return any
  function Entity:m_iHealth()
  	return entity.get_prop(self.eid, "m_iHealth")
  end
  
  --- @return any
  function Entity:m_iBonusProgress()
  	return entity.get_prop(self.eid, "m_iBonusProgress")
  end
  
  --- @return any
  function Entity:m_iBonusChallenge()
  	return entity.get_prop(self.eid, "m_iBonusChallenge")
  end
  
  --- @return any
  function Entity:m_flMaxspeed()
  	return entity.get_prop(self.eid, "m_flMaxspeed")
  end
  
  --- @return any
  function Entity:m_iObserverMode()
  	return entity.get_prop(self.eid, "m_iObserverMode")
  end
  
  --- @return any
  function Entity:m_bActiveCameraMan()
  	return entity.get_prop(self.eid, "m_bActiveCameraMan")
  end
  
  --- @return any
  function Entity:m_bCameraManXRay()
  	return entity.get_prop(self.eid, "m_bCameraManXRay")
  end
  
  --- @return any
  function Entity:m_bCameraManOverview()
  	return entity.get_prop(self.eid, "m_bCameraManOverview")
  end
  
  --- @return any
  function Entity:m_bCameraManScoreBoard()
  	return entity.get_prop(self.eid, "m_bCameraManScoreBoard")
  end
  
  --- @return any
  function Entity:m_uCameraManGraphs()
  	return entity.get_prop(self.eid, "m_uCameraManGraphs")
  end
  
  --- @return any
  function Entity:m_iCoachingTeam()
  	return entity.get_prop(self.eid, "m_iCoachingTeam")
  end
  
  --- @return any
  function Entity:m_hObserverTarget()
  	return entity.get_prop(self.eid, "m_hObserverTarget")
  end
  
  --- @return any
  function Entity:m_iFOV()
  	return entity.get_prop(self.eid, "m_iFOV")
  end
  
  --- @return any
  function Entity:m_iFOVStart()
  	return entity.get_prop(self.eid, "m_iFOVStart")
  end
  
  --- @return any
  function Entity:m_flFOVTime()
  	return entity.get_prop(self.eid, "m_flFOVTime")
  end
  
  --- @return any
  function Entity:m_iDefaultFOV()
  	return entity.get_prop(self.eid, "m_iDefaultFOV")
  end
  
  --- @return any
  function Entity:m_hZoomOwner()
  	return entity.get_prop(self.eid, "m_hZoomOwner")
  end
  
  --- @return any
  function Entity:m_hViewModel()
  	return entity.get_prop(self.eid, "m_hViewModel")
  end
  
  --- @return any
  function Entity:m_szLastPlaceName()
  	return entity.get_prop(self.eid, "m_szLastPlaceName")
  end
  
  --- @return Vector3
  function Entity:m_vecLadderNormal()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecLadderNormal"))
  end
  
  --- @return any
  function Entity:m_ladderSurfaceProps()
  	return entity.get_prop(self.eid, "m_ladderSurfaceProps")
  end
  
  --- @return any
  function Entity:m_ubEFNoInterpParity()
  	return entity.get_prop(self.eid, "m_ubEFNoInterpParity")
  end
  
  --- @return any
  function Entity:m_iDeathPostEffect()
  	return entity.get_prop(self.eid, "m_iDeathPostEffect")
  end
  
  --- @return any
  function Entity:m_hPostProcessCtrl()
  	return entity.get_prop(self.eid, "m_hPostProcessCtrl")
  end
  
  --- @return any
  function Entity:m_hColorCorrectionCtrl()
  	return entity.get_prop(self.eid, "m_hColorCorrectionCtrl")
  end
  
  --- @return any
  function Entity:m_vphysicsCollisionState()
  	return entity.get_prop(self.eid, "m_vphysicsCollisionState")
  end
  
  --- @return any
  function Entity:m_hViewEntity()
  	return entity.get_prop(self.eid, "m_hViewEntity")
  end
  
  --- @return any
  function Entity:m_bShouldDrawPlayerWhileUsingViewEntity()
  	return entity.get_prop(self.eid, "m_bShouldDrawPlayerWhileUsingViewEntity")
  end
  
  --- @return any
  function Entity:m_flDuckAmount()
  	return entity.get_prop(self.eid, "m_flDuckAmount")
  end
  
  --- @return any
  function Entity:m_flDuckSpeed()
  	return entity.get_prop(self.eid, "m_flDuckSpeed")
  end
  
  --- @return any
  function Entity:m_nWaterLevel()
  	return entity.get_prop(self.eid, "m_nWaterLevel")
  end
  
  --- @return any
  function Entity:m_iHideHUD()
  	return entity.get_prop(self.eid, "m_iHideHUD")
  end
  
  --- @return any
  function Entity:m_flFOVRate()
  	return entity.get_prop(self.eid, "m_flFOVRate")
  end
  
  --- @return any
  function Entity:m_bDucked()
  	return entity.get_prop(self.eid, "m_bDucked")
  end
  
  --- @return any
  function Entity:m_bDucking()
  	return entity.get_prop(self.eid, "m_bDucking")
  end
  
  --- @return any
  function Entity:m_flLastDuckTime()
  	return entity.get_prop(self.eid, "m_flLastDuckTime")
  end
  
  --- @return any
  function Entity:m_bInDuckJump()
  	return entity.get_prop(self.eid, "m_bInDuckJump")
  end
  
  --- @return any
  function Entity:m_nDuckTimeMsecs()
  	return entity.get_prop(self.eid, "m_nDuckTimeMsecs")
  end
  
  --- @return any
  function Entity:m_nDuckJumpTimeMsecs()
  	return entity.get_prop(self.eid, "m_nDuckJumpTimeMsecs")
  end
  
  --- @return any
  function Entity:m_nJumpTimeMsecs()
  	return entity.get_prop(self.eid, "m_nJumpTimeMsecs")
  end
  
  --- @return any
  function Entity:m_flFallVelocity()
  	return entity.get_prop(self.eid, "m_flFallVelocity")
  end
  
  --- @return any
  function Entity:m_viewPunchAngle()
  	return entity.get_prop(self.eid, "m_viewPunchAngle")
  end
  
  --- @return any
  function Entity:m_aimPunchAngle()
  	return entity.get_prop(self.eid, "m_aimPunchAngle")
  end
  
  --- @return any
  function Entity:m_aimPunchAngleVel()
  	return entity.get_prop(self.eid, "m_aimPunchAngleVel")
  end
  
  --- @return any
  function Entity:m_bDrawViewmodel()
  	return entity.get_prop(self.eid, "m_bDrawViewmodel")
  end
  
  --- @return any
  function Entity:m_bWearingSuit()
  	return entity.get_prop(self.eid, "m_bWearingSuit")
  end
  
  --- @return any
  function Entity:m_bPoisoned()
  	return entity.get_prop(self.eid, "m_bPoisoned")
  end
  
  --- @return any
  function Entity:m_flStepSize()
  	return entity.get_prop(self.eid, "m_flStepSize")
  end
  
  --- @return any
  function Entity:m_bAllowAutoMovement()
  	return entity.get_prop(self.eid, "m_bAllowAutoMovement")
  end
  
  --- @return any
  function Entity:m_flFriction()
  	return entity.get_prop(self.eid, "m_flFriction")
  end
  
  --- @return any
  function Entity:m_fOnTarget()
  	return entity.get_prop(self.eid, "m_fOnTarget")
  end
  
  --- @return any
  function Entity:m_nTickBase()
  	return entity.get_prop(self.eid, "m_nTickBase")
  end
  
  --- @return any
  function Entity:m_hLastWeapon()
  	return entity.get_prop(self.eid, "m_hLastWeapon")
  end
  
  --- @return Vector3
  function Entity:m_vecBaseVelocity()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecBaseVelocity"))
  end
  
  --- @return any
  function Entity:m_hConstraintEntity()
  	return entity.get_prop(self.eid, "m_hConstraintEntity")
  end
  
  --- @return Vector3
  function Entity:m_vecConstraintCenter()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecConstraintCenter"))
  end
  
  --- @return any
  function Entity:m_flConstraintRadius()
  	return entity.get_prop(self.eid, "m_flConstraintRadius")
  end
  
  --- @return any
  function Entity:m_flConstraintWidth()
  	return entity.get_prop(self.eid, "m_flConstraintWidth")
  end
  
  --- @return any
  function Entity:m_flConstraintSpeedFactor()
  	return entity.get_prop(self.eid, "m_flConstraintSpeedFactor")
  end
  
  --- @return any
  function Entity:m_bConstraintPastRadius()
  	return entity.get_prop(self.eid, "m_bConstraintPastRadius")
  end
  
  --- @return any
  function Entity:m_flDeathTime()
  	return entity.get_prop(self.eid, "m_flDeathTime")
  end
  
  --- @return any
  function Entity:m_flNextDecalTime()
  	return entity.get_prop(self.eid, "m_flNextDecalTime")
  end
  
  --- @return any
  function Entity:m_fForceTeam()
  	return entity.get_prop(self.eid, "m_fForceTeam")
  end
  
  --- @return any
  function Entity:m_flLaggedMovementValue()
  	return entity.get_prop(self.eid, "m_flLaggedMovementValue")
  end
  
  --- @return any
  function Entity:m_hTonemapController()
  	return entity.get_prop(self.eid, "m_hTonemapController")
  end
  
  --- @return any
  function Entity:m_qPreferredPlayerCarryAngles()
  	return entity.get_prop(self.eid, "m_qPreferredPlayerCarryAngles")
  end
  
  --- @return any
  function Entity:m_bClientPhysics()
  	return entity.get_prop(self.eid, "m_bClientPhysics")
  end
  
  --- @return any
  function Entity:m_bUseHitboxesForRenderBox()
  	return entity.get_prop(self.eid, "m_bUseHitboxesForRenderBox")
  end
  
  --- @return any
  function Entity:m_flGlowMaxDist()
  	return entity.get_prop(self.eid, "m_flGlowMaxDist")
  end
  
  --- @return any
  function Entity:m_bShouldGlow()
  	return entity.get_prop(self.eid, "m_bShouldGlow")
  end
  
  --- @return any
  function Entity:m_clrGlow()
  	return entity.get_prop(self.eid, "m_clrGlow")
  end
  
  --- @return any
  function Entity:m_nGlowStyle()
  	return entity.get_prop(self.eid, "m_nGlowStyle")
  end
  
  --- @return any
  function Entity:m_flPoseParameter()
  	return entity.get_prop(self.eid, "m_flPoseParameter")
  end
  
  --- @return any
  function Entity:m_flexWeight()
  	return entity.get_prop(self.eid, "m_flexWeight")
  end
  
  --- @return any
  function Entity:m_iTimerToShowInHUD()
  	return entity.get_prop(self.eid, "m_iTimerToShowInHUD")
  end
  
  --- @return any
  function Entity:m_iStopWatchTimer()
  	return entity.get_prop(self.eid, "m_iStopWatchTimer")
  end
  
  --- @return any
  function Entity:m_iNumControlPoints()
  	return entity.get_prop(self.eid, "m_iNumControlPoints")
  end
  
  --- @return any
  function Entity:m_bPlayingMiniRounds()
  	return entity.get_prop(self.eid, "m_bPlayingMiniRounds")
  end
  
  --- @return any
  function Entity:m_bControlPointsReset()
  	return entity.get_prop(self.eid, "m_bControlPointsReset")
  end
  
  --- @return any
  function Entity:m_iUpdateCapHudParity()
  	return entity.get_prop(self.eid, "m_iUpdateCapHudParity")
  end
  
  --- @return any
  function Entity:m_vCPPositions()
  	return entity.get_prop(self.eid, "m_vCPPositions")
  end
  
  --- @return any
  function Entity:m_iszWarnSound()
  	return entity.get_prop(self.eid, "m_iszWarnSound")
  end
  
  --- @return any
  function Entity:m_pszCapLayoutInHUD()
  	return entity.get_prop(self.eid, "m_pszCapLayoutInHUD")
  end
  
  --- @return any
  function Entity:m_bClientSidePredicted()
  	return entity.get_prop(self.eid, "m_bClientSidePredicted")
  end
  
  --- @return any
  function Entity:m_spawnflags()
  	return entity.get_prop(self.eid, "m_spawnflags")
  end
  
  --- @return any
  function Entity:m_hWeapon()
  	return entity.get_prop(self.eid, "m_hWeapon")
  end
  
  --- @return any
  function Entity:m_nAnimationParity()
  	return entity.get_prop(self.eid, "m_nAnimationParity")
  end
  
  --- @return any
  function Entity:m_bShouldIgnoreOffsetAndAccuracy()
  	return entity.get_prop(self.eid, "m_bShouldIgnoreOffsetAndAccuracy")
  end
  
  --- @return any
  function Entity:m_hCombatWeaponParent()
  	return entity.get_prop(self.eid, "m_hCombatWeaponParent")
  end
  
  --- @return any
  function Entity:m_nBeamType()
  	return entity.get_prop(self.eid, "m_nBeamType")
  end
  
  --- @return any
  function Entity:m_nBeamFlags()
  	return entity.get_prop(self.eid, "m_nBeamFlags")
  end
  
  --- @return any
  function Entity:m_nNumBeamEnts()
  	return entity.get_prop(self.eid, "m_nNumBeamEnts")
  end
  
  --- @return any
  function Entity:m_nHaloIndex()
  	return entity.get_prop(self.eid, "m_nHaloIndex")
  end
  
  --- @return any
  function Entity:m_fHaloScale()
  	return entity.get_prop(self.eid, "m_fHaloScale")
  end
  
  --- @return any
  function Entity:m_fWidth()
  	return entity.get_prop(self.eid, "m_fWidth")
  end
  
  --- @return any
  function Entity:m_fEndWidth()
  	return entity.get_prop(self.eid, "m_fEndWidth")
  end
  
  --- @return any
  function Entity:m_fFadeLength()
  	return entity.get_prop(self.eid, "m_fFadeLength")
  end
  
  --- @return any
  function Entity:m_fAmplitude()
  	return entity.get_prop(self.eid, "m_fAmplitude")
  end
  
  --- @return any
  function Entity:m_fStartFrame()
  	return entity.get_prop(self.eid, "m_fStartFrame")
  end
  
  --- @return any
  function Entity:m_fSpeed()
  	return entity.get_prop(self.eid, "m_fSpeed")
  end
  
  --- @return any
  function Entity:m_flFrameRate()
  	return entity.get_prop(self.eid, "m_flFrameRate")
  end
  
  --- @return any
  function Entity:m_flHDRColorScale()
  	return entity.get_prop(self.eid, "m_flHDRColorScale")
  end
  
  --- @return any
  function Entity:m_flFrame()
  	return entity.get_prop(self.eid, "m_flFrame")
  end
  
  --- @return any
  function Entity:m_nClipStyle()
  	return entity.get_prop(self.eid, "m_nClipStyle")
  end
  
  --- @return Vector3
  function Entity:m_vecEndPos()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEndPos"))
  end
  
  --- @return any
  function Entity:m_bSpotlightOn()
  	return entity.get_prop(self.eid, "m_bSpotlightOn")
  end
  
  --- @return any
  function Entity:m_bHasDynamicLight()
  	return entity.get_prop(self.eid, "m_bHasDynamicLight")
  end
  
  --- @return any
  function Entity:m_flSpotlightMaxLength()
  	return entity.get_prop(self.eid, "m_flSpotlightMaxLength")
  end
  
  --- @return any
  function Entity:m_flSpotlightGoalWidth()
  	return entity.get_prop(self.eid, "m_flSpotlightGoalWidth")
  end
  
  --- @return any
  function Entity:m_flRotationSpeed()
  	return entity.get_prop(self.eid, "m_flRotationSpeed")
  end
  
  --- @return any
  function Entity:m_nRotationAxis()
  	return entity.get_prop(self.eid, "m_nRotationAxis")
  end
  
  --- @return any
  function Entity:m_modelIndex()
  	return entity.get_prop(self.eid, "m_modelIndex")
  end
  
  --- @return any
  function Entity:m_solidIndex()
  	return entity.get_prop(self.eid, "m_solidIndex")
  end
  
  --- @return any
  function Entity:m_bBrokenOpen()
  	return entity.get_prop(self.eid, "m_bBrokenOpen")
  end
  
  --- @return any
  function Entity:m_flRadius()
  	return entity.get_prop(self.eid, "m_flRadius")
  end
  
  --- @return any
  function Entity:m_bShouldExplode()
  	return entity.get_prop(self.eid, "m_bShouldExplode")
  end
  
  --- @return any
  function Entity:m_weaponThatThrewMe()
  	return entity.get_prop(self.eid, "m_weaponThatThrewMe")
  end
  
  --- @return any
  function Entity:m_nParentBoneIndex()
  	return entity.get_prop(self.eid, "m_nParentBoneIndex")
  end
  
  --- @return Vector3
  function Entity:m_vecParentBonePos()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecParentBonePos"))
  end
  
  --- @return any
  function Entity:m_nNumWide()
  	return entity.get_prop(self.eid, "m_nNumWide")
  end
  
  --- @return any
  function Entity:m_nNumHigh()
  	return entity.get_prop(self.eid, "m_nNumHigh")
  end
  
  --- @return any
  function Entity:m_flPanelWidth()
  	return entity.get_prop(self.eid, "m_flPanelWidth")
  end
  
  --- @return any
  function Entity:m_flPanelHeight()
  	return entity.get_prop(self.eid, "m_flPanelHeight")
  end
  
  --- @return any
  function Entity:m_vNormal()
  	return entity.get_prop(self.eid, "m_vNormal")
  end
  
  --- @return any
  function Entity:m_vCorner()
  	return entity.get_prop(self.eid, "m_vCorner")
  end
  
  --- @return any
  function Entity:m_bIsBroken()
  	return entity.get_prop(self.eid, "m_bIsBroken")
  end
  
  --- @return any
  function Entity:m_nSurfaceType()
  	return entity.get_prop(self.eid, "m_nSurfaceType")
  end
  
  --- @return any
  function Entity:m_bArmed()
  	return entity.get_prop(self.eid, "m_bArmed")
  end
  
  --- @return any
  function Entity:m_bStartedArming()
  	return entity.get_prop(self.eid, "m_bStartedArming")
  end
  
  --- @return any
  function Entity:m_bBombPlacedAnimation()
  	return entity.get_prop(self.eid, "m_bBombPlacedAnimation")
  end
  
  --- @return any
  function Entity:m_fArmedTime()
  	return entity.get_prop(self.eid, "m_fArmedTime")
  end
  
  --- @return any
  function Entity:m_bShowC4LED()
  	return entity.get_prop(self.eid, "m_bShowC4LED")
  end
  
  --- @return any
  function Entity:m_bIsPlantingViaUse()
  	return entity.get_prop(self.eid, "m_bIsPlantingViaUse")
  end
  
  --- @return any
  function Entity:m_shadowDirection()
  	return entity.get_prop(self.eid, "m_shadowDirection")
  end
  
  --- @return any
  function Entity:m_envLightShadowDirection()
  	return entity.get_prop(self.eid, "m_envLightShadowDirection")
  end
  
  --- @return any
  function Entity:m_bEnabled()
  	return entity.get_prop(self.eid, "m_bEnabled")
  end
  
  --- @return any
  function Entity:m_bUseLightEnvAngles()
  	return entity.get_prop(self.eid, "m_bUseLightEnvAngles")
  end
  
  --- @return any
  function Entity:m_LightColor()
  	return entity.get_prop(self.eid, "m_LightColor")
  end
  
  --- @return any
  function Entity:m_LightColorScale()
  	return entity.get_prop(self.eid, "m_LightColorScale")
  end
  
  --- @return any
  function Entity:m_flMaxShadowDist()
  	return entity.get_prop(self.eid, "m_flMaxShadowDist")
  end
  
  --- @return any
  function Entity:m_jumpedThisFrame()
  	return entity.get_prop(self.eid, "m_jumpedThisFrame")
  end
  
  --- @return any
  function Entity:m_leader()
  	return entity.get_prop(self.eid, "m_leader")
  end
  
  --- @return any
  function Entity:m_MinFalloff()
  	return entity.get_prop(self.eid, "m_MinFalloff")
  end
  
  --- @return any
  function Entity:m_MaxFalloff()
  	return entity.get_prop(self.eid, "m_MaxFalloff")
  end
  
  --- @return any
  function Entity:m_flCurWeight()
  	return entity.get_prop(self.eid, "m_flCurWeight")
  end
  
  --- @return any
  function Entity:m_flMaxWeight()
  	return entity.get_prop(self.eid, "m_flMaxWeight")
  end
  
  --- @return any
  function Entity:m_flFadeInDuration()
  	return entity.get_prop(self.eid, "m_flFadeInDuration")
  end
  
  --- @return any
  function Entity:m_flFadeOutDuration()
  	return entity.get_prop(self.eid, "m_flFadeOutDuration")
  end
  
  --- @return any
  function Entity:m_netlookupFilename()
  	return entity.get_prop(self.eid, "m_netlookupFilename")
  end
  
  --- @return any
  function Entity:m_bMaster()
  	return entity.get_prop(self.eid, "m_bMaster")
  end
  
  --- @return any
  function Entity:m_bClientSide()
  	return entity.get_prop(self.eid, "m_bClientSide")
  end
  
  --- @return any
  function Entity:m_bExclusive()
  	return entity.get_prop(self.eid, "m_bExclusive")
  end
  
  --- @return any
  function Entity:m_Weight()
  	return entity.get_prop(self.eid, "m_Weight")
  end
  
  --- @return any
  function Entity:m_lookupFilename()
  	return entity.get_prop(self.eid, "m_lookupFilename")
  end
  
  --- @return any
  function Entity:m_bFreezePeriod()
  	return entity.get_prop(self.eid, "m_bFreezePeriod")
  end
  
  --- @return any
  function Entity:m_bMatchWaitingForResume()
  	return entity.get_prop(self.eid, "m_bMatchWaitingForResume")
  end
  
  --- @return any
  function Entity:m_bWarmupPeriod()
  	return entity.get_prop(self.eid, "m_bWarmupPeriod")
  end
  
  --- @return any
  function Entity:m_fWarmupPeriodEnd()
  	return entity.get_prop(self.eid, "m_fWarmupPeriodEnd")
  end
  
  --- @return any
  function Entity:m_fWarmupPeriodStart()
  	return entity.get_prop(self.eid, "m_fWarmupPeriodStart")
  end
  
  --- @return any
  function Entity:m_bTerroristTimeOutActive()
  	return entity.get_prop(self.eid, "m_bTerroristTimeOutActive")
  end
  
  --- @return any
  function Entity:m_bCTTimeOutActive()
  	return entity.get_prop(self.eid, "m_bCTTimeOutActive")
  end
  
  --- @return any
  function Entity:m_flTerroristTimeOutRemaining()
  	return entity.get_prop(self.eid, "m_flTerroristTimeOutRemaining")
  end
  
  --- @return any
  function Entity:m_flCTTimeOutRemaining()
  	return entity.get_prop(self.eid, "m_flCTTimeOutRemaining")
  end
  
  --- @return any
  function Entity:m_nTerroristTimeOuts()
  	return entity.get_prop(self.eid, "m_nTerroristTimeOuts")
  end
  
  --- @return any
  function Entity:m_nCTTimeOuts()
  	return entity.get_prop(self.eid, "m_nCTTimeOuts")
  end
  
  --- @return any
  function Entity:m_iRoundTime()
  	return entity.get_prop(self.eid, "m_iRoundTime")
  end
  
  --- @return any
  function Entity:m_gamePhase()
  	return entity.get_prop(self.eid, "m_gamePhase")
  end
  
  --- @return any
  function Entity:m_totalRoundsPlayed()
  	return entity.get_prop(self.eid, "m_totalRoundsPlayed")
  end
  
  --- @return any
  function Entity:m_nOvertimePlaying()
  	return entity.get_prop(self.eid, "m_nOvertimePlaying")
  end
  
  --- @return any
  function Entity:m_timeUntilNextPhaseStarts()
  	return entity.get_prop(self.eid, "m_timeUntilNextPhaseStarts")
  end
  
  --- @return any
  function Entity:m_flCMMItemDropRevealStartTime()
  	return entity.get_prop(self.eid, "m_flCMMItemDropRevealStartTime")
  end
  
  --- @return any
  function Entity:m_flCMMItemDropRevealEndTime()
  	return entity.get_prop(self.eid, "m_flCMMItemDropRevealEndTime")
  end
  
  --- @return any
  function Entity:m_fRoundStartTime()
  	return entity.get_prop(self.eid, "m_fRoundStartTime")
  end
  
  --- @return any
  function Entity:m_flRestartRoundTime()
  	return entity.get_prop(self.eid, "m_flRestartRoundTime")
  end
  
  --- @return any
  function Entity:m_bGameRestart()
  	return entity.get_prop(self.eid, "m_bGameRestart")
  end
  
  --- @return any
  function Entity:m_flGameStartTime()
  	return entity.get_prop(self.eid, "m_flGameStartTime")
  end
  
  --- @return any
  function Entity:m_iHostagesRemaining()
  	return entity.get_prop(self.eid, "m_iHostagesRemaining")
  end
  
  --- @return any
  function Entity:m_bAnyHostageReached()
  	return entity.get_prop(self.eid, "m_bAnyHostageReached")
  end
  
  --- @return any
  function Entity:m_bMapHasBombTarget()
  	return entity.get_prop(self.eid, "m_bMapHasBombTarget")
  end
  
  --- @return any
  function Entity:m_bMapHasRescueZone()
  	return entity.get_prop(self.eid, "m_bMapHasRescueZone")
  end
  
  --- @return any
  function Entity:m_bMapHasBuyZone()
  	return entity.get_prop(self.eid, "m_bMapHasBuyZone")
  end
  
  --- @return any
  function Entity:m_bIsQueuedMatchmaking()
  	return entity.get_prop(self.eid, "m_bIsQueuedMatchmaking")
  end
  
  --- @return any
  function Entity:m_bIsValveDS()
  	return entity.get_prop(self.eid, "m_bIsValveDS")
  end
  
  --- @return any
  function Entity:m_bIsQuestEligible()
  	return entity.get_prop(self.eid, "m_bIsQuestEligible")
  end
  
  --- @return any
  function Entity:m_bLogoMap()
  	return entity.get_prop(self.eid, "m_bLogoMap")
  end
  
  --- @return any
  function Entity:m_bPlayAllStepSoundsOnServer()
  	return entity.get_prop(self.eid, "m_bPlayAllStepSoundsOnServer")
  end
  
  --- @return any
  function Entity:m_iNumGunGameProgressiveWeaponsCT()
  	return entity.get_prop(self.eid, "m_iNumGunGameProgressiveWeaponsCT")
  end
  
  --- @return any
  function Entity:m_iNumGunGameProgressiveWeaponsT()
  	return entity.get_prop(self.eid, "m_iNumGunGameProgressiveWeaponsT")
  end
  
  --- @return any
  function Entity:m_iSpectatorSlotCount()
  	return entity.get_prop(self.eid, "m_iSpectatorSlotCount")
  end
  
  --- @return any
  function Entity:m_bBombDropped()
  	return entity.get_prop(self.eid, "m_bBombDropped")
  end
  
  --- @return any
  function Entity:m_bBombPlanted()
  	return entity.get_prop(self.eid, "m_bBombPlanted")
  end
  
  --- @return any
  function Entity:m_iRoundWinStatus()
  	return entity.get_prop(self.eid, "m_iRoundWinStatus")
  end
  
  --- @return any
  function Entity:m_eRoundWinReason()
  	return entity.get_prop(self.eid, "m_eRoundWinReason")
  end
  
  --- @return any
  function Entity:m_flDMBonusStartTime()
  	return entity.get_prop(self.eid, "m_flDMBonusStartTime")
  end
  
  --- @return any
  function Entity:m_flDMBonusTimeLength()
  	return entity.get_prop(self.eid, "m_flDMBonusTimeLength")
  end
  
  --- @return any
  function Entity:m_unDMBonusWeaponLoadoutSlot()
  	return entity.get_prop(self.eid, "m_unDMBonusWeaponLoadoutSlot")
  end
  
  --- @return any
  function Entity:m_bDMBonusActive()
  	return entity.get_prop(self.eid, "m_bDMBonusActive")
  end
  
  --- @return any
  function Entity:m_bTCantBuy()
  	return entity.get_prop(self.eid, "m_bTCantBuy")
  end
  
  --- @return any
  function Entity:m_bCTCantBuy()
  	return entity.get_prop(self.eid, "m_bCTCantBuy")
  end
  
  --- @return any
  function Entity:m_flGuardianBuyUntilTime()
  	return entity.get_prop(self.eid, "m_flGuardianBuyUntilTime")
  end
  
  --- @return any
  function Entity:m_MatchDevice()
  	return entity.get_prop(self.eid, "m_MatchDevice")
  end
  
  --- @return any
  function Entity:m_bHasMatchStarted()
  	return entity.get_prop(self.eid, "m_bHasMatchStarted")
  end
  
  --- @return any
  function Entity:m_nNextMapInMapgroup()
  	return entity.get_prop(self.eid, "m_nNextMapInMapgroup")
  end
  
  --- @return any
  function Entity:m_nEndMatchMapVoteWinner()
  	return entity.get_prop(self.eid, "m_nEndMatchMapVoteWinner")
  end
  
  --- @return any
  function Entity:m_bIsDroppingItems()
  	return entity.get_prop(self.eid, "m_bIsDroppingItems")
  end
  
  --- @return any
  function Entity:m_iActiveAssassinationTargetMissionID()
  	return entity.get_prop(self.eid, "m_iActiveAssassinationTargetMissionID")
  end
  
  --- @return any
  function Entity:m_fMatchStartTime()
  	return entity.get_prop(self.eid, "m_fMatchStartTime")
  end
  
  --- @return any
  function Entity:m_szTournamentEventName()
  	return entity.get_prop(self.eid, "m_szTournamentEventName")
  end
  
  --- @return any
  function Entity:m_szTournamentEventStage()
  	return entity.get_prop(self.eid, "m_szTournamentEventStage")
  end
  
  --- @return any
  function Entity:m_szTournamentPredictionsTxt()
  	return entity.get_prop(self.eid, "m_szTournamentPredictionsTxt")
  end
  
  --- @return any
  function Entity:m_nTournamentPredictionsPct()
  	return entity.get_prop(self.eid, "m_nTournamentPredictionsPct")
  end
  
  --- @return any
  function Entity:m_szMatchStatTxt()
  	return entity.get_prop(self.eid, "m_szMatchStatTxt")
  end
  
  --- @return any
  function Entity:m_nGuardianModeWaveNumber()
  	return entity.get_prop(self.eid, "m_nGuardianModeWaveNumber")
  end
  
  --- @return any
  function Entity:m_nGuardianModeSpecialKillsRemaining()
  	return entity.get_prop(self.eid, "m_nGuardianModeSpecialKillsRemaining")
  end
  
  --- @return any
  function Entity:m_nGuardianModeSpecialWeaponNeeded()
  	return entity.get_prop(self.eid, "m_nGuardianModeSpecialWeaponNeeded")
  end
  
  --- @return any
  function Entity:m_nHalloweenMaskListSeed()
  	return entity.get_prop(self.eid, "m_nHalloweenMaskListSeed")
  end
  
  --- @return any
  function Entity:m_numGlobalGiftsGiven()
  	return entity.get_prop(self.eid, "m_numGlobalGiftsGiven")
  end
  
  --- @return any
  function Entity:m_numGlobalGifters()
  	return entity.get_prop(self.eid, "m_numGlobalGifters")
  end
  
  --- @return any
  function Entity:m_numGlobalGiftsPeriodSeconds()
  	return entity.get_prop(self.eid, "m_numGlobalGiftsPeriodSeconds")
  end
  
  --- @return any
  function Entity:m_numBestOfMaps()
  	return entity.get_prop(self.eid, "m_numBestOfMaps")
  end
  
  --- @return any
  function Entity:m_iNumConsecutiveCTLoses()
  	return entity.get_prop(self.eid, "m_iNumConsecutiveCTLoses")
  end
  
  --- @return any
  function Entity:m_iNumConsecutiveTerroristLoses()
  	return entity.get_prop(self.eid, "m_iNumConsecutiveTerroristLoses")
  end
  
  --- @return Vector3
  function Entity:m_vecPlayAreaMins()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPlayAreaMins"))
  end
  
  --- @return Vector3
  function Entity:m_vecPlayAreaMaxs()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPlayAreaMaxs"))
  end
  
  --- @return any
  function Entity:m_flSpawnSelectionTimeStart()
  	return entity.get_prop(self.eid, "m_flSpawnSelectionTimeStart")
  end
  
  --- @return any
  function Entity:m_flSpawnSelectionTimeEnd()
  	return entity.get_prop(self.eid, "m_flSpawnSelectionTimeEnd")
  end
  
  --- @return any
  function Entity:m_flSpawnSelectionTimeLoadout()
  	return entity.get_prop(self.eid, "m_flSpawnSelectionTimeLoadout")
  end
  
  --- @return any
  function Entity:m_spawnStage()
  	return entity.get_prop(self.eid, "m_spawnStage")
  end
  
  --- @return any
  function Entity:m_flTabletHexOriginX()
  	return entity.get_prop(self.eid, "m_flTabletHexOriginX")
  end
  
  --- @return any
  function Entity:m_flTabletHexOriginY()
  	return entity.get_prop(self.eid, "m_flTabletHexOriginY")
  end
  
  --- @return any
  function Entity:m_flTabletHexSize()
  	return entity.get_prop(self.eid, "m_flTabletHexSize")
  end
  
  --- @return any
  function Entity:m_flSurvivalStartTime()
  	return entity.get_prop(self.eid, "m_flSurvivalStartTime")
  end
  
  --- @return any
  function Entity:m_flStamina()
  	return entity.get_prop(self.eid, "m_flStamina")
  end
  
  --- @return any
  function Entity:m_iDirection()
  	return entity.get_prop(self.eid, "m_iDirection")
  end
  
  --- @return any
  function Entity:m_iShotsFired()
  	return entity.get_prop(self.eid, "m_iShotsFired")
  end
  
  --- @return any
  function Entity:m_nNumFastDucks()
  	return entity.get_prop(self.eid, "m_nNumFastDucks")
  end
  
  --- @return any
  function Entity:m_bDuckOverride()
  	return entity.get_prop(self.eid, "m_bDuckOverride")
  end
  
  --- @return any
  function Entity:m_flVelocityModifier()
  	return entity.get_prop(self.eid, "m_flVelocityModifier")
  end
  
  --- @return any
  function Entity:m_unActiveQuestId()
  	return entity.get_prop(self.eid, "m_unActiveQuestId")
  end
  
  --- @return any
  function Entity:m_nQuestProgressReason()
  	return entity.get_prop(self.eid, "m_nQuestProgressReason")
  end
  
  --- @return any
  function Entity:m_iAddonBits()
  	return entity.get_prop(self.eid, "m_iAddonBits")
  end
  
  --- @return any
  function Entity:m_iPrimaryAddon()
  	return entity.get_prop(self.eid, "m_iPrimaryAddon")
  end
  
  --- @return any
  function Entity:m_iSecondaryAddon()
  	return entity.get_prop(self.eid, "m_iSecondaryAddon")
  end
  
  --- @return any
  function Entity:m_iThrowGrenadeCounter()
  	return entity.get_prop(self.eid, "m_iThrowGrenadeCounter")
  end
  
  --- @return any
  function Entity:m_bWaitForNoAttack()
  	return entity.get_prop(self.eid, "m_bWaitForNoAttack")
  end
  
  --- @return any
  function Entity:m_bIsRespawningForDMBonus()
  	return entity.get_prop(self.eid, "m_bIsRespawningForDMBonus")
  end
  
  --- @return any
  function Entity:m_iPlayerState()
  	return entity.get_prop(self.eid, "m_iPlayerState")
  end
  
  --- @return any
  function Entity:m_iAccount()
  	return entity.get_prop(self.eid, "m_iAccount")
  end
  
  --- @return any
  function Entity:m_iStartAccount()
  	return entity.get_prop(self.eid, "m_iStartAccount")
  end
  
  --- @return any
  function Entity:m_totalHitsOnServer()
  	return entity.get_prop(self.eid, "m_totalHitsOnServer")
  end
  
  --- @return any
  function Entity:m_bInBombZone()
  	return entity.get_prop(self.eid, "m_bInBombZone")
  end
  
  --- @return any
  function Entity:m_bInBuyZone()
  	return entity.get_prop(self.eid, "m_bInBuyZone")
  end
  
  --- @return any
  function Entity:m_bInNoDefuseArea()
  	return entity.get_prop(self.eid, "m_bInNoDefuseArea")
  end
  
  --- @return any
  function Entity:m_bKilledByTaser()
  	return entity.get_prop(self.eid, "m_bKilledByTaser")
  end
  
  --- @return any
  function Entity:m_iMoveState()
  	return entity.get_prop(self.eid, "m_iMoveState")
  end
  
  --- @return any
  function Entity:m_iClass()
  	return entity.get_prop(self.eid, "m_iClass")
  end
  
  --- @return any
  function Entity:m_ArmorValue()
  	return entity.get_prop(self.eid, "m_ArmorValue")
  end
  
  --- @return any
  function Entity:m_bHasDefuser()
  	return entity.get_prop(self.eid, "m_bHasDefuser")
  end
  
  --- @return any
  function Entity:m_bNightVisionOn()
  	return entity.get_prop(self.eid, "m_bNightVisionOn")
  end
  
  --- @return any
  function Entity:m_bHasNightVision()
  	return entity.get_prop(self.eid, "m_bHasNightVision")
  end
  
  --- @return any
  function Entity:m_bInHostageRescueZone()
  	return entity.get_prop(self.eid, "m_bInHostageRescueZone")
  end
  
  --- @return any
  function Entity:m_bIsDefusing()
  	return entity.get_prop(self.eid, "m_bIsDefusing")
  end
  
  --- @return any
  function Entity:m_bIsGrabbingHostage()
  	return entity.get_prop(self.eid, "m_bIsGrabbingHostage")
  end
  
  --- @return any
  function Entity:m_iBlockingUseActionInProgress()
  	return entity.get_prop(self.eid, "m_iBlockingUseActionInProgress")
  end
  
  --- @return any
  function Entity:m_bIsScoped()
  	return entity.get_prop(self.eid, "m_bIsScoped")
  end
  
  --- @return any
  function Entity:m_bIsWalking()
  	return entity.get_prop(self.eid, "m_bIsWalking")
  end
  
  --- @return any
  function Entity:m_nIsAutoMounting()
  	return entity.get_prop(self.eid, "m_nIsAutoMounting")
  end
  
  --- @return any
  function Entity:m_bResumeZoom()
  	return entity.get_prop(self.eid, "m_bResumeZoom")
  end
  
  --- @return any
  function Entity:m_fImmuneToGunGameDamageTime()
  	return entity.get_prop(self.eid, "m_fImmuneToGunGameDamageTime")
  end
  
  --- @return any
  function Entity:m_bGunGameImmunity()
  	return entity.get_prop(self.eid, "m_bGunGameImmunity")
  end
  
  --- @return any
  function Entity:m_bHasMovedSinceSpawn()
  	return entity.get_prop(self.eid, "m_bHasMovedSinceSpawn")
  end
  
  --- @return any
  function Entity:m_bMadeFinalGunGameProgressiveKill()
  	return entity.get_prop(self.eid, "m_bMadeFinalGunGameProgressiveKill")
  end
  
  --- @return any
  function Entity:m_iGunGameProgressiveWeaponIndex()
  	return entity.get_prop(self.eid, "m_iGunGameProgressiveWeaponIndex")
  end
  
  --- @return any
  function Entity:m_iNumGunGameTRKillPoints()
  	return entity.get_prop(self.eid, "m_iNumGunGameTRKillPoints")
  end
  
  --- @return any
  function Entity:m_iNumGunGameKillsWithCurrentWeapon()
  	return entity.get_prop(self.eid, "m_iNumGunGameKillsWithCurrentWeapon")
  end
  
  --- @return any
  function Entity:m_iNumRoundKills()
  	return entity.get_prop(self.eid, "m_iNumRoundKills")
  end
  
  --- @return any
  function Entity:m_fMolotovUseTime()
  	return entity.get_prop(self.eid, "m_fMolotovUseTime")
  end
  
  --- @return any
  function Entity:m_fMolotovDamageTime()
  	return entity.get_prop(self.eid, "m_fMolotovDamageTime")
  end
  
  --- @return any
  function Entity:m_szArmsModel()
  	return entity.get_prop(self.eid, "m_szArmsModel")
  end
  
  --- @return any
  function Entity:m_hCarriedHostage()
  	return entity.get_prop(self.eid, "m_hCarriedHostage")
  end
  
  --- @return any
  function Entity:m_hCarriedHostageProp()
  	return entity.get_prop(self.eid, "m_hCarriedHostageProp")
  end
  
  --- @return any
  function Entity:m_bIsRescuing()
  	return entity.get_prop(self.eid, "m_bIsRescuing")
  end
  
  --- @return any
  function Entity:m_flGroundAccelLinearFracLastTime()
  	return entity.get_prop(self.eid, "m_flGroundAccelLinearFracLastTime")
  end
  
  --- @return any
  function Entity:m_flGuardianTooFarDistFrac()
  	return entity.get_prop(self.eid, "m_flGuardianTooFarDistFrac")
  end
  
  --- @return any
  function Entity:m_flDetectedByEnemySensorTime()
  	return entity.get_prop(self.eid, "m_flDetectedByEnemySensorTime")
  end
  
  --- @return any
  function Entity:m_bCanMoveDuringFreezePeriod()
  	return entity.get_prop(self.eid, "m_bCanMoveDuringFreezePeriod")
  end
  
  --- @return any
  function Entity:m_isCurrentGunGameLeader()
  	return entity.get_prop(self.eid, "m_isCurrentGunGameLeader")
  end
  
  --- @return any
  function Entity:m_isCurrentGunGameTeamLeader()
  	return entity.get_prop(self.eid, "m_isCurrentGunGameTeamLeader")
  end
  
  --- @return any
  function Entity:m_unMusicID()
  	return entity.get_prop(self.eid, "m_unMusicID")
  end
  
  --- @return any
  function Entity:m_bIsPlayerGhost()
  	return entity.get_prop(self.eid, "m_bIsPlayerGhost")
  end
  
  --- @return any
  function Entity:m_bHasHelmet()
  	return entity.get_prop(self.eid, "m_bHasHelmet")
  end
  
  --- @return any
  function Entity:m_bHasHeavyArmor()
  	return entity.get_prop(self.eid, "m_bHasHeavyArmor")
  end
  
  --- @return any
  function Entity:m_nHeavyAssaultSuitCooldownRemaining()
  	return entity.get_prop(self.eid, "m_nHeavyAssaultSuitCooldownRemaining")
  end
  
  --- @return any
  function Entity:m_flFlashDuration()
  	return entity.get_prop(self.eid, "m_flFlashDuration")
  end
  
  --- @return any
  function Entity:m_flFlashMaxAlpha()
  	return entity.get_prop(self.eid, "m_flFlashMaxAlpha")
  end
  
  --- @return any
  function Entity:m_iProgressBarDuration()
  	return entity.get_prop(self.eid, "m_iProgressBarDuration")
  end
  
  --- @return any
  function Entity:m_flProgressBarStartTime()
  	return entity.get_prop(self.eid, "m_flProgressBarStartTime")
  end
  
  --- @return any
  function Entity:m_hRagdoll()
  	return entity.get_prop(self.eid, "m_hRagdoll")
  end
  
  --- @return any
  function Entity:m_hPlayerPing()
  	return entity.get_prop(self.eid, "m_hPlayerPing")
  end
  
  --- @return any
  function Entity:m_cycleLatch()
  	return entity.get_prop(self.eid, "m_cycleLatch")
  end
  
  --- @return any
  function Entity:m_unCurrentEquipmentValue()
  	return entity.get_prop(self.eid, "m_unCurrentEquipmentValue")
  end
  
  --- @return any
  function Entity:m_unRoundStartEquipmentValue()
  	return entity.get_prop(self.eid, "m_unRoundStartEquipmentValue")
  end
  
  --- @return any
  function Entity:m_unFreezetimeEndEquipmentValue()
  	return entity.get_prop(self.eid, "m_unFreezetimeEndEquipmentValue")
  end
  
  --- @return any
  function Entity:m_bIsControllingBot()
  	return entity.get_prop(self.eid, "m_bIsControllingBot")
  end
  
  --- @return any
  function Entity:m_bHasControlledBotThisRound()
  	return entity.get_prop(self.eid, "m_bHasControlledBotThisRound")
  end
  
  --- @return any
  function Entity:m_bCanControlObservedBot()
  	return entity.get_prop(self.eid, "m_bCanControlObservedBot")
  end
  
  --- @return any
  function Entity:m_iControlledBotEntIndex()
  	return entity.get_prop(self.eid, "m_iControlledBotEntIndex")
  end
  
  --- @return any
  function Entity:m_bHud_MiniScoreHidden()
  	return entity.get_prop(self.eid, "m_bHud_MiniScoreHidden")
  end
  
  --- @return any
  function Entity:m_bHud_RadarHidden()
  	return entity.get_prop(self.eid, "m_bHud_RadarHidden")
  end
  
  --- @return any
  function Entity:m_nLastKillerIndex()
  	return entity.get_prop(self.eid, "m_nLastKillerIndex")
  end
  
  --- @return any
  function Entity:m_nLastConcurrentKilled()
  	return entity.get_prop(self.eid, "m_nLastConcurrentKilled")
  end
  
  --- @return any
  function Entity:m_nDeathCamMusic()
  	return entity.get_prop(self.eid, "m_nDeathCamMusic")
  end
  
  --- @return any
  function Entity:m_bIsLookingAtWeapon()
  	return entity.get_prop(self.eid, "m_bIsLookingAtWeapon")
  end
  
  --- @return any
  function Entity:m_bIsHoldingLookAtWeapon()
  	return entity.get_prop(self.eid, "m_bIsHoldingLookAtWeapon")
  end
  
  --- @return any
  function Entity:m_iNumRoundKillsHeadshots()
  	return entity.get_prop(self.eid, "m_iNumRoundKillsHeadshots")
  end
  
  --- @return any
  function Entity:m_unTotalRoundDamageDealt()
  	return entity.get_prop(self.eid, "m_unTotalRoundDamageDealt")
  end
  
  --- @return any
  function Entity:m_flLowerBodyYawTarget()
  	return entity.get_prop(self.eid, "m_flLowerBodyYawTarget")
  end
  
  --- @return any
  function Entity:m_bStrafing()
  	return entity.get_prop(self.eid, "m_bStrafing")
  end
  
  --- @return any
  function Entity:m_flThirdpersonRecoil()
  	return entity.get_prop(self.eid, "m_flThirdpersonRecoil")
  end
  
  --- @return any
  function Entity:m_bHideTargetID()
  	return entity.get_prop(self.eid, "m_bHideTargetID")
  end
  
  --- @return any
  function Entity:m_bIsSpawnRappelling()
  	return entity.get_prop(self.eid, "m_bIsSpawnRappelling")
  end
  
  --- @return Vector3
  function Entity:m_vecSpawnRappellingRopeOrigin()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecSpawnRappellingRopeOrigin"))
  end
  
  --- @return any
  function Entity:m_nSurvivalTeam()
  	return entity.get_prop(self.eid, "m_nSurvivalTeam")
  end
  
  --- @return any
  function Entity:m_hSurvivalAssassinationTarget()
  	return entity.get_prop(self.eid, "m_hSurvivalAssassinationTarget")
  end
  
  --- @return Vector3
  function Entity:m_vecAutomoveTargetEnd()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecAutomoveTargetEnd"))
  end
  
  --- @return any
  function Entity:m_flAutoMoveStartTime()
  	return entity.get_prop(self.eid, "m_flAutoMoveStartTime")
  end
  
  --- @return any
  function Entity:m_flAutoMoveTargetTime()
  	return entity.get_prop(self.eid, "m_flAutoMoveTargetTime")
  end
  
  --- @return any
  function Entity:m_flHealthShotBoostExpirationTime()
  	return entity.get_prop(self.eid, "m_flHealthShotBoostExpirationTime")
  end
  
  --- @return any
  function Entity:m_flLastExoJumpTime()
  	return entity.get_prop(self.eid, "m_flLastExoJumpTime")
  end
  
  --- @return any
  function Entity:m_iPlayerC4()
  	return entity.get_prop(self.eid, "m_iPlayerC4")
  end
  
  --- @return any
  function Entity:m_iPlayerVIP()
  	return entity.get_prop(self.eid, "m_iPlayerVIP")
  end
  
  --- @return any
  function Entity:m_bombsiteCenterA()
  	return entity.get_prop(self.eid, "m_bombsiteCenterA")
  end
  
  --- @return any
  function Entity:m_bombsiteCenterB()
  	return entity.get_prop(self.eid, "m_bombsiteCenterB")
  end
  
  --- @return any
  function Entity:m_bEndMatchNextMapAllVoted()
  	return entity.get_prop(self.eid, "m_bEndMatchNextMapAllVoted")
  end
  
  --- @return Vector3
  function Entity:m_vecRagdollOrigin()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecRagdollOrigin"))
  end
  
  --- @return any
  function Entity:m_hPlayer()
  	return entity.get_prop(self.eid, "m_hPlayer")
  end
  
  --- @return Vector3
  function Entity:m_vecRagdollVelocity()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecRagdollVelocity"))
  end
  
  --- @return any
  function Entity:m_flDeathYaw()
  	return entity.get_prop(self.eid, "m_flDeathYaw")
  end
  
  --- @return any
  function Entity:m_flAbsYaw()
  	return entity.get_prop(self.eid, "m_flAbsYaw")
  end
  
  --- @return any
  function Entity:m_bSurrendered()
  	return entity.get_prop(self.eid, "m_bSurrendered")
  end
  
  --- @return any
  function Entity:m_scoreTotal()
  	return entity.get_prop(self.eid, "m_scoreTotal")
  end
  
  --- @return any
  function Entity:m_scoreFirstHalf()
  	return entity.get_prop(self.eid, "m_scoreFirstHalf")
  end
  
  --- @return any
  function Entity:m_scoreSecondHalf()
  	return entity.get_prop(self.eid, "m_scoreSecondHalf")
  end
  
  --- @return any
  function Entity:m_scoreOvertime()
  	return entity.get_prop(self.eid, "m_scoreOvertime")
  end
  
  --- @return any
  function Entity:m_iClanID()
  	return entity.get_prop(self.eid, "m_iClanID")
  end
  
  --- @return any
  function Entity:m_szTeamname()
  	return entity.get_prop(self.eid, "m_szTeamname")
  end
  
  --- @return any
  function Entity:m_szClanTeamname()
  	return entity.get_prop(self.eid, "m_szClanTeamname")
  end
  
  --- @return any
  function Entity:m_szTeamFlagImage()
  	return entity.get_prop(self.eid, "m_szTeamFlagImage")
  end
  
  --- @return any
  function Entity:m_szTeamLogoImage()
  	return entity.get_prop(self.eid, "m_szTeamLogoImage")
  end
  
  --- @return any
  function Entity:m_szTeamMatchStat()
  	return entity.get_prop(self.eid, "m_szTeamMatchStat")
  end
  
  --- @return any
  function Entity:m_nGGLeaderEntIndex_CT()
  	return entity.get_prop(self.eid, "m_nGGLeaderEntIndex_CT")
  end
  
  --- @return any
  function Entity:m_nGGLeaderEntIndex_T()
  	return entity.get_prop(self.eid, "m_nGGLeaderEntIndex_T")
  end
  
  --- @return any
  function Entity:m_numMapVictories()
  	return entity.get_prop(self.eid, "m_numMapVictories")
  end
  
  --- @return Vector3
  function Entity:m_vecDangerZoneOriginStartedAt()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecDangerZoneOriginStartedAt"))
  end
  
  --- @return any
  function Entity:m_flBombLaunchTime()
  	return entity.get_prop(self.eid, "m_flBombLaunchTime")
  end
  
  --- @return any
  function Entity:m_flExtraRadius()
  	return entity.get_prop(self.eid, "m_flExtraRadius")
  end
  
  --- @return any
  function Entity:m_flExtraRadiusStartTime()
  	return entity.get_prop(self.eid, "m_flExtraRadiusStartTime")
  end
  
  --- @return any
  function Entity:m_flExtraRadiusTotalLerpTime()
  	return entity.get_prop(self.eid, "m_flExtraRadiusTotalLerpTime")
  end
  
  --- @return any
  function Entity:m_nDropOrder()
  	return entity.get_prop(self.eid, "m_nDropOrder")
  end
  
  --- @return any
  function Entity:m_iWave()
  	return entity.get_prop(self.eid, "m_iWave")
  end
  
  --- @return Angle
  function Entity:m_bDangerZoneControllerEnabled()
  	return Angle:new(entity.get_prop(self.eid, "m_bDangerZoneControllerEnabled"))
  end
  
  --- @return any
  function Entity:m_bMissionControlledExplosions()
  	return entity.get_prop(self.eid, "m_bMissionControlledExplosions")
  end
  
  --- @return any
  function Entity:m_flStartTime()
  	return entity.get_prop(self.eid, "m_flStartTime")
  end
  
  --- @return any
  function Entity:m_flFinalExpansionTime()
  	return entity.get_prop(self.eid, "m_flFinalExpansionTime")
  end
  
  --- @return Vector3
  function Entity:m_vecEndGameCircleStart()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEndGameCircleStart"))
  end
  
  --- @return Vector3
  function Entity:m_vecEndGameCircleEnd()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEndGameCircleEnd"))
  end
  
  --- @return any
  function Entity:m_hTheFinalZone()
  	return entity.get_prop(self.eid, "m_hTheFinalZone")
  end
  
  --- @return any
  function Entity:m_bAwake()
  	return entity.get_prop(self.eid, "m_bAwake")
  end
  
  --- @return any
  function Entity:m_hMoveToThisEntity()
  	return entity.get_prop(self.eid, "m_hMoveToThisEntity")
  end
  
  --- @return any
  function Entity:m_hDeliveryCargo()
  	return entity.get_prop(self.eid, "m_hDeliveryCargo")
  end
  
  --- @return any
  function Entity:m_bPilotTakeoverAllowed()
  	return entity.get_prop(self.eid, "m_bPilotTakeoverAllowed")
  end
  
  --- @return any
  function Entity:m_hPotentialCargo()
  	return entity.get_prop(self.eid, "m_hPotentialCargo")
  end
  
  --- @return any
  function Entity:m_hCurrentPilot()
  	return entity.get_prop(self.eid, "m_hCurrentPilot")
  end
  
  --- @return Vector3
  function Entity:m_vecTagPositions()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecTagPositions"))
  end
  
  --- @return Vector3
  function Entity:m_vecTagIncrements()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecTagIncrements"))
  end
  
  --- @return Vector3
  function Entity:m_vecAttentionTarget()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecAttentionTarget"))
  end
  
  --- @return Vector3
  function Entity:m_vecTargetOffset()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecTargetOffset"))
  end
  
  --- @return any
  function Entity:m_bHasTarget()
  	return entity.get_prop(self.eid, "m_bHasTarget")
  end
  
  --- @return any
  function Entity:m_Flags()
  	return entity.get_prop(self.eid, "m_Flags")
  end
  
  --- @return any
  function Entity:m_LightStyle()
  	return entity.get_prop(self.eid, "m_LightStyle")
  end
  
  --- @return any
  function Entity:m_Radius()
  	return entity.get_prop(self.eid, "m_Radius")
  end
  
  --- @return any
  function Entity:m_Exponent()
  	return entity.get_prop(self.eid, "m_Exponent")
  end
  
  --- @return any
  function Entity:m_InnerAngle()
  	return entity.get_prop(self.eid, "m_InnerAngle")
  end
  
  --- @return any
  function Entity:m_OuterAngle()
  	return entity.get_prop(self.eid, "m_OuterAngle")
  end
  
  --- @return any
  function Entity:m_SpotRadius()
  	return entity.get_prop(self.eid, "m_SpotRadius")
  end
  
  --- @return any
  function Entity:m_nDensity()
  	return entity.get_prop(self.eid, "m_nDensity")
  end
  
  --- @return any
  function Entity:m_nLifetime()
  	return entity.get_prop(self.eid, "m_nLifetime")
  end
  
  --- @return any
  function Entity:m_nSpeed()
  	return entity.get_prop(self.eid, "m_nSpeed")
  end
  
  --- @return any
  function Entity:m_bEmit()
  	return entity.get_prop(self.eid, "m_bEmit")
  end
  
  --- @return any
  function Entity:m_flFadeInStart()
  	return entity.get_prop(self.eid, "m_flFadeInStart")
  end
  
  --- @return any
  function Entity:m_flFadeInLength()
  	return entity.get_prop(self.eid, "m_flFadeInLength")
  end
  
  --- @return any
  function Entity:m_flFadeOutModelStart()
  	return entity.get_prop(self.eid, "m_flFadeOutModelStart")
  end
  
  --- @return any
  function Entity:m_flFadeOutModelLength()
  	return entity.get_prop(self.eid, "m_flFadeOutModelLength")
  end
  
  --- @return any
  function Entity:m_flFadeOutStart()
  	return entity.get_prop(self.eid, "m_flFadeOutStart")
  end
  
  --- @return any
  function Entity:m_flFadeOutLength()
  	return entity.get_prop(self.eid, "m_flFadeOutLength")
  end
  
  --- @return any
  function Entity:m_nDissolveType()
  	return entity.get_prop(self.eid, "m_nDissolveType")
  end
  
  --- @return any
  function Entity:m_vDissolverOrigin()
  	return entity.get_prop(self.eid, "m_vDissolverOrigin")
  end
  
  --- @return any
  function Entity:m_nMagnitude()
  	return entity.get_prop(self.eid, "m_nMagnitude")
  end
  
  --- @return any
  function Entity:m_hEntAttached()
  	return entity.get_prop(self.eid, "m_hEntAttached")
  end
  
  --- @return any
  function Entity:m_bCheapEffect()
  	return entity.get_prop(self.eid, "m_bCheapEffect")
  end
  
  --- @return any
  function Entity:m_vFreezingOrigin()
  	return entity.get_prop(self.eid, "m_vFreezingOrigin")
  end
  
  --- @return any
  function Entity:m_bFinishFreezing()
  	return entity.get_prop(self.eid, "m_bFinishFreezing")
  end
  
  --- @return any
  function Entity:m_iMaterialName()
  	return entity.get_prop(self.eid, "m_iMaterialName")
  end
  
  --- @return any
  function Entity:m_flLifetime()
  	return entity.get_prop(self.eid, "m_flLifetime")
  end
  
  --- @return any
  function Entity:m_flStartSize()
  	return entity.get_prop(self.eid, "m_flStartSize")
  end
  
  --- @return any
  function Entity:m_flEndSize()
  	return entity.get_prop(self.eid, "m_flEndSize")
  end
  
  --- @return Vector3
  function Entity:m_vecColor()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecColor"))
  end
  
  --- @return any
  function Entity:m_flFadeStartDist()
  	return entity.get_prop(self.eid, "m_flFadeStartDist")
  end
  
  --- @return any
  function Entity:m_flFadeEndDist()
  	return entity.get_prop(self.eid, "m_flFadeEndDist")
  end
  
  --- @return any
  function Entity:m_bDOFEnabled()
  	return entity.get_prop(self.eid, "m_bDOFEnabled")
  end
  
  --- @return any
  function Entity:m_flNearBlurDepth()
  	return entity.get_prop(self.eid, "m_flNearBlurDepth")
  end
  
  --- @return any
  function Entity:m_flNearFocusDepth()
  	return entity.get_prop(self.eid, "m_flNearFocusDepth")
  end
  
  --- @return any
  function Entity:m_flFarFocusDepth()
  	return entity.get_prop(self.eid, "m_flFarFocusDepth")
  end
  
  --- @return any
  function Entity:m_flFarBlurDepth()
  	return entity.get_prop(self.eid, "m_flFarBlurDepth")
  end
  
  --- @return any
  function Entity:m_flNearBlurRadius()
  	return entity.get_prop(self.eid, "m_flNearBlurRadius")
  end
  
  --- @return any
  function Entity:m_flFarBlurRadius()
  	return entity.get_prop(self.eid, "m_flFarBlurRadius")
  end
  
  --- @return any
  function Entity:m_flFlightSpeed()
  	return entity.get_prop(self.eid, "m_flFlightSpeed")
  end
  
  --- @return any
  function Entity:m_flLaunchTime()
  	return entity.get_prop(self.eid, "m_flLaunchTime")
  end
  
  --- @return Vector3
  function Entity:m_vecParabolaDirection()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecParabolaDirection"))
  end
  
  --- @return any
  function Entity:m_flFlightTime()
  	return entity.get_prop(self.eid, "m_flFlightTime")
  end
  
  --- @return any
  function Entity:m_flWorldEnterTime()
  	return entity.get_prop(self.eid, "m_flWorldEnterTime")
  end
  
  --- @return any
  function Entity:m_flInitialZSpeed()
  	return entity.get_prop(self.eid, "m_flInitialZSpeed")
  end
  
  --- @return any
  function Entity:m_flZAcceleration()
  	return entity.get_prop(self.eid, "m_flZAcceleration")
  end
  
  --- @return any
  function Entity:m_flHorizSpeed()
  	return entity.get_prop(self.eid, "m_flHorizSpeed")
  end
  
  --- @return any
  function Entity:m_bLaunchedFromWithinWorld()
  	return entity.get_prop(self.eid, "m_bLaunchedFromWithinWorld")
  end
  
  --- @return Vector3
  function Entity:m_vecImpactPosition()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecImpactPosition"))
  end
  
  --- @return Vector3
  function Entity:m_vecStartPosition()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecStartPosition"))
  end
  
  --- @return Vector3
  function Entity:m_vecEnterWorldPosition()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEnterWorldPosition"))
  end
  
  --- @return Vector3
  function Entity:m_vecDirection()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecDirection"))
  end
  
  --- @return Vector3
  function Entity:m_vecStartAngles()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecStartAngles"))
  end
  
  --- @return Vector3
  function Entity:m_vecSkyboxOrigin()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecSkyboxOrigin"))
  end
  
  --- @return any
  function Entity:m_flSkyboxScale()
  	return entity.get_prop(self.eid, "m_flSkyboxScale")
  end
  
  --- @return any
  function Entity:m_bInSkybox()
  	return entity.get_prop(self.eid, "m_bInSkybox")
  end
  
  --- @return any
  function Entity:m_bDoImpactEffects()
  	return entity.get_prop(self.eid, "m_bDoImpactEffects")
  end
  
  --- @return any
  function Entity:m_bLanded()
  	return entity.get_prop(self.eid, "m_bLanded")
  end
  
  --- @return any
  function Entity:m_hSkyboxCopy()
  	return entity.get_prop(self.eid, "m_hSkyboxCopy")
  end
  
  --- @return any
  function Entity:m_nMyZoneIndex()
  	return entity.get_prop(self.eid, "m_nMyZoneIndex")
  end
  
  --- @return any
  function Entity:m_flSequenceScale()
  	return entity.get_prop(self.eid, "m_flSequenceScale")
  end
  
  --- @return any
  function Entity:m_hTargetEntity()
  	return entity.get_prop(self.eid, "m_hTargetEntity")
  end
  
  --- @return any
  function Entity:m_bState()
  	return entity.get_prop(self.eid, "m_bState")
  end
  
  --- @return any
  function Entity:m_bAlwaysUpdate()
  	return entity.get_prop(self.eid, "m_bAlwaysUpdate")
  end
  
  --- @return any
  function Entity:m_flLightFOV()
  	return entity.get_prop(self.eid, "m_flLightFOV")
  end
  
  --- @return any
  function Entity:m_bEnableShadows()
  	return entity.get_prop(self.eid, "m_bEnableShadows")
  end
  
  --- @return any
  function Entity:m_bSimpleProjection()
  	return entity.get_prop(self.eid, "m_bSimpleProjection")
  end
  
  --- @return any
  function Entity:m_bLightOnlyTarget()
  	return entity.get_prop(self.eid, "m_bLightOnlyTarget")
  end
  
  --- @return any
  function Entity:m_bLightWorld()
  	return entity.get_prop(self.eid, "m_bLightWorld")
  end
  
  --- @return any
  function Entity:m_bCameraSpace()
  	return entity.get_prop(self.eid, "m_bCameraSpace")
  end
  
  --- @return any
  function Entity:m_flBrightnessScale()
  	return entity.get_prop(self.eid, "m_flBrightnessScale")
  end
  
  --- @return any
  function Entity:m_flColorTransitionTime()
  	return entity.get_prop(self.eid, "m_flColorTransitionTime")
  end
  
  --- @return any
  function Entity:m_flAmbient()
  	return entity.get_prop(self.eid, "m_flAmbient")
  end
  
  --- @return any
  function Entity:m_SpotlightTextureName()
  	return entity.get_prop(self.eid, "m_SpotlightTextureName")
  end
  
  --- @return any
  function Entity:m_nSpotlightTextureFrame()
  	return entity.get_prop(self.eid, "m_nSpotlightTextureFrame")
  end
  
  --- @return any
  function Entity:m_flNearZ()
  	return entity.get_prop(self.eid, "m_flNearZ")
  end
  
  --- @return any
  function Entity:m_flFarZ()
  	return entity.get_prop(self.eid, "m_flFarZ")
  end
  
  --- @return any
  function Entity:m_nShadowQuality()
  	return entity.get_prop(self.eid, "m_nShadowQuality")
  end
  
  --- @return any
  function Entity:m_flProjectionSize()
  	return entity.get_prop(self.eid, "m_flProjectionSize")
  end
  
  --- @return any
  function Entity:m_flRotation()
  	return entity.get_prop(self.eid, "m_flRotation")
  end
  
  --- @return any
  function Entity:m_iStyle()
  	return entity.get_prop(self.eid, "m_iStyle")
  end
  
  --- @return any
  function Entity:m_targetPosition()
  	return entity.get_prop(self.eid, "m_targetPosition")
  end
  
  --- @return any
  function Entity:m_controlPosition()
  	return entity.get_prop(self.eid, "m_controlPosition")
  end
  
  --- @return any
  function Entity:m_scrollRate()
  	return entity.get_prop(self.eid, "m_scrollRate")
  end
  
  --- @return any
  function Entity:m_flWidth()
  	return entity.get_prop(self.eid, "m_flWidth")
  end
  
  --- @return any
  function Entity:m_flDuration()
  	return entity.get_prop(self.eid, "m_flDuration")
  end
  
  --- @return any
  function Entity:m_nType()
  	return entity.get_prop(self.eid, "m_nType")
  end
  
  --- @return any
  function Entity:m_iszOverlayNames()
  	return entity.get_prop(self.eid, "m_iszOverlayNames")
  end
  
  --- @return any
  function Entity:m_flOverlayTimes()
  	return entity.get_prop(self.eid, "m_flOverlayTimes")
  end
  
  --- @return any
  function Entity:m_iDesiredOverlay()
  	return entity.get_prop(self.eid, "m_iDesiredOverlay")
  end
  
  --- @return any
  function Entity:m_bIsActive()
  	return entity.get_prop(self.eid, "m_bIsActive")
  end
  
  --- @return any
  function Entity:m_bUseCustomAutoExposureMin()
  	return entity.get_prop(self.eid, "m_bUseCustomAutoExposureMin")
  end
  
  --- @return any
  function Entity:m_bUseCustomAutoExposureMax()
  	return entity.get_prop(self.eid, "m_bUseCustomAutoExposureMax")
  end
  
  --- @return any
  function Entity:m_bUseCustomBloomScale()
  	return entity.get_prop(self.eid, "m_bUseCustomBloomScale")
  end
  
  --- @return any
  function Entity:m_flCustomAutoExposureMin()
  	return entity.get_prop(self.eid, "m_flCustomAutoExposureMin")
  end
  
  --- @return any
  function Entity:m_flCustomAutoExposureMax()
  	return entity.get_prop(self.eid, "m_flCustomAutoExposureMax")
  end
  
  --- @return any
  function Entity:m_flCustomBloomScale()
  	return entity.get_prop(self.eid, "m_flCustomBloomScale")
  end
  
  --- @return any
  function Entity:m_flCustomBloomScaleMinimum()
  	return entity.get_prop(self.eid, "m_flCustomBloomScaleMinimum")
  end
  
  --- @return any
  function Entity:m_flBloomExponent()
  	return entity.get_prop(self.eid, "m_flBloomExponent")
  end
  
  --- @return any
  function Entity:m_flBloomSaturation()
  	return entity.get_prop(self.eid, "m_flBloomSaturation")
  end
  
  --- @return any
  function Entity:m_flTonemapPercentTarget()
  	return entity.get_prop(self.eid, "m_flTonemapPercentTarget")
  end
  
  --- @return any
  function Entity:m_flTonemapPercentBrightPixels()
  	return entity.get_prop(self.eid, "m_flTonemapPercentBrightPixels")
  end
  
  --- @return any
  function Entity:m_flTonemapMinAvgLum()
  	return entity.get_prop(self.eid, "m_flTonemapMinAvgLum")
  end
  
  --- @return any
  function Entity:m_flTonemapRate()
  	return entity.get_prop(self.eid, "m_flTonemapRate")
  end
  
  --- @return any
  function Entity:m_iMinWind()
  	return entity.get_prop(self.eid, "m_iMinWind")
  end
  
  --- @return any
  function Entity:m_iMaxWind()
  	return entity.get_prop(self.eid, "m_iMaxWind")
  end
  
  --- @return any
  function Entity:m_iMinGust()
  	return entity.get_prop(self.eid, "m_iMinGust")
  end
  
  --- @return any
  function Entity:m_iMaxGust()
  	return entity.get_prop(self.eid, "m_iMaxGust")
  end
  
  --- @return any
  function Entity:m_flMinGustDelay()
  	return entity.get_prop(self.eid, "m_flMinGustDelay")
  end
  
  --- @return any
  function Entity:m_flMaxGustDelay()
  	return entity.get_prop(self.eid, "m_flMaxGustDelay")
  end
  
  --- @return Angle
  function Entity:m_iGustDirChange()
  	return Angle:new(entity.get_prop(self.eid, "m_iGustDirChange"))
  end
  
  --- @return any
  function Entity:m_iWindSeed()
  	return entity.get_prop(self.eid, "m_iWindSeed")
  end
  
  --- @return any
  function Entity:m_iInitialWindDir()
  	return entity.get_prop(self.eid, "m_iInitialWindDir")
  end
  
  --- @return any
  function Entity:m_flInitialWindSpeed()
  	return entity.get_prop(self.eid, "m_flInitialWindSpeed")
  end
  
  --- @return any
  function Entity:m_flGustDuration()
  	return entity.get_prop(self.eid, "m_flGustDuration")
  end
  
  --- @return any
  function Entity:m_nUniqueID()
  	return entity.get_prop(self.eid, "m_nUniqueID")
  end
  
  --- @return any
  function Entity:m_unAccountID()
  	return entity.get_prop(self.eid, "m_unAccountID")
  end
  
  --- @return any
  function Entity:m_unTraceID()
  	return entity.get_prop(self.eid, "m_unTraceID")
  end
  
  --- @return any
  function Entity:m_rtGcTime()
  	return entity.get_prop(self.eid, "m_rtGcTime")
  end
  
  --- @return Vector3
  function Entity:m_vecStart()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecStart"))
  end
  
  --- @return Vector3
  function Entity:m_vecRight()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecRight"))
  end
  
  --- @return Vector3
  function Entity:m_vecNormal()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecNormal"))
  end
  
  --- @return any
  function Entity:m_nEntity()
  	return entity.get_prop(self.eid, "m_nEntity")
  end
  
  --- @return any
  function Entity:m_nPlayer()
  	return entity.get_prop(self.eid, "m_nPlayer")
  end
  
  --- @return any
  function Entity:m_nHitbox()
  	return entity.get_prop(self.eid, "m_nHitbox")
  end
  
  --- @return any
  function Entity:m_nTintID()
  	return entity.get_prop(self.eid, "m_nTintID")
  end
  
  --- @return any
  function Entity:m_flCreationTime()
  	return entity.get_prop(self.eid, "m_flCreationTime")
  end
  
  --- @return any
  function Entity:m_nVersion()
  	return entity.get_prop(self.eid, "m_nVersion")
  end
  
  --- @return any
  function Entity:m_fireCount()
  	return entity.get_prop(self.eid, "m_fireCount")
  end
  
  --- @return any
  function Entity:m_nFireEffectTickBegin()
  	return entity.get_prop(self.eid, "m_nFireEffectTickBegin")
  end
  
  --- @return any
  function Entity:m_flStartScale()
  	return entity.get_prop(self.eid, "m_flStartScale")
  end
  
  --- @return any
  function Entity:m_flScale()
  	return entity.get_prop(self.eid, "m_flScale")
  end
  
  --- @return any
  function Entity:m_flScaleTime()
  	return entity.get_prop(self.eid, "m_flScaleTime")
  end
  
  --- @return any
  function Entity:m_nFlags()
  	return entity.get_prop(self.eid, "m_nFlags")
  end
  
  --- @return any
  function Entity:m_nFlameModelIndex()
  	return entity.get_prop(self.eid, "m_nFlameModelIndex")
  end
  
  --- @return any
  function Entity:m_nFlameFromAboveModelIndex()
  	return entity.get_prop(self.eid, "m_nFlameFromAboveModelIndex")
  end
  
  --- @return any
  function Entity:m_nAttachment()
  	return entity.get_prop(self.eid, "m_nAttachment")
  end
  
  --- @return any
  function Entity:m_poolOrigin()
  	return entity.get_prop(self.eid, "m_poolOrigin")
  end
  
  --- @return Angle
  function Entity:m_angle()
  	return Angle:new(entity.get_prop(self.eid, "m_angle"))
  end
  
  --- @return any
  function Entity:m_x()
  	return entity.get_prop(self.eid, "m_x")
  end
  
  --- @return any
  function Entity:m_y()
  	return entity.get_prop(self.eid, "m_y")
  end
  
  --- @return any
  function Entity:m_z()
  	return entity.get_prop(self.eid, "m_z")
  end
  
  --- @return any
  function Entity:m_waterLevel()
  	return entity.get_prop(self.eid, "m_waterLevel")
  end
  
  --- @return any
  function Entity:m_bPlayingUninterruptableAct()
  	return entity.get_prop(self.eid, "m_bPlayingUninterruptableAct")
  end
  
  --- @return any
  function Entity:m_source()
  	return entity.get_prop(self.eid, "m_source")
  end
  
  --- @return any
  function Entity:m_destination()
  	return entity.get_prop(self.eid, "m_destination")
  end
  
  --- @return any
  function Entity:m_Color()
  	return entity.get_prop(self.eid, "m_Color")
  end
  
  --- @return any
  function Entity:m_SpawnRate()
  	return entity.get_prop(self.eid, "m_SpawnRate")
  end
  
  --- @return any
  function Entity:m_SpeedMax()
  	return entity.get_prop(self.eid, "m_SpeedMax")
  end
  
  --- @return any
  function Entity:m_flSizeMin()
  	return entity.get_prop(self.eid, "m_flSizeMin")
  end
  
  --- @return any
  function Entity:m_flSizeMax()
  	return entity.get_prop(self.eid, "m_flSizeMax")
  end
  
  --- @return any
  function Entity:m_DistMax()
  	return entity.get_prop(self.eid, "m_DistMax")
  end
  
  --- @return any
  function Entity:m_LifetimeMin()
  	return entity.get_prop(self.eid, "m_LifetimeMin")
  end
  
  --- @return any
  function Entity:m_LifetimeMax()
  	return entity.get_prop(self.eid, "m_LifetimeMax")
  end
  
  --- @return any
  function Entity:m_DustFlags()
  	return entity.get_prop(self.eid, "m_DustFlags")
  end
  
  --- @return any
  function Entity:m_FallSpeed()
  	return entity.get_prop(self.eid, "m_FallSpeed")
  end
  
  --- @return any
  function Entity:m_bAffectedByWind()
  	return entity.get_prop(self.eid, "m_bAffectedByWind")
  end
  
  --- @return any
  function Entity:m_nDisappearMinDist()
  	return entity.get_prop(self.eid, "m_nDisappearMinDist")
  end
  
  --- @return any
  function Entity:m_nDisappearMaxDist()
  	return entity.get_prop(self.eid, "m_nDisappearMaxDist")
  end
  
  --- @return any
  function Entity:m_flFadeDist()
  	return entity.get_prop(self.eid, "m_flFadeDist")
  end
  
  --- @return any
  function Entity:m_flTranslucencyLimit()
  	return entity.get_prop(self.eid, "m_flTranslucencyLimit")
  end
  
  --- @return any
  function Entity:m_iBackgroundModelIndex()
  	return entity.get_prop(self.eid, "m_iBackgroundModelIndex")
  end
  
  --- @return any
  function Entity:m_flConveyorSpeed()
  	return entity.get_prop(self.eid, "m_flConveyorSpeed")
  end
  
  --- @return Vector3
  function Entity:m_vecPlayerMountPositionTop()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPlayerMountPositionTop"))
  end
  
  --- @return Vector3
  function Entity:m_vecPlayerMountPositionBottom()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPlayerMountPositionBottom"))
  end
  
  --- @return Vector3
  function Entity:m_vecLadderDir()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecLadderDir"))
  end
  
  --- @return any
  function Entity:m_bFakeLadder()
  	return entity.get_prop(self.eid, "m_bFakeLadder")
  end
  
  --- @return any
  function Entity:m_bActive()
  	return entity.get_prop(self.eid, "m_bActive")
  end
  
  --- @return any
  function Entity:m_nOccluderIndex()
  	return entity.get_prop(self.eid, "m_nOccluderIndex")
  end
  
  --- @return any
  function Entity:m_Color1()
  	return entity.get_prop(self.eid, "m_Color1")
  end
  
  --- @return any
  function Entity:m_Color2()
  	return entity.get_prop(self.eid, "m_Color2")
  end
  
  --- @return any
  function Entity:m_MaterialName()
  	return entity.get_prop(self.eid, "m_MaterialName")
  end
  
  --- @return any
  function Entity:m_ParticleDrawWidth()
  	return entity.get_prop(self.eid, "m_ParticleDrawWidth")
  end
  
  --- @return any
  function Entity:m_ParticleSpacingDistance()
  	return entity.get_prop(self.eid, "m_ParticleSpacingDistance")
  end
  
  --- @return any
  function Entity:m_DensityRampSpeed()
  	return entity.get_prop(self.eid, "m_DensityRampSpeed")
  end
  
  --- @return any
  function Entity:m_RotationSpeed()
  	return entity.get_prop(self.eid, "m_RotationSpeed")
  end
  
  --- @return any
  function Entity:m_MovementSpeed()
  	return entity.get_prop(self.eid, "m_MovementSpeed")
  end
  
  --- @return any
  function Entity:m_Density()
  	return entity.get_prop(self.eid, "m_Density")
  end
  
  --- @return any
  function Entity:m_maxDrawDistance()
  	return entity.get_prop(self.eid, "m_maxDrawDistance")
  end
  
  --- @return any
  function Entity:m_flGrassBurnClearTime()
  	return entity.get_prop(self.eid, "m_flGrassBurnClearTime")
  end
  
  --- @return any
  function Entity:m_Handle()
  	return entity.get_prop(self.eid, "m_Handle")
  end
  
  --- @return any
  function Entity:m_bSendHandle()
  	return entity.get_prop(self.eid, "m_bSendHandle")
  end
  
  --- @return any
  function Entity:m_isRescued()
  	return entity.get_prop(self.eid, "m_isRescued")
  end
  
  --- @return any
  function Entity:m_iMaxHealth()
  	return entity.get_prop(self.eid, "m_iMaxHealth")
  end
  
  --- @return any
  function Entity:m_vel()
  	return entity.get_prop(self.eid, "m_vel")
  end
  
  --- @return any
  function Entity:m_nHostageState()
  	return entity.get_prop(self.eid, "m_nHostageState")
  end
  
  --- @return any
  function Entity:m_flRescueStartTime()
  	return entity.get_prop(self.eid, "m_flRescueStartTime")
  end
  
  --- @return any
  function Entity:m_flGrabSuccessTime()
  	return entity.get_prop(self.eid, "m_flGrabSuccessTime")
  end
  
  --- @return any
  function Entity:m_flDropStartTime()
  	return entity.get_prop(self.eid, "m_flDropStartTime")
  end
  
  --- @return any
  function Entity:m_szLocToken()
  	return entity.get_prop(self.eid, "m_szLocToken")
  end
  
  --- @return any
  function Entity:m_iOverlayID()
  	return entity.get_prop(self.eid, "m_iOverlayID")
  end
  
  --- @return any
  function Entity:m_OwningPlayer()
  	return entity.get_prop(self.eid, "m_OwningPlayer")
  end
  
  --- @return any
  function Entity:m_KillingPlayer()
  	return entity.get_prop(self.eid, "m_KillingPlayer")
  end
  
  --- @return any
  function Entity:m_nHorizontalSize()
  	return entity.get_prop(self.eid, "m_nHorizontalSize")
  end
  
  --- @return any
  function Entity:m_nVerticalSize()
  	return entity.get_prop(self.eid, "m_nVerticalSize")
  end
  
  --- @return any
  function Entity:m_nMinDist()
  	return entity.get_prop(self.eid, "m_nMinDist")
  end
  
  --- @return any
  function Entity:m_nMaxDist()
  	return entity.get_prop(self.eid, "m_nMaxDist")
  end
  
  --- @return any
  function Entity:m_nOuterMaxDist()
  	return entity.get_prop(self.eid, "m_nOuterMaxDist")
  end
  
  --- @return any
  function Entity:m_flGlowProxySize()
  	return entity.get_prop(self.eid, "m_flGlowProxySize")
  end
  
  --- @return any
  function Entity:m_szMaterialName()
  	return entity.get_prop(self.eid, "m_szMaterialName")
  end
  
  --- @return any
  function Entity:m_szMaterialVar()
  	return entity.get_prop(self.eid, "m_szMaterialVar")
  end
  
  --- @return any
  function Entity:m_szMaterialVarValue()
  	return entity.get_prop(self.eid, "m_szMaterialVarValue")
  end
  
  --- @return any
  function Entity:m_iFrameStart()
  	return entity.get_prop(self.eid, "m_iFrameStart")
  end
  
  --- @return any
  function Entity:m_iFrameEnd()
  	return entity.get_prop(self.eid, "m_iFrameEnd")
  end
  
  --- @return any
  function Entity:m_bWrap()
  	return entity.get_prop(self.eid, "m_bWrap")
  end
  
  --- @return any
  function Entity:m_flFramerate()
  	return entity.get_prop(self.eid, "m_flFramerate")
  end
  
  --- @return any
  function Entity:m_bNewAnimCommandsSemaphore()
  	return entity.get_prop(self.eid, "m_bNewAnimCommandsSemaphore")
  end
  
  --- @return any
  function Entity:m_flFloatLerpStartValue()
  	return entity.get_prop(self.eid, "m_flFloatLerpStartValue")
  end
  
  --- @return any
  function Entity:m_flFloatLerpEndValue()
  	return entity.get_prop(self.eid, "m_flFloatLerpEndValue")
  end
  
  --- @return any
  function Entity:m_flFloatLerpTransitionTime()
  	return entity.get_prop(self.eid, "m_flFloatLerpTransitionTime")
  end
  
  --- @return any
  function Entity:m_nModifyMode()
  	return entity.get_prop(self.eid, "m_nModifyMode")
  end
  
  --- @return any
  function Entity:m_flThrowAt()
  	return entity.get_prop(self.eid, "m_flThrowAt")
  end
  
  --- @return any
  function Entity:m_bIsIncGrenade()
  	return entity.get_prop(self.eid, "m_bIsIncGrenade")
  end
  
  --- @return any
  function Entity:m_bLooping()
  	return entity.get_prop(self.eid, "m_bLooping")
  end
  
  --- @return any
  function Entity:m_szMovieFilename()
  	return entity.get_prop(self.eid, "m_szMovieFilename")
  end
  
  --- @return any
  function Entity:m_szGroupName()
  	return entity.get_prop(self.eid, "m_szGroupName")
  end
  
  --- @return any
  function Entity:m_bStretchToFill()
  	return entity.get_prop(self.eid, "m_bStretchToFill")
  end
  
  --- @return any
  function Entity:m_bForcedSlave()
  	return entity.get_prop(self.eid, "m_bForcedSlave")
  end
  
  --- @return any
  function Entity:m_bUseCustomUVs()
  	return entity.get_prop(self.eid, "m_bUseCustomUVs")
  end
  
  --- @return any
  function Entity:m_flUMin()
  	return entity.get_prop(self.eid, "m_flUMin")
  end
  
  --- @return any
  function Entity:m_flUMax()
  	return entity.get_prop(self.eid, "m_flUMax")
  end
  
  --- @return any
  function Entity:m_flVMin()
  	return entity.get_prop(self.eid, "m_flVMin")
  end
  
  --- @return any
  function Entity:m_flVMax()
  	return entity.get_prop(self.eid, "m_flVMax")
  end
  
  --- @return any
  function Entity:m_hCallingPlayer()
  	return entity.get_prop(self.eid, "m_hCallingPlayer")
  end
  
  --- @return any
  function Entity:m_vOrigin()
  	return entity.get_prop(self.eid, "m_vOrigin")
  end
  
  --- @return any
  function Entity:m_vDirection()
  	return entity.get_prop(self.eid, "m_vDirection")
  end
  
  --- @return any
  function Entity:m_bDisplayPerf()
  	return entity.get_prop(self.eid, "m_bDisplayPerf")
  end
  
  --- @return any
  function Entity:m_bMeasurePerf()
  	return entity.get_prop(self.eid, "m_bMeasurePerf")
  end
  
  --- @return any
  function Entity:m_iEffectIndex()
  	return entity.get_prop(self.eid, "m_iEffectIndex")
  end
  
  --- @return any
  function Entity:m_nStopType()
  	return entity.get_prop(self.eid, "m_nStopType")
  end
  
  --- @return any
  function Entity:m_szSnapshotFileName()
  	return entity.get_prop(self.eid, "m_szSnapshotFileName")
  end
  
  --- @return any
  function Entity:m_iPhysicsMode()
  	return entity.get_prop(self.eid, "m_iPhysicsMode")
  end
  
  --- @return any
  function Entity:m_fMass()
  	return entity.get_prop(self.eid, "m_fMass")
  end
  
  --- @return any
  function Entity:m_collisionMins()
  	return entity.get_prop(self.eid, "m_collisionMins")
  end
  
  --- @return any
  function Entity:m_collisionMaxs()
  	return entity.get_prop(self.eid, "m_collisionMaxs")
  end
  
  --- @return any
  function Entity:m_bRenderInPSPM()
  	return entity.get_prop(self.eid, "m_bRenderInPSPM")
  end
  
  --- @return any
  function Entity:m_bRenderInTablet()
  	return entity.get_prop(self.eid, "m_bRenderInTablet")
  end
  
  --- @return any
  function Entity:m_bBombTicking()
  	return entity.get_prop(self.eid, "m_bBombTicking")
  end
  
  --- @return any
  function Entity:m_nBombSite()
  	return entity.get_prop(self.eid, "m_nBombSite")
  end
  
  --- @return any
  function Entity:m_flC4Blow()
  	return entity.get_prop(self.eid, "m_flC4Blow")
  end
  
  --- @return any
  function Entity:m_flTimerLength()
  	return entity.get_prop(self.eid, "m_flTimerLength")
  end
  
  --- @return any
  function Entity:m_flDefuseLength()
  	return entity.get_prop(self.eid, "m_flDefuseLength")
  end
  
  --- @return any
  function Entity:m_flDefuseCountDown()
  	return entity.get_prop(self.eid, "m_flDefuseCountDown")
  end
  
  --- @return any
  function Entity:m_bBombDefused()
  	return entity.get_prop(self.eid, "m_bBombDefused")
  end
  
  --- @return any
  function Entity:m_hBombDefuser()
  	return entity.get_prop(self.eid, "m_hBombDefuser")
  end
  
  --- @return any
  function Entity:m_nPlasmaModelIndex()
  	return entity.get_prop(self.eid, "m_nPlasmaModelIndex")
  end
  
  --- @return any
  function Entity:m_nPlasmaModelIndex2()
  	return entity.get_prop(self.eid, "m_nPlasmaModelIndex2")
  end
  
  --- @return any
  function Entity:m_nGlowModelIndex()
  	return entity.get_prop(self.eid, "m_nGlowModelIndex")
  end
  
  --- @return any
  function Entity:m_hPingedEntity()
  	return entity.get_prop(self.eid, "m_hPingedEntity")
  end
  
  --- @return any
  function Entity:m_iType()
  	return entity.get_prop(self.eid, "m_iType")
  end
  
  --- @return any
  function Entity:m_FOV()
  	return entity.get_prop(self.eid, "m_FOV")
  end
  
  --- @return any
  function Entity:m_Resolution()
  	return entity.get_prop(self.eid, "m_Resolution")
  end
  
  --- @return any
  function Entity:m_bFogEnable()
  	return entity.get_prop(self.eid, "m_bFogEnable")
  end
  
  --- @return any
  function Entity:m_FogColor()
  	return entity.get_prop(self.eid, "m_FogColor")
  end
  
  --- @return any
  function Entity:m_flFogStart()
  	return entity.get_prop(self.eid, "m_flFogStart")
  end
  
  --- @return any
  function Entity:m_flFogEnd()
  	return entity.get_prop(self.eid, "m_flFogEnd")
  end
  
  --- @return any
  function Entity:m_flFogMaxDensity()
  	return entity.get_prop(self.eid, "m_flFogMaxDensity")
  end
  
  --- @return any
  function Entity:m_bUseScreenAspectRatio()
  	return entity.get_prop(self.eid, "m_bUseScreenAspectRatio")
  end
  
  --- @return any
  function Entity:m_iszCommentaryFile()
  	return entity.get_prop(self.eid, "m_iszCommentaryFile")
  end
  
  --- @return any
  function Entity:m_iszCommentaryFileNoHDR()
  	return entity.get_prop(self.eid, "m_iszCommentaryFileNoHDR")
  end
  
  --- @return any
  function Entity:m_iszSpeakers()
  	return entity.get_prop(self.eid, "m_iszSpeakers")
  end
  
  --- @return any
  function Entity:m_iNodeNumber()
  	return entity.get_prop(self.eid, "m_iNodeNumber")
  end
  
  --- @return any
  function Entity:m_iNodeNumberMax()
  	return entity.get_prop(self.eid, "m_iNodeNumberMax")
  end
  
  --- @return any
  function Entity:m_hViewPosition()
  	return entity.get_prop(self.eid, "m_hViewPosition")
  end
  
  --- @return any
  function Entity:m_szText()
  	return entity.get_prop(self.eid, "m_szText")
  end
  
  --- @return any
  function Entity:m_textColor()
  	return entity.get_prop(self.eid, "m_textColor")
  end
  
  --- @return any
  function Entity:m_flTextSize()
  	return entity.get_prop(self.eid, "m_flTextSize")
  end
  
  --- @return any
  function Entity:m_bPoseValueParity()
  	return entity.get_prop(self.eid, "m_bPoseValueParity")
  end
  
  --- @return any
  function Entity:m_fPoseValue()
  	return entity.get_prop(self.eid, "m_fPoseValue")
  end
  
  --- @return any
  function Entity:m_fInterpolationTime()
  	return entity.get_prop(self.eid, "m_fInterpolationTime")
  end
  
  --- @return any
  function Entity:m_bInterpolationWrap()
  	return entity.get_prop(self.eid, "m_bInterpolationWrap")
  end
  
  --- @return any
  function Entity:m_fCycleFrequency()
  	return entity.get_prop(self.eid, "m_fCycleFrequency")
  end
  
  --- @return any
  function Entity:m_nFModType()
  	return entity.get_prop(self.eid, "m_nFModType")
  end
  
  --- @return any
  function Entity:m_fFModTimeOffset()
  	return entity.get_prop(self.eid, "m_fFModTimeOffset")
  end
  
  --- @return any
  function Entity:m_fFModRate()
  	return entity.get_prop(self.eid, "m_fFModRate")
  end
  
  --- @return any
  function Entity:m_fFModAmplitude()
  	return entity.get_prop(self.eid, "m_fFModAmplitude")
  end
  
  --- @return any
  function Entity:m_nPrecipType()
  	return entity.get_prop(self.eid, "m_nPrecipType")
  end
  
  --- @return any
  function Entity:m_fVisibleTime()
  	return entity.get_prop(self.eid, "m_fVisibleTime")
  end
  
  --- @return any
  function Entity:m_fRechargeTime()
  	return entity.get_prop(self.eid, "m_fRechargeTime")
  end
  
  --- @return any
  function Entity:m_flDisplayValue()
  	return entity.get_prop(self.eid, "m_flDisplayValue")
  end
  
  --- @return any
  function Entity:m_nRPM()
  	return entity.get_prop(self.eid, "m_nRPM")
  end
  
  --- @return any
  function Entity:m_flThrottle()
  	return entity.get_prop(self.eid, "m_flThrottle")
  end
  
  --- @return any
  function Entity:m_nBoostTimeLeft()
  	return entity.get_prop(self.eid, "m_nBoostTimeLeft")
  end
  
  --- @return any
  function Entity:m_nHasBoost()
  	return entity.get_prop(self.eid, "m_nHasBoost")
  end
  
  --- @return any
  function Entity:m_nScannerDisabledWeapons()
  	return entity.get_prop(self.eid, "m_nScannerDisabledWeapons")
  end
  
  --- @return any
  function Entity:m_nScannerDisabledVehicle()
  	return entity.get_prop(self.eid, "m_nScannerDisabledVehicle")
  end
  
  --- @return any
  function Entity:m_bEnterAnimOn()
  	return entity.get_prop(self.eid, "m_bEnterAnimOn")
  end
  
  --- @return any
  function Entity:m_bExitAnimOn()
  	return entity.get_prop(self.eid, "m_bExitAnimOn")
  end
  
  --- @return any
  function Entity:m_bUnableToFire()
  	return entity.get_prop(self.eid, "m_bUnableToFire")
  end
  
  --- @return Vector3
  function Entity:m_vecEyeExitEndpoint()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEyeExitEndpoint"))
  end
  
  --- @return any
  function Entity:m_bHasGun()
  	return entity.get_prop(self.eid, "m_bHasGun")
  end
  
  --- @return Vector3
  function Entity:m_vecGunCrosshair()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecGunCrosshair"))
  end
  
  --- @return any
  function Entity:m_bHeadlightIsOn()
  	return entity.get_prop(self.eid, "m_bHeadlightIsOn")
  end
  
  --- @return any
  function Entity:m_iCurrentMaxRagdollCount()
  	return entity.get_prop(self.eid, "m_iCurrentMaxRagdollCount")
  end
  
  --- @return any
  function Entity:m_ragAngles()
  	return entity.get_prop(self.eid, "m_ragAngles")
  end
  
  --- @return any
  function Entity:m_ragPos()
  	return entity.get_prop(self.eid, "m_ragPos")
  end
  
  --- @return any
  function Entity:m_hUnragdoll()
  	return entity.get_prop(self.eid, "m_hUnragdoll")
  end
  
  --- @return any
  function Entity:m_flBlendWeight()
  	return entity.get_prop(self.eid, "m_flBlendWeight")
  end
  
  --- @return any
  function Entity:m_nOverlaySequence()
  	return entity.get_prop(self.eid, "m_nOverlaySequence")
  end
  
  --- @return any
  function Entity:m_boneIndexAttached()
  	return entity.get_prop(self.eid, "m_boneIndexAttached")
  end
  
  --- @return any
  function Entity:m_ragdollAttachedObjectIndex()
  	return entity.get_prop(self.eid, "m_ragdollAttachedObjectIndex")
  end
  
  --- @return any
  function Entity:m_attachmentPointBoneSpace()
  	return entity.get_prop(self.eid, "m_attachmentPointBoneSpace")
  end
  
  --- @return any
  function Entity:m_attachmentPointRagdollSpace()
  	return entity.get_prop(self.eid, "m_attachmentPointRagdollSpace")
  end
  
  --- @return any
  function Entity:m_hStartPoint()
  	return entity.get_prop(self.eid, "m_hStartPoint")
  end
  
  --- @return any
  function Entity:m_hEndPoint()
  	return entity.get_prop(self.eid, "m_hEndPoint")
  end
  
  --- @return any
  function Entity:m_iStartAttachment()
  	return entity.get_prop(self.eid, "m_iStartAttachment")
  end
  
  --- @return any
  function Entity:m_iEndAttachment()
  	return entity.get_prop(self.eid, "m_iEndAttachment")
  end
  
  --- @return any
  function Entity:m_Slack()
  	return entity.get_prop(self.eid, "m_Slack")
  end
  
  --- @return any
  function Entity:m_RopeLength()
  	return entity.get_prop(self.eid, "m_RopeLength")
  end
  
  --- @return any
  function Entity:m_fLockedPoints()
  	return entity.get_prop(self.eid, "m_fLockedPoints")
  end
  
  --- @return Angle
  function Entity:m_nChangeCount()
  	return Angle:new(entity.get_prop(self.eid, "m_nChangeCount"))
  end
  
  --- @return any
  function Entity:m_RopeFlags()
  	return entity.get_prop(self.eid, "m_RopeFlags")
  end
  
  --- @return any
  function Entity:m_nSegments()
  	return entity.get_prop(self.eid, "m_nSegments")
  end
  
  --- @return any
  function Entity:m_bConstrainBetweenEndpoints()
  	return entity.get_prop(self.eid, "m_bConstrainBetweenEndpoints")
  end
  
  --- @return any
  function Entity:m_iRopeMaterialModelIndex()
  	return entity.get_prop(self.eid, "m_iRopeMaterialModelIndex")
  end
  
  --- @return any
  function Entity:m_Subdiv()
  	return entity.get_prop(self.eid, "m_Subdiv")
  end
  
  --- @return any
  function Entity:m_TextureScale()
  	return entity.get_prop(self.eid, "m_TextureScale")
  end
  
  --- @return any
  function Entity:m_Width()
  	return entity.get_prop(self.eid, "m_Width")
  end
  
  --- @return any
  function Entity:m_flScrollSpeed()
  	return entity.get_prop(self.eid, "m_flScrollSpeed")
  end
  
  --- @return any
  function Entity:m_iDefaultRopeMaterialModelIndex()
  	return entity.get_prop(self.eid, "m_iDefaultRopeMaterialModelIndex")
  end
  
  --- @return any
  function Entity:m_nSceneStringIndex()
  	return entity.get_prop(self.eid, "m_nSceneStringIndex")
  end
  
  --- @return any
  function Entity:m_bIsPlayingBack()
  	return entity.get_prop(self.eid, "m_bIsPlayingBack")
  end
  
  --- @return any
  function Entity:m_bPaused()
  	return entity.get_prop(self.eid, "m_bPaused")
  end
  
  --- @return any
  function Entity:m_bMultiplayer()
  	return entity.get_prop(self.eid, "m_bMultiplayer")
  end
  
  --- @return any
  function Entity:m_flForceClientTime()
  	return entity.get_prop(self.eid, "m_flForceClientTime")
  end
  
  --- @return any
  function Entity:m_shadowColor()
  	return entity.get_prop(self.eid, "m_shadowColor")
  end
  
  --- @return any
  function Entity:m_flShadowMaxDist()
  	return entity.get_prop(self.eid, "m_flShadowMaxDist")
  end
  
  --- @return any
  function Entity:m_bDisableShadows()
  	return entity.get_prop(self.eid, "m_bDisableShadows")
  end
  
  --- @return any
  function Entity:m_bEnableLocalLightShadows()
  	return entity.get_prop(self.eid, "m_bEnableLocalLightShadows")
  end
  
  --- @return any
  function Entity:m_szDisplayText()
  	return entity.get_prop(self.eid, "m_szDisplayText")
  end
  
  --- @return any
  function Entity:m_szSlideshowDirectory()
  	return entity.get_prop(self.eid, "m_szSlideshowDirectory")
  end
  
  --- @return any
  function Entity:m_fMinSlideTime()
  	return entity.get_prop(self.eid, "m_fMinSlideTime")
  end
  
  --- @return any
  function Entity:m_fMaxSlideTime()
  	return entity.get_prop(self.eid, "m_fMaxSlideTime")
  end
  
  --- @return any
  function Entity:m_iCycleType()
  	return entity.get_prop(self.eid, "m_iCycleType")
  end
  
  --- @return any
  function Entity:m_bNoListRepeats()
  	return entity.get_prop(self.eid, "m_bNoListRepeats")
  end
  
  --- @return any
  function Entity:m_bDidSmokeEffect()
  	return entity.get_prop(self.eid, "m_bDidSmokeEffect")
  end
  
  --- @return any
  function Entity:m_nSmokeEffectTickBegin()
  	return entity.get_prop(self.eid, "m_nSmokeEffectTickBegin")
  end
  
  --- @return any
  function Entity:m_SpreadSpeed()
  	return entity.get_prop(self.eid, "m_SpreadSpeed")
  end
  
  --- @return any
  function Entity:m_Speed()
  	return entity.get_prop(self.eid, "m_Speed")
  end
  
  --- @return any
  function Entity:m_StartSize()
  	return entity.get_prop(self.eid, "m_StartSize")
  end
  
  --- @return any
  function Entity:m_EndSize()
  	return entity.get_prop(self.eid, "m_EndSize")
  end
  
  --- @return any
  function Entity:m_Rate()
  	return entity.get_prop(self.eid, "m_Rate")
  end
  
  --- @return any
  function Entity:m_JetLength()
  	return entity.get_prop(self.eid, "m_JetLength")
  end
  
  --- @return any
  function Entity:m_flBaseSpread()
  	return entity.get_prop(self.eid, "m_flBaseSpread")
  end
  
  --- @return any
  function Entity:m_flRollSpeed()
  	return entity.get_prop(self.eid, "m_flRollSpeed")
  end
  
  --- @return any
  function Entity:m_vWind()
  	return entity.get_prop(self.eid, "m_vWind")
  end
  
  --- @return any
  function Entity:m_flTwist()
  	return entity.get_prop(self.eid, "m_flTwist")
  end
  
  --- @return any
  function Entity:m_iMaterialModel()
  	return entity.get_prop(self.eid, "m_iMaterialModel")
  end
  
  --- @return any
  function Entity:m_flLightScale()
  	return entity.get_prop(self.eid, "m_flLightScale")
  end
  
  --- @return any
  function Entity:m_hAttachedToEntity()
  	return entity.get_prop(self.eid, "m_hAttachedToEntity")
  end
  
  --- @return any
  function Entity:m_flSpriteScale()
  	return entity.get_prop(self.eid, "m_flSpriteScale")
  end
  
  --- @return any
  function Entity:m_flSpriteFramerate()
  	return entity.get_prop(self.eid, "m_flSpriteFramerate")
  end
  
  --- @return any
  function Entity:m_flBrightnessTime()
  	return entity.get_prop(self.eid, "m_flBrightnessTime")
  end
  
  --- @return any
  function Entity:m_nBrightness()
  	return entity.get_prop(self.eid, "m_nBrightness")
  end
  
  --- @return any
  function Entity:m_bWorldSpaceScale()
  	return entity.get_prop(self.eid, "m_bWorldSpaceScale")
  end
  
  --- @return any
  function Entity:m_flLifeTime()
  	return entity.get_prop(self.eid, "m_flLifeTime")
  end
  
  --- @return any
  function Entity:m_flStartWidth()
  	return entity.get_prop(self.eid, "m_flStartWidth")
  end
  
  --- @return any
  function Entity:m_flEndWidth()
  	return entity.get_prop(self.eid, "m_flEndWidth")
  end
  
  --- @return any
  function Entity:m_flStartWidthVariance()
  	return entity.get_prop(self.eid, "m_flStartWidthVariance")
  end
  
  --- @return any
  function Entity:m_flTextureRes()
  	return entity.get_prop(self.eid, "m_flTextureRes")
  end
  
  --- @return any
  function Entity:m_flMinFadeLength()
  	return entity.get_prop(self.eid, "m_flMinFadeLength")
  end
  
  --- @return any
  function Entity:m_hInitBaseAnimating()
  	return entity.get_prop(self.eid, "m_hInitBaseAnimating")
  end
  
  --- @return any
  function Entity:m_bShatter()
  	return entity.get_prop(self.eid, "m_bShatter")
  end
  
  --- @return any
  function Entity:m_nShatterFlags()
  	return entity.get_prop(self.eid, "m_nShatterFlags")
  end
  
  --- @return any
  function Entity:m_vShatterPosition()
  	return entity.get_prop(self.eid, "m_vShatterPosition")
  end
  
  --- @return any
  function Entity:m_vShatterForce()
  	return entity.get_prop(self.eid, "m_vShatterForce")
  end
  
  --- @return any
  function Entity:m_bFaceLeft()
  	return entity.get_prop(self.eid, "m_bFaceLeft")
  end
  
  --- @return any
  function Entity:m_clrOverlay()
  	return entity.get_prop(self.eid, "m_clrOverlay")
  end
  
  --- @return any
  function Entity:m_bOn()
  	return entity.get_prop(self.eid, "m_bOn")
  end
  
  --- @return any
  function Entity:m_nSize()
  	return entity.get_prop(self.eid, "m_nSize")
  end
  
  --- @return any
  function Entity:m_nOverlaySize()
  	return entity.get_prop(self.eid, "m_nOverlaySize")
  end
  
  --- @return any
  function Entity:m_nMaterial()
  	return entity.get_prop(self.eid, "m_nMaterial")
  end
  
  --- @return any
  function Entity:m_nOverlayMaterial()
  	return entity.get_prop(self.eid, "m_nOverlayMaterial")
  end
  
  --- @return any
  function Entity:m_TextureName()
  	return entity.get_prop(self.eid, "m_TextureName")
  end
  
  --- @return any
  function Entity:m_flSunDistance()
  	return entity.get_prop(self.eid, "m_flSunDistance")
  end
  
  --- @return any
  function Entity:m_flFOV()
  	return entity.get_prop(self.eid, "m_flFOV")
  end
  
  --- @return any
  function Entity:m_flNorthOffset()
  	return entity.get_prop(self.eid, "m_flNorthOffset")
  end
  
  --- @return any
  function Entity:m_flUpgradeExpirationTime()
  	return entity.get_prop(self.eid, "m_flUpgradeExpirationTime")
  end
  
  --- @return Vector3
  function Entity:m_vecLocalHexFlags()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecLocalHexFlags"))
  end
  
  --- @return any
  function Entity:m_nContractKillGridIndex()
  	return entity.get_prop(self.eid, "m_nContractKillGridIndex")
  end
  
  --- @return any
  function Entity:m_nContractKillGridHighResIndex()
  	return entity.get_prop(self.eid, "m_nContractKillGridHighResIndex")
  end
  
  --- @return any
  function Entity:m_bTabletReceptionIsBlocked()
  	return entity.get_prop(self.eid, "m_bTabletReceptionIsBlocked")
  end
  
  --- @return any
  function Entity:m_flScanProgress()
  	return entity.get_prop(self.eid, "m_flScanProgress")
  end
  
  --- @return any
  function Entity:m_flBootTime()
  	return entity.get_prop(self.eid, "m_flBootTime")
  end
  
  --- @return any
  function Entity:m_flShowMapTime()
  	return entity.get_prop(self.eid, "m_flShowMapTime")
  end
  
  --- @return Vector3
  function Entity:m_vecNotificationIds()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecNotificationIds"))
  end
  
  --- @return Vector3
  function Entity:m_vecNotificationTimestamps()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecNotificationTimestamps"))
  end
  
  --- @return Vector3
  function Entity:m_vecPlayerPositionHistory()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPlayerPositionHistory"))
  end
  
  --- @return any
  function Entity:m_nLastPurchaseIndex()
  	return entity.get_prop(self.eid, "m_nLastPurchaseIndex")
  end
  
  --- @return Vector3
  function Entity:m_vecNearestMetalCratePos()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecNearestMetalCratePos"))
  end
  
  --- @return any
  function Entity:m_iRoundState()
  	return entity.get_prop(self.eid, "m_iRoundState")
  end
  
  --- @return any
  function Entity:m_bInWaitingForPlayers()
  	return entity.get_prop(self.eid, "m_bInWaitingForPlayers")
  end
  
  --- @return any
  function Entity:m_iWinningTeam()
  	return entity.get_prop(self.eid, "m_iWinningTeam")
  end
  
  --- @return any
  function Entity:m_bInOvertime()
  	return entity.get_prop(self.eid, "m_bInOvertime")
  end
  
  --- @return any
  function Entity:m_bInSetup()
  	return entity.get_prop(self.eid, "m_bInSetup")
  end
  
  --- @return any
  function Entity:m_bSwitchedTeamsThisRound()
  	return entity.get_prop(self.eid, "m_bSwitchedTeamsThisRound")
  end
  
  --- @return any
  function Entity:m_bAwaitingReadyRestart()
  	return entity.get_prop(self.eid, "m_bAwaitingReadyRestart")
  end
  
  --- @return any
  function Entity:m_flMapResetTime()
  	return entity.get_prop(self.eid, "m_flMapResetTime")
  end
  
  --- @return any
  function Entity:m_bStopWatch()
  	return entity.get_prop(self.eid, "m_bStopWatch")
  end
  
  --- @return Vector3
  function Entity:m_vecPos()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPos"))
  end
  
  --- @return Vector3
  function Entity:m_vecDir()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecDir"))
  end
  
  --- @return any
  function Entity:m_nStartFrame()
  	return entity.get_prop(self.eid, "m_nStartFrame")
  end
  
  --- @return any
  function Entity:m_nFrameRate()
  	return entity.get_prop(self.eid, "m_nFrameRate")
  end
  
  --- @return any
  function Entity:m_fLife()
  	return entity.get_prop(self.eid, "m_fLife")
  end
  
  --- @return any
  function Entity:m_nFadeLength()
  	return entity.get_prop(self.eid, "m_nFadeLength")
  end
  
  --- @return any
  function Entity:m_nStartEntity()
  	return entity.get_prop(self.eid, "m_nStartEntity")
  end
  
  --- @return any
  function Entity:m_nEndEntity()
  	return entity.get_prop(self.eid, "m_nEndEntity")
  end
  
  --- @return Vector3
  function Entity:m_vecStartPoint()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecStartPoint"))
  end
  
  --- @return Vector3
  function Entity:m_vecEndPoint()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEndPoint"))
  end
  
  --- @return any
  function Entity:m_iEntIndex()
  	return entity.get_prop(self.eid, "m_iEntIndex")
  end
  
  --- @return Vector3
  function Entity:m_vecCenter()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecCenter"))
  end
  
  --- @return any
  function Entity:m_flStartRadius()
  	return entity.get_prop(self.eid, "m_flStartRadius")
  end
  
  --- @return any
  function Entity:m_flEndRadius()
  	return entity.get_prop(self.eid, "m_flEndRadius")
  end
  
  --- @return any
  function Entity:m_nPoints()
  	return entity.get_prop(self.eid, "m_nPoints")
  end
  
  --- @return Vector3
  function Entity:m_vecPoints()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecPoints"))
  end
  
  --- @return any
  function Entity:m_nSprayModel()
  	return entity.get_prop(self.eid, "m_nSprayModel")
  end
  
  --- @return any
  function Entity:m_nDropModel()
  	return entity.get_prop(self.eid, "m_nDropModel")
  end
  
  --- @return any
  function Entity:m_nAmount()
  	return entity.get_prop(self.eid, "m_nAmount")
  end
  
  --- @return Vector3
  function Entity:m_vecSize()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecSize"))
  end
  
  --- @return any
  function Entity:m_nRandomization()
  	return entity.get_prop(self.eid, "m_nRandomization")
  end
  
  --- @return any
  function Entity:m_nCount()
  	return entity.get_prop(self.eid, "m_nCount")
  end
  
  --- @return any
  function Entity:m_fTime()
  	return entity.get_prop(self.eid, "m_fTime")
  end
  
  --- @return any
  function Entity:m_nIndex()
  	return entity.get_prop(self.eid, "m_nIndex")
  end
  
  --- @return any
  function Entity:m_fHeight()
  	return entity.get_prop(self.eid, "m_fHeight")
  end
  
  --- @return any
  function Entity:m_flWaterZ()
  	return entity.get_prop(self.eid, "m_flWaterZ")
  end
  
  --- @return any
  function Entity:m_nLifeTime()
  	return entity.get_prop(self.eid, "m_nLifeTime")
  end
  
  --- @return any
  function Entity:m_flSize()
  	return entity.get_prop(self.eid, "m_flSize")
  end
  
  --- @return any
  function Entity:m_flSpeed()
  	return entity.get_prop(self.eid, "m_flSpeed")
  end
  
  --- @return any
  function Entity:m_fRadius()
  	return entity.get_prop(self.eid, "m_fRadius")
  end
  
  --- @return any
  function Entity:m_fDecay()
  	return entity.get_prop(self.eid, "m_fDecay")
  end
  
  --- @return any
  function Entity:m_vAngles()
  	return entity.get_prop(self.eid, "m_vAngles")
  end
  
  --- @return any
  function Entity:m_flMagnitude()
  	return entity.get_prop(self.eid, "m_flMagnitude")
  end
  
  --- @return any
  function Entity:m_nAttachmentIndex()
  	return entity.get_prop(self.eid, "m_nAttachmentIndex")
  end
  
  --- @return any
  function Entity:m_nSurfaceProp()
  	return entity.get_prop(self.eid, "m_nSurfaceProp")
  end
  
  --- @return any
  function Entity:m_iEffectName()
  	return entity.get_prop(self.eid, "m_iEffectName")
  end
  
  --- @return any
  function Entity:m_nDamageType()
  	return entity.get_prop(self.eid, "m_nDamageType")
  end
  
  --- @return any
  function Entity:m_nHitBox()
  	return entity.get_prop(self.eid, "m_nHitBox")
  end
  
  --- @return any
  function Entity:m_nOtherEntIndex()
  	return entity.get_prop(self.eid, "m_nOtherEntIndex")
  end
  
  --- @return any
  function Entity:m_nColor()
  	return entity.get_prop(self.eid, "m_nColor")
  end
  
  --- @return any
  function Entity:m_bPositionsAreRelativeToEntity()
  	return entity.get_prop(self.eid, "m_bPositionsAreRelativeToEntity")
  end
  
  --- @return any
  function Entity:m_bExplosive()
  	return entity.get_prop(self.eid, "m_bExplosive")
  end
  
  --- @return any
  function Entity:m_fScale()
  	return entity.get_prop(self.eid, "m_fScale")
  end
  
  --- @return any
  function Entity:m_chMaterialType()
  	return entity.get_prop(self.eid, "m_chMaterialType")
  end
  
  --- @return any
  function Entity:m_nRadius()
  	return entity.get_prop(self.eid, "m_nRadius")
  end
  
  --- @return any
  function Entity:m_weapon()
  	return entity.get_prop(self.eid, "m_weapon")
  end
  
  --- @return any
  function Entity:m_iMode()
  	return entity.get_prop(self.eid, "m_iMode")
  end
  
  --- @return any
  function Entity:m_iSeed()
  	return entity.get_prop(self.eid, "m_iSeed")
  end
  
  --- @return any
  function Entity:m_iPlayer()
  	return entity.get_prop(self.eid, "m_iPlayer")
  end
  
  --- @return any
  function Entity:m_fInaccuracy()
  	return entity.get_prop(self.eid, "m_fInaccuracy")
  end
  
  --- @return any
  function Entity:m_fSpread()
  	return entity.get_prop(self.eid, "m_fSpread")
  end
  
  --- @return any
  function Entity:m_nItemDefIndex()
  	return entity.get_prop(self.eid, "m_nItemDefIndex")
  end
  
  --- @return any
  function Entity:m_iSoundType()
  	return entity.get_prop(self.eid, "m_iSoundType")
  end
  
  --- @return any
  function Entity:m_nCurrent()
  	return entity.get_prop(self.eid, "m_nCurrent")
  end
  
  --- @return any
  function Entity:m_iEntity()
  	return entity.get_prop(self.eid, "m_iEntity")
  end
  
  --- @return any
  function Entity:m_nReversed()
  	return entity.get_prop(self.eid, "m_nReversed")
  end
  
  --- @return Vector3
  function Entity:m_vecAngles()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecAngles"))
  end
  
  --- @return any
  function Entity:m_nEffects()
  	return entity.get_prop(self.eid, "m_nEffects")
  end
  
  --- @return any
  function Entity:m_option()
  	return entity.get_prop(self.eid, "m_option")
  end
  
  --- @return any
  function Entity:m_iEvent()
  	return entity.get_prop(self.eid, "m_iEvent")
  end
  
  --- @return any
  function Entity:m_nData()
  	return entity.get_prop(self.eid, "m_nData")
  end
  
  --- @return any
  function Entity:m_flDistance()
  	return entity.get_prop(self.eid, "m_flDistance")
  end
  
  --- @return any
  function Entity:m_iAttachToClient()
  	return entity.get_prop(self.eid, "m_iAttachToClient")
  end
  
  --- @return Vector3
  function Entity:m_vecForcePos()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecForcePos"))
  end
  
  --- @return any
  function Entity:m_flHeight()
  	return entity.get_prop(self.eid, "m_flHeight")
  end
  
  --- @return any
  function Entity:m_flShardSize()
  	return entity.get_prop(self.eid, "m_flShardSize")
  end
  
  --- @return Vector3
  function Entity:m_vecEnd()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEnd"))
  end
  
  --- @return any
  function Entity:m_SoundName()
  	return entity.get_prop(self.eid, "m_SoundName")
  end
  
  --- @return any
  function Entity:m_iszSpriteName()
  	return entity.get_prop(self.eid, "m_iszSpriteName")
  end
  
  --- @return any
  function Entity:m_nTrailLength()
  	return entity.get_prop(self.eid, "m_nTrailLength")
  end
  
  --- @return any
  function Entity:m_fNoise()
  	return entity.get_prop(self.eid, "m_fNoise")
  end
  
  --- @return any
  function Entity:m_WithProxy()
  	return entity.get_prop(self.eid, "m_WithProxy")
  end
  
  --- @return any
  function Entity:m_nSoundOperator()
  	return entity.get_prop(self.eid, "m_nSoundOperator")
  end
  
  --- @return any
  function Entity:m_nPanelName()
  	return entity.get_prop(self.eid, "m_nPanelName")
  end
  
  --- @return any
  function Entity:m_fScreenFlags()
  	return entity.get_prop(self.eid, "m_fScreenFlags")
  end
  
  --- @return any
  function Entity:m_hPlayerOwner()
  	return entity.get_prop(self.eid, "m_hPlayerOwner")
  end
  
  --- @return any
  function Entity:m_iActiveIssueIndex()
  	return entity.get_prop(self.eid, "m_iActiveIssueIndex")
  end
  
  --- @return any
  function Entity:m_iOnlyTeamToVote()
  	return entity.get_prop(self.eid, "m_iOnlyTeamToVote")
  end
  
  --- @return any
  function Entity:m_nPotentialVotes()
  	return entity.get_prop(self.eid, "m_nPotentialVotes")
  end
  
  --- @return any
  function Entity:m_bIsYesNoVote()
  	return entity.get_prop(self.eid, "m_bIsYesNoVote")
  end
  
  --- @return any
  function Entity:m_flCheapWaterStartDistance()
  	return entity.get_prop(self.eid, "m_flCheapWaterStartDistance")
  end
  
  --- @return any
  function Entity:m_flCheapWaterEndDistance()
  	return entity.get_prop(self.eid, "m_flCheapWaterEndDistance")
  end
  
  --- @return any
  function Entity:m_reloadState()
  	return entity.get_prop(self.eid, "m_reloadState")
  end
  
  --- @return any
  function Entity:m_fFireTime()
  	return entity.get_prop(self.eid, "m_fFireTime")
  end
  
  --- @return any
  function Entity:m_WorldMins()
  	return entity.get_prop(self.eid, "m_WorldMins")
  end
  
  --- @return any
  function Entity:m_WorldMaxs()
  	return entity.get_prop(self.eid, "m_WorldMaxs")
  end
  
  --- @return any
  function Entity:m_bStartDark()
  	return entity.get_prop(self.eid, "m_bStartDark")
  end
  
  --- @return any
  function Entity:m_flMaxOccludeeArea()
  	return entity.get_prop(self.eid, "m_flMaxOccludeeArea")
  end
  
  --- @return any
  function Entity:m_flMinOccluderArea()
  	return entity.get_prop(self.eid, "m_flMinOccluderArea")
  end
  
  --- @return any
  function Entity:m_flMaxPropScreenSpaceWidth()
  	return entity.get_prop(self.eid, "m_flMaxPropScreenSpaceWidth")
  end
  
  --- @return any
  function Entity:m_flMinPropScreenSpaceWidth()
  	return entity.get_prop(self.eid, "m_flMinPropScreenSpaceWidth")
  end
  
  --- @return any
  function Entity:m_iszDetailSpriteMaterial()
  	return entity.get_prop(self.eid, "m_iszDetailSpriteMaterial")
  end
  
  --- @return any
  function Entity:m_bColdWorld()
  	return entity.get_prop(self.eid, "m_bColdWorld")
  end
  
  --- @return any
  function Entity:m_szDisplayTextOption()
  	return entity.get_prop(self.eid, "m_szDisplayTextOption")
  end
  
  --- @return any
  function Entity:m_szFont()
  	return entity.get_prop(self.eid, "m_szFont")
  end
  
  --- @return any
  function Entity:m_iTextPanelWidth()
  	return entity.get_prop(self.eid, "m_iTextPanelWidth")
  end
  
  --- @return any
  function Entity:m_clrText()
  	return entity.get_prop(self.eid, "m_clrText")
  end
  
  --- @return any
  function Entity:m_ParticleLifetime()
  	return entity.get_prop(self.eid, "m_ParticleLifetime")
  end
  
  --- @return any
  function Entity:m_StopEmitTime()
  	return entity.get_prop(self.eid, "m_StopEmitTime")
  end
  
  --- @return any
  function Entity:m_MinSpeed()
  	return entity.get_prop(self.eid, "m_MinSpeed")
  end
  
  --- @return any
  function Entity:m_MaxSpeed()
  	return entity.get_prop(self.eid, "m_MaxSpeed")
  end
  
  --- @return any
  function Entity:m_MinDirectedSpeed()
  	return entity.get_prop(self.eid, "m_MinDirectedSpeed")
  end
  
  --- @return any
  function Entity:m_MaxDirectedSpeed()
  	return entity.get_prop(self.eid, "m_MaxDirectedSpeed")
  end
  
  --- @return any
  function Entity:m_SpawnRadius()
  	return entity.get_prop(self.eid, "m_SpawnRadius")
  end
  
  --- @return any
  function Entity:m_Opacity()
  	return entity.get_prop(self.eid, "m_Opacity")
  end
  
  --- @return any
  function Entity:m_flSpawnTime()
  	return entity.get_prop(self.eid, "m_flSpawnTime")
  end
  
  --- @return any
  function Entity:m_FadeStartTime()
  	return entity.get_prop(self.eid, "m_FadeStartTime")
  end
  
  --- @return any
  function Entity:m_FadeEndTime()
  	return entity.get_prop(self.eid, "m_FadeEndTime")
  end
  
  --- @return any
  function Entity:m_MinColor()
  	return entity.get_prop(self.eid, "m_MinColor")
  end
  
  --- @return any
  function Entity:m_MaxColor()
  	return entity.get_prop(self.eid, "m_MaxColor")
  end
  
  --- @return any
  function Entity:m_CurrentStage()
  	return entity.get_prop(self.eid, "m_CurrentStage")
  end
  
  --- @return any
  function Entity:m_StartColor()
  	return entity.get_prop(self.eid, "m_StartColor")
  end
  
  --- @return any
  function Entity:m_EndColor()
  	return entity.get_prop(self.eid, "m_EndColor")
  end
  
  --- @return any
  function Entity:m_bDamaged()
  	return entity.get_prop(self.eid, "m_bDamaged")
  end
  
  --- @return any
  function Entity:m_flFlareScale()
  	return entity.get_prop(self.eid, "m_flFlareScale")
  end
  
  --- @return any
  function Entity:m_flSpawnRate()
  	return entity.get_prop(self.eid, "m_flSpawnRate")
  end
  
  --- @return any
  function Entity:m_flParticleLifetime()
  	return entity.get_prop(self.eid, "m_flParticleLifetime")
  end
  
  --- @return any
  function Entity:m_flSpawnRadius()
  	return entity.get_prop(self.eid, "m_flSpawnRadius")
  end
  
  --- @return any
  function Entity:m_bDontRemove()
  	return entity.get_prop(self.eid, "m_bDontRemove")
  end
  
  --- @return Vector3
  function Entity:m_vecEndColor()
  	return Vector3:new(entity.get_prop(self.eid, "m_vecEndColor"))
  end
  
  return Nyx.class(
  	"Nyx/Entity",
  	Entity
  )
  --endregion
end
package.preload["gamesense/Nyx/Entity"] = function() return return_values["Entity"] end
--endregion

--region Callbacks
libraries["Callbacks"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  local Angle, _, Vector3 = VectorsAngles.Angle, VectorsAngles.Vector2, VectorsAngles.Vector3
  local Player = require "gamesense/Nyx/Player"
  local Entity = require "gamesense/Nyx/Entity"
  
  --region Callbacks
  --- @class Callback : Abstract
  local Callbacks = {}
  
  --- Add a callback event type.
  --- @param eventName string
  --- @param callback function
  --- @param dataCallback fun(data: table<any, any>): void
  --- @return void
  function Callbacks.addCallback(eventName, callback, dataCallback)
  	client.set_event_callback(eventName, function(data)
  		local callbackEventData = dataCallback(data)
  		local result = callback(callbackEventData)
  
  		if type(callbackEventData) == "table" and callbackEventData.sync ~= nil then
  			callbackEventData:sync()
  		end
  
  		return result
  	end)
  end
  
  --region events: gamesense
  --region OverrideViewEvent
  --- @class OverrideViewData
  --- @field x number
  --- @field y number
  --- @field z number
  --- @field pitch number
  --- @field yaw number
  --- @field fov number
  
  --- @class OverrideViewEvent : Class
  --- @field cameraPosition Vector3
  --- @field cameraAngles Angle
  --- @field fov number
  --- @field raw OverrideViewData
  local OverrideViewEvent = {}
  
  --- @param fields OverrideViewEvent
  --- @return OverrideViewEvent
  function OverrideViewEvent:new(fields)
  	return Nyx.new(self, fields)
  end
  
  --- @return void
  function OverrideViewEvent:sync()
  	self.raw.x, self.raw.y, self.raw.z = self.cameraPosition:unpack()
  	self.raw.pitch, self.raw.yaw = self.cameraAngles:unpack()
  	self.raw.fov = self.fov
  end
  
  Nyx.class(
  	"Nyx/OverrideViewEvent",
  	OverrideViewEvent
  )
  --endregion
  
  --- @param callback fun(data: OverrideViewEvent): void
  --- @return void
  function Callbacks.overrideView(callback)
  	Callbacks.addCallback("override_view", callback, function(data)
  		return OverrideViewEvent:new({
  			cameraPosition = Vector3:new(data.x, data.y, data.z),
  			cameraAngles =  Angle:new(data.pitch, data.yaw),
  			fov = data.fov,
  			raw = data
  		})
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.preConfigLoad(callback)
  	Callbacks.addCallback("pre_config_load", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.postConfigLoad(callback)
  	Callbacks.addCallback("post_config_load", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.preConfigSave(callback)
  	Callbacks.addCallback("pre_config_save", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.postConfigSave(callback)
  	Callbacks.addCallback("post_config_save", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.postConfigSave(callback)
  	Callbacks.addCallback("post_config_save", callback, function()
  		return nil
  	end)
  end
  
  --- @class OutputEvent
  --- @field text string
  --- @field r number
  --- @field g number
  --- @field b number
  --- @field a number
  --- @param callback fun(data: output_event_c): void
  --- @return void
  function Callbacks.output(callback)
  	Callbacks.addCallback("output", callback, function(data)
  		return data
  	end)
  end
  
  --- @class IndicatorEvent
  --- @field text string
  --- @field r number
  --- @field g number
  --- @field b number
  --- @field a number
  --- @param callback fun(data: output_event_c): void
  --- @return void
  function Callbacks.indicator(callback)
  	Callbacks.addCallback("indicator", callback, function(data)
  		return data
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.shutdown(callback)
  	Callbacks.addCallback("shutdown", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.init(callback)
  	callback()
  
  	client.set_event_callback("level_init", function()
  		callback()
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.levelInit(callback)
  	Callbacks.addCallback("level_init", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.paint(callback)
  	Callbacks.addCallback("paint", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.paintUi(callback)
  	Callbacks.addCallback("paint_ui", callback, function()
  		return nil
  	end)
  end
  
  --- @class AimFireEvent
  --- @field id number
  --- @field target Player
  --- @field origin Vector3
  --- @field hit_chance number
  --- @field hitgroup number
  --- @field damage number
  --- @field backtrack number
  --- @field boosted boolean
  --- @field high_priority boolean
  --- @field interpolated boolean
  --- @field extrapolated boolean
  --- @field teleported boolean
  --- @field tick number
  --- @param callback fun(data: aim_fire_event_c): void
  --- @return void
  function Callbacks.aimFire(callback)
  	Callbacks.addCallback("aim_fire", callback, function(data)
  		return {
  			id = data.id,
  			target = Player:new(data.target),
  			origin = Vector3:new(data.x, data.y, data.z),
  			hit_chance = data.hit_chance,
  			hitgroup = data.hitgroup,
  			damage = data.damage,
  			backtrack = data.backtrack,
  			boosted = data.boosted,
  			high_priority = data.high_priority,
  			interpolated = data.interpolated,
  			extrapolated = data.extrapolated,
  			teleported = data.teleported,
  			tick = data.tick
  		}
  	end)
  end
  
  --- @class AimHitEvent
  --- @field id number
  --- @field target Player
  --- @field hit_chance number
  --- @field hitgroup number
  --- @field damage number
  --- @param callback fun(data: aim_hit_event_c): void
  --- @return void
  function Callbacks.aimHit(callback)
  	Callbacks.addCallback("aim_hit", callback, function(data)
  		return {
  			id = data.id,
  			target = Player:new(data.target),
  			hit_chance = data.hit_chance,
  			hitgroup = data.hitgroup,
  			damage = data.damage,
  		}
  	end)
  end
  
  --- @class AimMissEvent
  --- @field id number
  --- @field target Player
  --- @field hit_chance number
  --- @field hitgroup number
  --- @field reason number
  --- @param callback fun(data: aim_miss_event_c): void
  --- @return void
  function Callbacks.aimMiss(callback)
  	Callbacks.addCallback("aim_miss", callback, function(data)
  		return {
  			id = data.id,
  			target = Player:new(data.target),
  			hit_chance = data.hit_chance,
  			hitgroup = data.hitgroup,
  			reason = data.reason,
  		}
  	end)
  end
  
  --- @class SetupCommandEvent
  --- @field chokedcommands number
  --- @field command_number number
  --- @field pitch number
  --- @field yaw number
  --- @field forwardmove number
  --- @field sidemove number
  --- @field move_yaw number
  --- @field allow_send_packet boolean
  --- @field in_attack boolean
  --- @field in_jump boolean
  --- @field in_duck boolean
  --- @field in_forward boolean
  --- @field in_back boolean
  --- @field in_use boolean
  --- @field in_cancel boolean
  --- @field in_left boolean
  --- @field in_right boolean
  --- @field in_moveleft boolean
  --- @field in_moveright boolean
  --- @field in_attack2 boolean
  --- @field in_run boolean
  --- @field in_reload boolean
  --- @field in_alt1 boolean
  --- @field in_alt2 boolean
  --- @field in_score boolean
  --- @field in_speed boolean
  --- @field in_walk boolean
  --- @field in_zoom boolean
  --- @field in_weapon1 boolean
  --- @field in_weapon2 boolean
  --- @field in_bullrush boolean
  --- @field in_grenade1 boolean
  --- @field in_grenade2 boolean
  --- @field in_attack3 boolean
  --- @field weaponselect any
  --- @field weaponsubtype any
  --- @param callback fun(data: setup_command_event_c): void
  --- @return void
  function Callbacks.setupCommand(callback)
  	Callbacks.addCallback("setup_command", callback, function(data)
  		return data
  	end)
  end
  
  --- @class RunCommandEvent
  --- @field chokedcommands number
  --- @field command_number number
  --- @param callback fun(data: run_command_event_c): void
  --- @return void
  function Callbacks.runCommand(callback)
  	Callbacks.addCallback("run_command", callback, function(data)
  		return data
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.netUpdateEnd(callback)
  	Callbacks.addCallback("net_update_end", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.netUpdateStart(callback)
  	Callbacks.addCallback("net_update_start", callback, function()
  		return nil
  	end)
  end
  
  --- @class PredictCommandEvent
  --- @field command_number number
  --- @param callback fun(data: predict_command_event_c): void
  --- @return void
  function Callbacks.predictCommand(callback)
  	Callbacks.addCallback("predict_command", callback, function(data)
  		return data
  	end)
  end
  
  --- @param callback fun(data: string): void
  --- @return void
  function Callbacks.consoleInput(callback)
  	Callbacks.addCallback("console_input", callback, function(data)
  		return data
  	end)
  end
  
  --- @class PlayerChatEvent
  --- @field sender Player
  --- @field text string
  --- @field teamonly boolean
  --- @field name string
  --- @param callback fun(data: PlayerChatEvent): void
  --- @return void
  function Callbacks.playerChat(callback)
  	Callbacks.addCallback("player_chat", callback, function(data)
  		return {
  			sender = Player:new(data.entity),
  			text = data.text,
  			teamonly = data.teamonly,
  			name = data.name
  		}
  	end)
  end
  
  --- @class StringCmdEvent
  --- @field text string
  --- @param callback fun(data: string_cmd_event_c): void
  --- @return void
  function Callbacks.stringCmd(callback)
  	Callbacks.addCallback("string_cmd", callback, function(data)
  		return data
  	end)
  end
  --endregion
  
  --region events: source / csgo
  --- @class PlayerPingEvent
  --- @field user Player
  --- @field urgent boolean
  --- @field origin Vector3
  --- @param callback fun(data: PlayerPingEvent): void
  --- @return void
  function Callbacks.playerPing(callback)
  	Callbacks.addCallback("player_ping", callback, function(data)
  		return {
  			user = Player:newFromUserid(data.userid),
  			urgent = data.urgent,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class PlayerConnectFullEvent
  --- @field user Player
  --- @param callback fun(data: PlayerConnectFullEvent): void
  --- @return void
  function Callbacks.playerConnectFull(callback)
  	Callbacks.addCallback("Playerconnect_full", callback, function(data)
  		return {
  			user = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class PlayerDeathEvent
  --- @field assistedflash boolean
  --- @field assister Player
  --- @field attacker Player
  --- @field dominated number
  --- @field headshot boolean
  --- @field noreplay boolean
  --- @field penetrated number
  --- @field revenge number
  --- @field victim Player
  --- @field weapon string
  --- @field weapon_fauxitemid string
  --- @field weapon_itemid string
  --- @field weapon_originalowner_xuid string
  --- @field wipe number
  --- @param callback fun(data: PlayerDeathEvent): void
  --- @return void
  function Callbacks.playerDeath(callback)
  	Callbacks.addCallback("player_death", callback, function(data)
  		return {
  			assistedflash = data.assistedflash,
  			assister = Player:newFromUserid(data.assister),
  			attacker = Player:newFromUserid(data.attacker),
  			dominated = data.dominated,
  			headshot = data.headshot,
  			noreplay = data.noreplay,
  			penetrated = data.penetrated,
  			revenge = data.revenge,
  			victim = Player:newFromUserid(data.userid),
  			weapon = data.weapon,
  			weapon_fauxitemid = data.weapon_fauxitemid,
  			weapon_itemid = data.weapon_itemid,
  			weapon_originalowner_xuid = data.weapon_originalowner_xuid,
  			wipe = data.wipe
  		}
  	end)
  end
  
  --- @class OtherDeathEvent
  --- @field otherid number
  --- @field othertype string
  --- @field attacker Player
  --- @field weapon string
  --- @field weapon_itemid string
  --- @field weapon_fauxitemid string
  --- @field weapon_originalowner_xuid string
  --- @field headshot boolean
  --- @field penetrated number
  --- @param callback fun(data: OtherDeathEvent): void
  --- @return void
  function Callbacks.otherDeath(callback)
  	Callbacks.addCallback("other_death", callback, function(data)
  		return {
  			otherid = data.otherid,
  			othertype = data.othertype,
  			attacker = Player:newFromUserid(data.attacker),
  			weapon = data.weapon,
  			weapon_itemid = data.weapon_itemid,
  			weapon_fauxitemid = data.weapon_fauxitemid,
  			weapon_originalowner_xuid = data.weapon_originalowner_xuid,
  			headshot = data.headshot,
  			penetrated = data.penetrated
  		}
  	end)
  end
  
  --- @class PlayerHurtEvent
  --- @field victim Player
  --- @field attacker Player
  --- @field health number
  --- @field armor number
  --- @field weapon string
  --- @field dmg_health number
  --- @field dmg_armor number
  --- @field hitgroup number
  --- @param callback fun(data: PlayerHurtEvent): void
  --- @return void
  function Callbacks.playerHurt(callback)
  	Callbacks.addCallback("player_hurt", callback, function(data)
  		return {
  			victim = Player:newFromUserid(data.userid),
  			attacker = Player:newFromUserid(data.attacker),
  			health = data.health,
  			armor = data.armor,
  			weapon = data.weapon,
  			dmg_health = data.dmg_health,
  			dmg_armor = data.dmg_armor,
  			hitgroup = data.hitgroup
  		}
  	end)
  end
  
  --- @class ItemPurchaseEvent
  --- @field player Player
  --- @field team number
  --- @field loadout number
  --- @field weapon string
  --- @param callback fun(data: ItemPurchaseEvent): void
  --- @return void
  function Callbacks.itemPurchase(callback)
  	Callbacks.addCallback("item_purchase", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			team = data.team,
  			loadout = data.loadout,
  			weapon = data.weapon
  		}
  	end)
  end
  
  --- @class BombBeginPlantEvent
  --- @field player Player
  --- @field site number
  --- @param callback fun(data: BombBeginPlantEvent): void
  --- @return void
  function Callbacks.bombBeginPlant(callback)
  	Callbacks.addCallback("bomb_beginplant", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			site = data.site
  		}
  	end)
  end
  
  --- @class BombAbortPlantEvent
  --- @field player Player
  --- @field site number
  --- @param callback fun(data: BombAbortPlantEvent): void
  --- @return void
  function Callbacks.bombAbortPlant(callback)
  	Callbacks.addCallback("bomb_abortplant", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			site = data.site
  		}
  	end)
  end
  
  --- @class BombPlantedEvent
  --- @field player Player
  --- @field site number
  --- @param callback fun(data: BombPlantedEvent): void
  --- @return void
  function Callbacks.bombPlanted(callback)
  	Callbacks.addCallback("bomb_planted", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			site = data.site
  		}
  	end)
  end
  
  --- @class BombDefusedEvent
  --- @field player Player
  --- @field site number
  --- @param callback fun(data: bomb_defused_event_c): void
  --- @return void
  function Callbacks.bombDefused(callback)
  	Callbacks.addCallback("bomb_defused", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			site = data.site
  		}
  	end)
  end
  
  --- @class BombExplodedEvent
  --- @field player Player
  --- @field site number
  --- @param callback fun(data: bomb_exploded_event_c): void
  --- @return void
  function Callbacks.bombExploded(callback)
  	Callbacks.addCallback("bomb_exploded", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			site = data.site
  		}
  	end)
  end
  
  --- @class BombDroppedEvent
  --- @field player Player
  --- @field entindex number
  --- @param callback fun(data: BombDroppedEvent): void
  --- @return void
  function Callbacks.bombDropped(callback)
  	Callbacks.addCallback("bomb_dropped", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entindex = data.entindex
  		}
  	end)
  end
  
  --- @class BombPickupEvent
  --- @field player Player
  --- @param callback fun(data: BombPickupEvent): void
  --- @return void
  function Callbacks.bombPickup(callback)
  	Callbacks.addCallback("bomb_pickup", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class DefuserDroppedEvent
  --- @field entityid number
  --- @param callback fun(data: DefuserDroppedEvent): void
  --- @return void
  function Callbacks.defuserDropped(callback)
  	Callbacks.addCallback("defuser_dropped", callback, function(data)
  		return {
  			entityid = data.entityid
  		}
  	end)
  end
  
  --- @class DefuserPickupEvent
  --- @field entityid number
  --- @field player Player
  --- @param callback fun(data: DefuserPickupEvent): void
  --- @return void
  function Callbacks.defuserPickup(callback)
  	Callbacks.addCallback("defuser_pickup", callback, function(data)
  		return {
  			entityid = data.entityid,
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.announcePhaseEnd(callback)
  	Callbacks.addCallback("announce_phase_end", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.csIntermission(callback)
  	Callbacks.addCallback("cs_intermission", callback, function()
  		return nil
  	end)
  end
  
  --- @class BombBeginDefuseEvent
  --- @field player Player
  --- @field haskit boolean
  --- @param callback fun(data: BombBeginDefuseEvent): void
  --- @return void
  function Callbacks.bombBeginDefuse(callback)
  	Callbacks.addCallback("bomb_begindefuse", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			haskit = data.haskit
  		}
  	end)
  end
  
  --- @class BombAbortDefuseEvent
  --- @field player Player
  --- @param callback fun(data: BombAbortDefuseEvent): void
  --- @return void
  function Callbacks.bombAbortDefuse(callback)
  	Callbacks.addCallback("bomb_abortdefuse", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class HostageFollowsEvent
  --- @field player Player
  --- @field hostage number
  --- @param callback fun(data: HostageFollowsEvent): void
  --- @return void
  function Callbacks.hostageFollows(callback)
  	Callbacks.addCallback("hostage_follows", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hostage = data.hostage
  		}
  	end)
  end
  
  --- @class HostageHurtEvent
  --- @field player Player
  --- @field hostage number
  --- @param callback fun(data: HostageHurtEvent): void
  --- @return void
  function Callbacks.hostageHurt(callback)
  	Callbacks.addCallback("hostage_hurt", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hostage = data.hostage
  		}
  	end)
  end
  
  --- @class HostageKilledEvent
  --- @field player Player
  --- @field hostage number
  --- @param callback fun(data: HostageKilledEvent): void
  --- @return void
  function Callbacks.hostageKilled(callback)
  	Callbacks.addCallback("hostage_killed", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hostage = data.hostage
  		}
  	end)
  end
  
  --- @class HostageRescuedEvent
  --- @field player Player
  --- @field hostage number
  --- @field site number
  --- @param callback fun(data: HostageRescuedEvent): void
  --- @return void
  function Callbacks.hostageRescued(callback)
  	Callbacks.addCallback("hostage_rescued", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hostage = data.hostage,
  			site = data.site
  		}
  	end)
  end
  
  --- @class HostageStopsFollowingEvent
  --- @field player Player
  --- @field hostage number
  --- @param callback fun(data: HostageStopsFollowingEvent): void
  --- @return void
  function Callbacks.hostageStopsFollowing(callback)
  	Callbacks.addCallback("hostage_stops_following", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hostage = data.hostage
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.hostageRescuedAll(callback)
  	Callbacks.addCallback("hostage_rescued_all", callback, function()
  		return nil
  	end)
  end
  
  --- @class HostageCallForHelpEvent
  --- @field hostage number
  --- @param callback fun(data: HostageCallForHelpEvent): void
  --- @return void
  function Callbacks.hostageCallForHelp(callback)
  	Callbacks.addCallback("hostage_call_for_help", callback, function(data)
  		return {
  			hostage = data.hostage
  		}
  	end)
  end
  
  --- @class VipEscapedEvent
  --- @field player Player
  --- @param callback fun(data: VipEscapedEvent): void
  --- @return void
  function Callbacks.vipEscaped(callback)
  	Callbacks.addCallback("vip_escaped", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class VipKilledEvent
  --- @field victim Player
  --- @field attacker Player
  --- @param callback fun(data: VipKilledEvent): void
  --- @return void
  function Callbacks.vipKilled(callback)
  	Callbacks.addCallback("vip_killed", callback, function(data)
  		return {
  			victim = Player:newFromUserid(data.userid),
  			attacker = Player:newFromUserid(data.attacker, self.cache),
  		}
  	end)
  end
  
  --- @class PlayerRadioEvent
  --- @field player Player
  --- @field slot number
  --- @param callback fun(data: PlayerRadioEvent): void
  --- @return void
  function Callbacks.playerRadio(callback)
  	Callbacks.addCallback("player_radio", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			slot = data.slot
  		}
  	end)
  end
  
  --- @class BombBeepEvent
  --- @field entindex number
  --- @param callback fun(data: BombBeepEvent): void
  --- @return void
  function Callbacks.bombBeep(callback)
  	Callbacks.addCallback("bomb_beep", callback, function(data)
  		return {
  			entindex = data.entindex
  		}
  	end)
  end
  
  --- @class WeaponFireEvent
  --- @field player Player
  --- @field weapon string
  --- @field silenced boolean
  --- @param callback fun(data: WeaponFireEvent): void
  --- @return void
  function Callbacks.weaponFire(callback)
  	Callbacks.addCallback("weapon_fire", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			weapon = data.weapon,
  			silenced = data.silenced
  		}
  	end)
  end
  
  --- @class WeaponFireOnEmptyEvent
  --- @field player Player
  --- @field weapon string
  --- @param callback fun(data: WeaponFireOnEmptyEvent): void
  --- @return void
  function Callbacks.weaponFireOnEmpty(callback)
  	Callbacks.addCallback("weapon_fire_on_empty", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			weapon = data.weapon
  		}
  	end)
  end
  
  --- @class GrenadeThrownEvent
  --- @field player Player
  --- @field weapon string
  --- @param callback fun(data: GrenadeThrownEvent): void
  --- @return void
  function Callbacks.grenadeThrown(callback)
  	Callbacks.addCallback("grenade_thrown", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			weapon = data.weapon
  		}
  	end)
  end
  
  --- @class WeaponOutOfAmmoEvent
  --- @field player Player
  --- @param callback fun(data: WeaponOutOfAmmoEvent): void
  --- @return void
  function Callbacks.weaponOutOfAmmo(callback)
  	Callbacks.addCallback("weapon_outofammo", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class WeaponReloadEvent
  --- @field player Player
  --- @param callback fun(data: WeaponReloadEvent): void
  --- @return void
  function Callbacks.weaponReload(callback)
  	Callbacks.addCallback("weapon_reload", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class WeaponZoomEvent
  --- @field player Player
  --- @param callback fun(data: WeaponZoomEvent): void
  --- @return void
  function Callbacks.weaponZoom(callback)
  	Callbacks.addCallback("weapon_zoom", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class SilencerDetachEvent
  --- @field player Player
  --- @param callback fun(data: SilencerDetachEvent): void
  --- @return void
  function Callbacks.silencerDetach(callback)
  	Callbacks.addCallback("silencer_detach", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class InspectWeaponEvent
  --- @field player Player
  --- @param callback fun(data: InspectWeaponEvent): void
  --- @return void
  function Callbacks.inspectWeapon(callback)
  	Callbacks.addCallback("inspect_weapon", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class WeaponZoomRifleEvent
  --- @field player Player
  --- @param callback fun(data: WeaponZoomRifleEvent): void
  --- @return void
  function Callbacks.weaponZoomRifle(callback)
  	Callbacks.addCallback("weapon_zoom_rifle", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class PlayerSpawnedEvent
  --- @field player Player
  --- @field inrestart boolean
  --- @param callback fun(data: PlayerSpawnedEvent): void
  --- @return void
  function Callbacks.playerSpawned(callback)
  	Callbacks.addCallback("player_spawned", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			inrestart = data.inrestart
  		}
  	end)
  end
  
  --- @class ItemPickupEvent
  --- @field player Player
  --- @field item string
  --- @field silent boolean
  --- @field defindex number
  --- @param callback fun(data: ItemPickupEvent): void
  --- @return void
  function Callbacks.itemPickup(callback)
  	Callbacks.addCallback("item_pickup", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			item = data.item,
  			silent = data.silent,
  			defindex = data.defindex
  		}
  	end)
  end
  
  --- @class ItemPickupSlerpEvent
  --- @field player Player
  --- @field index number
  --- @field behavior number
  --- @param callback fun(data: ItemPickupSlerpEvent): void
  --- @return void
  function Callbacks.itemPickupSlerp(callback)
  	Callbacks.addCallback("item_pickup_slerp", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			index = data.index,
  			behavior = data.behavior
  		}
  	end)
  end
  
  --- @class ItemPickupFailedEvent
  --- @field player Player
  --- @field item string
  --- @field reason number
  --- @field limit number
  --- @param callback fun(data: ItemPickupFailedEvent): void
  --- @return void
  function Callbacks.itemPickupFailed(callback)
  	Callbacks.addCallback("item_pickup_failed", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			item = data.item,
  			reason = data.reason,
  			limit = data.limit
  		}
  	end)
  end
  
  --- @class ItemRemoveEvent
  --- @field player Player
  --- @field item string
  --- @field defindex number
  --- @param callback fun(data: ItemRemoveEvent): void
  --- @return void
  function Callbacks.itemRemove(callback)
  	Callbacks.addCallback("item_remove", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			item = data.item,
  			defindex = data.defindex
  		}
  	end)
  end
  
  --- @class ItemEquipEvent
  --- @field player Player
  --- @field item string
  --- @field defindex number
  --- @field canzoom boolean
  --- @field hassilencer boolean
  --- @field issilenced boolean
  --- @field hastracers boolean
  --- @field weptype number
  --- @field ispainted boolean
  --- @param callback fun(data: ItemEquipEvent): void
  --- @return void
  function Callbacks.itemEquip(callback)
  	Callbacks.addCallback("item_equip", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			item = data.item,
  			defindex = data.defindex,
  			canzoom = data.canzoom,
  			hassilencer = data.hassilencer,
  			issilenced = data.issilenced,
  			hastracers = data.hastracers,
  			weptype = data.weptype,
  			ispainted = data.ispainted
  		}
  	end)
  end
  
  --- @class EnterBuyzoneEvent
  --- @field player Player
  --- @field canbuy boolean
  --- @param callback fun(data: EnterBuyzoneEvent): void
  --- @return void
  function Callbacks.enterBuyzone(callback)
  	Callbacks.addCallback("enter_buyzone", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			canbuy = data.canbuy
  		}
  	end)
  end
  
  --- @class ExitBuyzoneEvent
  --- @field player Player
  --- @field canbuy boolean
  --- @param callback fun(data: ExitBuyzoneEvent): void
  --- @return void
  function Callbacks.exitBuyzone(callback)
  	Callbacks.addCallback("exit_buyzone", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			canbuy = data.canbuy
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.buytimeEnded(callback)
  	Callbacks.addCallback("buytime_ended", callback, function()
  		return nil
  	end)
  end
  
  --- @class EnterBombzoneEvent
  --- @field player Player
  --- @field hasbomb boolean
  --- @field isplanted boolean
  --- @param callback fun(data: EnterBombzoneEvent): void
  --- @return void
  function Callbacks.enterBombzone(callback)
  	Callbacks.addCallback("enter_bombzone", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			hasbomb = data.hasbomb,
  			isplanted = data.isplanted
  		}
  	end)
  end
  
  --- @class EnterRescueZoneEvent
  --- @field player Player
  --- @param callback fun(data: EnterRescueZoneEvent): void
  --- @return void
  function Callbacks.enterRescueZone(callback)
  	Callbacks.addCallback("enter_rescue_zone", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class ExitRescueZoneEvent
  --- @field player Player
  --- @param callback fun(data: ExitRescueZoneEvent): void
  --- @return void
  function Callbacks.exitRescueZone(callback)
  	Callbacks.addCallback("exit_rescue_zone", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class SilencerOffEvent
  --- @field player Player
  --- @param callback fun(data: SilencerOffEvent): void
  --- @return void
  function Callbacks.silencerOff(callback)
  	Callbacks.addCallback("silencer_off", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class SilencerOnEvent
  --- @field player Player
  --- @param callback fun(data: SilencerOnEvent): void
  --- @return void
  function Callbacks.silencerOn(callback)
  	Callbacks.addCallback("silencer_on", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class BuyMenuOpenEvent
  --- @field player Player
  --- @param callback fun(data: BuyMenuOpenEvent): void
  --- @return void
  function Callbacks.buyMenuOpen(callback)
  	Callbacks.addCallback("buymenu_open", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class BuyMenuCloseEvent
  --- @field player Player
  --- @param callback fun(data: BuyMenuCloseEvent): void
  --- @return void
  function Callbacks.buyMenuClose(callback)
  	Callbacks.addCallback("buymenu_close", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.roundPrestart(callback)
  	Callbacks.addCallback("round_prestart", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.roundPoststart(callback)
  	Callbacks.addCallback("round_poststart", callback, function()
  		return nil
  	end)
  end
  
  --- @class RoundStartEvent
  --- @field timelimit number
  --- @field fraglimit number
  --- @field objective string
  --- @param callback fun(data: RoundStartEvent): void
  --- @return void
  function Callbacks.roundStart(callback)
  	Callbacks.addCallback("round_start", callback, function(data)
  		return {
  			timelimit = data.timelimit,
  			fraglimit = data.fraglimit,
  			objective = data.objective
  		}
  	end)
  end
  
  --- @class RoundEndEvent
  --- @field winner number
  --- @field reason number
  --- @field message string
  --- @field legacy number
  --- @field Playerount number
  --- @field nomusic number
  --- @param callback fun(data: RoundEndEvent): void
  --- @return void
  function Callbacks.roundEnd(callback)
  	Callbacks.addCallback("round_end", callback, function(data)
  		return {
  			winner = data.winner,
  			reason = data.reason,
  			message = data.message,
  			legacy = data.legacy,
  			Playerount = data.Playerount,
  			nomusic = data.nomusic
  		}
  	end)
  end
  
  --- @class GrenadeBounceEvent
  --- @field player Player
  --- @param callback fun(data: GrenadeBounceEvent): void
  --- @return void
  function Callbacks.grenadeBounce(callback)
  	Callbacks.addCallback("grenade_bounce", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class HeGrenadeDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: HeGrenadeDetonateEvent): void
  --- @return void
  function Callbacks.heGrenadeDetonate(callback)
  	Callbacks.addCallback("hegrenade_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class FlashbangDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: FlashbangDetonateEvent): void
  --- @return void
  function Callbacks.flashbangDetonate(callback)
  	Callbacks.addCallback("flashbang_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class SmokeGrenadeDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: SmokeGrenadeDetonateEvent): void
  --- @return void
  function Callbacks.smokeGrenadeDetonate(callback)
  	Callbacks.addCallback("smokegrenade_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class SmokeGrenadeExpiredEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: SmokeGrenadeExpiredEvent: void
  --- @return void
  function Callbacks.smokeGrenadeExpired(callback)
  	Callbacks.addCallback("smokegrenade_expired", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class MolotovDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: MolotovDetonateEvent): void
  --- @return void
  function Callbacks.molotovDetonate(callback)
  	Callbacks.addCallback("molotov_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class DecoyDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: DecoyDetonateEvent): void
  --- @return void
  function Callbacks.decoyDetonate(callback)
  	Callbacks.addCallback("decoy_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class DecoyStartedEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: DecoyStartedEvent): void
  --- @return void
  function Callbacks.decoyStarted(callback)
  	Callbacks.addCallback("decoy_started", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class TaGrenadeDetonateEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: TaGrenadeDetonateEvent): void
  --- @return void
  function Callbacks.taGrenadeDetonate(callback)
  	Callbacks.addCallback("tagrenade_detonate", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class InfernoStartBurnEvent
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: InfernoStartBurnEvent): void
  --- @return void
  function Callbacks.infernoStartBurn(callback)
  	Callbacks.addCallback("inferno_startburn", callback, function(data)
  		return {
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class InfernoExpireEvent
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: InfernoExpireEvent): void
  --- @return void
  function Callbacks.infernoExpire(callback)
  	Callbacks.addCallback("inferno_expire", callback, function(data)
  		return {
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class InfernoExtinguishEvent
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: InfernoExtinguishEvent): void
  --- @return void
  function Callbacks.infernoExtinguish(callback)
  	Callbacks.addCallback("inferno_extinguish", callback, function(data)
  		return {
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class DecoyFiringEvent
  --- @field player Player
  --- @field entityid number
  --- @field origin Vector3
  --- @param callback fun(data: DecoyFiringEvent): void
  --- @return void
  function Callbacks.decoyFiring(callback)
  	Callbacks.addCallback("decoy_firing", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			entityid = data.entityid,
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class BulletImpactEvent
  --- @field shooter Player
  --- @field origin Vector3
  --- @param callback fun(data: BulletImpactEvent): void
  --- @return void
  function Callbacks.bulletImpact(callback)
  	Callbacks.addCallback("bullet_impact", callback, function(data)
  		return {
  			shooter = Player:newFromUserid(data.userid),
  			origin = Vector3:new(data.x, data.y, data.z)
  		}
  	end)
  end
  
  --- @class PlayerFootstepEvent
  --- @field player Player
  --- @param callback fun(data: PlayerFootstepEvent): void
  --- @return void
  function Callbacks.playerFootstep(callback)
  	Callbacks.addCallback("player_footstep", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class PlayerJumpEvent
  --- @field player Player
  --- @param callback fun(data: PlayerJumpEvent): void
  --- @return void
  function Callbacks.playerJump(callback)
  	Callbacks.addCallback("player_jump", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class PlayerBlindEvent
  --- @field victim Player
  --- @field attacker Player
  --- @field entityid number
  --- @field blind_duration number
  --- @param callback fun(data: PlayerBlindEvent): void
  --- @return void
  function Callbacks.playerBlind(callback)
  	Callbacks.addCallback("player_blind", callback, function(data)
  		return {
  			victim = Player:newFromUserid(data.userid),
  			attacker = Player:newFromUserid(data.attacker, self.cache),
  			entityid = data.entityid,
  			blind_duration = data.blind_duration
  		}
  	end)
  end
  
  --- @class PlayerFallDamageEvent
  --- @field player Player
  --- @field damage number
  --- @param callback fun(data: PlayerFallDamageEvent): void
  --- @return void
  function Callbacks.playerFallDamage(callback)
  	Callbacks.addCallback("player_falldamage", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			damage = data.damage
  		}
  	end)
  end
  
  --- @class DoorMovingEvent
  --- @field entindex number
  --- @field player Player
  --- @param callback fun(data: DoorMovingEvent): void
  --- @return void
  function Callbacks.doorMoving(callback)
  	Callbacks.addCallback("door_moving", callback, function(data)
  		return {
  			entindex = data.entindex,
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.roundFreezeEnd(callback)
  	Callbacks.addCallback("round_freeze_end", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.mbInputLockSuccess(callback)
  	Callbacks.addCallback("mb_input_lock_success", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.mbInputLockCancel(callback)
  	Callbacks.addCallback("mb_input_lock_cancel", callback, function()
  		return nil
  	end)
  end
  
  --- @class NavBlockedEvent
  --- @field area number
  --- @field blocked boolean
  --- @param callback fun(data: NavBlockedEvent): void
  --- @return void
  function Callbacks.navBlocked(callback)
  	Callbacks.addCallback("nav_blocked", callback, function(data)
  		return {
  			area = data.area,
  			blocked = data.blocked
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.navGenerate(callback)
  	Callbacks.addCallback("nav_generate", callback, function()
  		return nil
  	end)
  end
  
  --- @class PlayerStatsUpdatedEvent
  --- @field forceupload boolean
  --- @param callback fun(data: PlayerStatsUpdatedEvent): void
  --- @return void
  function Callbacks.playerStatsUpdated(callback)
  	Callbacks.addCallback("player_stats_updated", callback, function(data)
  		return {
  			forceupload = data.forceupload
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.achievementInfoLoaded(callback)
  	Callbacks.addCallback("achievement_info_loaded", callback, function()
  		return nil
  	end)
  end
  
  --- @class SpecTargetUpdatedEvent
  --- @field player Player
  --- @param callback fun(data: SpecTargetUpdatedEvent): void
  --- @return void
  function Callbacks.specTargetUpdated(callback)
  	Callbacks.addCallback("spec_target_updated", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class SpecModeUpdatedEvent
  --- @field player Player
  --- @param callback fun(data: SpecModeUpdatedEvent): void
  --- @return void
  function Callbacks.specModeUpdated(callback)
  	Callbacks.addCallback("spec_mode_updated", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.csGameDisconnected(callback)
  	Callbacks.addCallback("cs_game_disconnected", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.csWinPanelMatch(callback)
  	Callbacks.addCallback("cs_win_panel_match", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.csMatchEndRestart(callback)
  	Callbacks.addCallback("cs_match_end_restart", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.csPreRestart(callback)
  	Callbacks.addCallback("cs_pre_restart", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.hideFreezepanel(callback)
  	Callbacks.addCallback("hide_freezepanel", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.freezecamStarted(callback)
  	Callbacks.addCallback("freezecam_started", callback, function()
  		return nil
  	end)
  end
  
  --- @class PlayerDecalEvent
  --- @field player Player
  --- @param callback fun(data: PlayerDecalEvent): void
  --- @return void
  function Callbacks.playerDecal(callback)
  	Callbacks.addCallback("player_decal", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.clientDisconnect(callback)
  	Callbacks.addCallback("client_disconnect", callback, function()
  		return nil
  	end)
  end
  
  --- @class GgBonusGrenadeAchievedEvent
  --- @field player Player
  --- @param callback fun(data: GgBonusGrenadeAchievedEvent): void
  --- @return void
  function Callbacks.ggBonusGrenadeAchieved(callback)
  	Callbacks.addCallback("gg_bonus_grenade_achieved", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class GgLeaderEvent
  --- @field player Player
  --- @param callback fun(data: GgLeaderEvent): void
  --- @return void
  function Callbacks.ggLeader(callback)
  	Callbacks.addCallback("gg_leader", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.playerid, self.cache)
  		}
  	end)
  end
  
  --- @class GgTeamLeaderEvent
  --- @field player Player
  --- @param callback fun(data: GgTeamLeaderEvent): void
  --- @return void
  function Callbacks.ggTeamLeader(callback)
  	Callbacks.addCallback("gg_team_leader", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.playerid, self.cache)
  		}
  	end)
  end
  
  --- @class GgPlayerImpendingUpgradeEvent
  --- @field player Player
  --- @param callback fun(data: GgPlayerImpendingUpgradeEvent): void
  --- @return void
  function Callbacks.ggPlayerImpendingUpgrade(callback)
  	Callbacks.addCallback("gg_player_impending_upgrade", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.writeProfileData(callback)
  	Callbacks.addCallback("write_profile_data", callback, function()
  		return nil
  	end)
  end
  
  --- @class TrialTimeExpiredEvent
  --- @field slot number
  --- @param callback fun(data: TrialTimeExpiredEvent): void
  --- @return void
  function Callbacks.trialTimeExpired(callback)
  	Callbacks.addCallback("trial_time_expired", callback, function(data)
  		return {
  			slot = data.slot
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.updateMatchmakingStats(callback)
  	Callbacks.addCallback("update_matchmaking_stats", callback, function()
  		return nil
  	end)
  end
  
  --- @class PlayerResetVoteEvent
  --- @field player Player
  --- @field vote boolean
  --- @param callback fun(data: PlayerResetVoteEvent): void
  --- @return void
  function Callbacks.playerResetVote(callback)
  	Callbacks.addCallback("player_reset_vote", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			vote = data.vote
  		}
  	end)
  end
  
  --- @class EnableRestartVotingEvent
  --- @field enable boolean
  --- @param callback fun(data: EnableRestartVotingEvent): void
  --- @return void
  function Callbacks.enableRestartVoting(callback)
  	Callbacks.addCallback("enable_restart_voting", callback, function(data)
  		return {
  			enable = data.enable
  		}
  	end)
  end
  
  --- @class SfuieventEvent
  --- @field action Player
  --- @field data number
  --- @field slot number
  --- @param callback fun(data: SfuieventEvent): void
  --- @return void
  function Callbacks.sfuievent(callback)
  	Callbacks.addCallback("sfuievent", callback, function(data)
  		return {
  			action = data.action,
  			data = data.data,
  			slot = data.slot
  		}
  	end)
  end
  
  --- @class StartVoteEvent
  --- @field player Player
  --- @field type number
  --- @field vote_parameter number
  --- @param callback fun(data: StartVoteEvent): void
  --- @return void
  function Callbacks.startVote(callback)
  	Callbacks.addCallback("start_vote", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			type = data.type,
  			vote_parameter = data.vote_parameter
  		}
  	end)
  end
  
  --- @class PlayerGivenC4Event
  --- @field player Player
  --- @param callback fun(data: PlayerGivenC4Event): void
  --- @return void
  function Callbacks.playerGivenC4(callback)
  	Callbacks.addCallback("player_given_c4", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class PlayerBecomeGhostEvent
  --- @field player Player
  --- @param callback fun(data: PlayerBecomeGhostEvent): void
  --- @return void
  function Callbacks.playerBecomeGhost(callback)
  	Callbacks.addCallback("player_become_ghost", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class GgResetRoundStartSoundsEvent
  --- @field player Player
  --- @param callback fun(data: GgResetRoundStartSoundsEvent): void
  --- @return void
  function Callbacks.ggResetRoundStartSounds(callback)
  	Callbacks.addCallback("gg_reset_round_start_sounds", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class TrPlayerFlashbangedEvent
  --- @field player Player
  --- @param callback fun(data: TrPlayerFlashbangedEvent): void
  --- @return void
  function Callbacks.trPlayerFlashbanged(callback)
  	Callbacks.addCallback("tr_player_flashbanged", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class TrHighlightAmmoEvent
  --- @field player Player
  --- @param callback fun(data: TrHighlightAmmoEvent): void
  --- @return void
  function Callbacks.trHighlightAmmo(callback)
  	Callbacks.addCallback("tr_highlight_ammo", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class TrMarkCompleteEvent
  --- @field complete number
  --- @param callback fun(data: TrMarkCompleteEvent): void
  --- @return void
  function Callbacks.trMarkBestTime(callback)
  	Callbacks.addCallback("tr_mark_complete", callback, function(data)
  		return {
  			complete = data.complete
  		}
  	end)
  end
  
  --- @class TrMarkBestTimeEvent
  --- @field time number
  --- @param callback fun(data: TrMarkBestTimeEvent): void
  --- @return void
  function Callbacks.trMarkBestTime(callback)
  	Callbacks.addCallback("tr_mark_best_time", callback, function(data)
  		return {
  			time = data.time
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.trExitHintTrigger(callback)
  	Callbacks.addCallback("tr_exit_hint_trigger", callback, function()
  		return nil
  	end)
  end
  
  --- @class BotTakeoverEvent
  --- @field player Player
  --- @field bot Player
  --- @field index number
  --- @param callback fun(data: BotTakeoverEvent): void
  --- @return void
  function Callbacks.botTakeover(callback)
  	Callbacks.addCallback("bot_takeover", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			bot = Player:newFromUserid(data.botid, self.cache),
  			index = data.index
  		}
  	end)
  end
  
  --- @class TrShowFinishMsgboxEvent
  --- @field player Player
  --- @param callback fun(data: TrShowFinishMsgboxEvent): void
  --- @return void
  function Callbacks.trShowFinishMsgbox(callback)
  	Callbacks.addCallback("tr_show_finish_msgbox", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class TrShowExitMsgboxEvent
  --- @field player Player
  --- @param callback fun(data: TrShowExitMsgboxEvent): void
  --- @return void
  function Callbacks.trShowExitMsgbox(callback)
  	Callbacks.addCallback("tr_show_exit_msgbox", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.resetPlayerontrols(callback)
  	Callbacks.addCallback("reset_Playerontrols", callback, function()
  		return nil
  	end)
  end
  
  --- @class JoinTeamFailedEvent
  --- @field player Player
  --- @field reason number
  --- @param callback fun(data: JoinTeamFailedEvent): void
  --- @return void
  function Callbacks.joinTeamFailed(callback)
  	Callbacks.addCallback("jointeam_failed", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			reason = data.reason
  		}
  	end)
  end
  
  --- @class TeamChangePendingEvent
  --- @field player Player
  --- @field toteam number
  --- @param callback fun(data: TeamChangePendingEvent): void
  --- @return void
  function Callbacks.teamChangePending(callback)
  	Callbacks.addCallback("teamchange_pending", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			toteam = data.toteam
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.materialDefaultComplete(callback)
  	Callbacks.addCallback("material_default_complete", callback, function()
  		return nil
  	end)
  end
  
  --- @class CsPrevNextSpectatorEvent
  --- @field next boolean
  --- @param callback fun(data: cs_prev_next_spectator_event_c): void
  --- @return void
  function Callbacks.csPrevNextSpectator(callback)
  	Callbacks.addCallback("cs_prev_next_spectator", callback, function(data)
  		return {
  			next = data.next
  		}
  	end)
  end
  
  --- @class CsHandleImeEvent
  --- @field eventtype string
  --- @field eventdata string
  --- @param callback fun(data: CsHandleImeEvent): void
  --- @return void
  function Callbacks.csHandleImeEvent(callback)
  	Callbacks.addCallback("cs_handle_ime_event", callback, function(data)
  		return {
  			eventtype = data.eventtype,
  			eventdata = data.eventdata
  		}
  	end)
  end
  
  --- @class NextLevelChangedEvent
  --- @field nextlevel string
  --- @field mapgroup string
  --- @field skirmishmode string
  --- @param callback fun(data: NextLevelChangedEvent): void
  --- @return void
  function Callbacks.nextLevelChanged(callback)
  	Callbacks.addCallback("nextlevel_changed", callback, function(data)
  		return {
  			nextlevel = data.nextlevel,
  			mapgroup = data.mapgroup,
  			skirmishmode = data.skirmishmode
  		}
  	end)
  end
  
  --- @class SeasonCoinLevelupEvent
  --- @field player Player
  --- @field category number
  --- @field rank number
  --- @param callback fun(data: SeasonCoinLevelupEvent): void
  --- @return void
  function Callbacks.seasonCoinLevelup(callback)
  	Callbacks.addCallback("seasoncoin_levelup", callback, function(data)
  		return {
  			player = data.player,
  			category = data.category,
  			rank = data.rank
  		}
  	end)
  end
  
  --- @class TournamentRewardEvent
  --- @field defindex number
  --- @field totalrewards number
  --- @field accountid number
  --- @param callback fun(data: TournamentRewardEvent): void
  --- @return void
  function Callbacks.tournamentReward(callback)
  	Callbacks.addCallback("tournament_reward", callback, function(data)
  		return {
  			defindex = data.defindex,
  			totalrewards = data.totalrewards,
  			accountid = data.accountid
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.startHalftime(callback)
  	Callbacks.addCallback("start_halftime", callback, function()
  		return nil
  	end)
  end
  
  --- @class AmmoRefillEvent
  --- @field player Player
  --- @field success boolean
  --- @param callback fun(data: AmmoRefillEvent): void
  --- @return void
  function Callbacks.ammoRefill(callback)
  	Callbacks.addCallback("ammo_refill", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			success = data.success
  		}
  	end)
  end
  
  --- @class ParachutePickupEvent
  --- @field player Player
  --- @param callback fun(data: ParachutePickupEvent): void
  --- @return void
  function Callbacks.parachutePickup(callback)
  	Callbacks.addCallback("parachute_pickup", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class ParachuteDeployEvent
  --- @field player Player
  --- @param callback fun(data: ParachuteDeployEvent): void
  --- @return void
  function Callbacks.parachuteDeploy(callback)
  	Callbacks.addCallback("parachute_deploy", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class DroneGunAttackEvent
  --- @field player Player
  --- @param callback fun(data: DroneGunAttackEvent): void
  --- @return void
  function Callbacks.droneGunAttack(callback)
  	Callbacks.addCallback("dronegun_attack", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid)
  		}
  	end)
  end
  
  --- @class DroneDispatchedEvent
  --- @field player Player
  --- @field priority number
  --- @field drone_dispatched boolean
  --- @param callback fun(data: DroneDispatchedEvent): void
  --- @return void
  function Callbacks.droneDispatched(callback)
  	Callbacks.addCallback("drone_dispatched", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			priority = data.priority,
  			drone_dispatched = data.drone_dispatched
  		}
  	end)
  end
  
  --- @class LootCrateVisibleEvent
  --- @field player Player
  --- @field subject number
  --- @field type string
  --- @param callback fun(data: LootCrateVisibleEvent): void
  --- @return void
  function Callbacks.lootCrateVisible(callback)
  	Callbacks.addCallback("loot_crate_visible", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			subject = data.subject,
  			type = data.type
  		}
  	end)
  end
  
  --- @class LootCrateOpenedEvent
  --- @field player Player
  --- @field type string
  --- @param callback fun(data: LootCrateOpenedEvent): void
  --- @return void
  function Callbacks.lootCrateOpened(callback)
  	Callbacks.addCallback("loot_crate_opened", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			type = data.type
  		}
  	end)
  end
  
  --- @class OpenCrateInstrEvent
  --- @field player Player
  --- @field subject number
  --- @field type string
  --- @param callback fun(data: OpenCrateInstrEvent): void
  --- @return void
  function Callbacks.openCrateInstr(callback)
  	Callbacks.addCallback("open_crate_instr", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			subject = data.subject,
  			type = data.type
  		}
  	end)
  end
  
  --- @class SmokeBeaconParadropEvent
  --- @field player Player
  --- @field paradrop number
  --- @param callback fun(data: SmokeBeaconParadropEvent): void
  --- @return void
  function Callbacks.smokeBeaconParadrop(callback)
  	Callbacks.addCallback("smoke_beacon_paradrop", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			paradrop = data.paradrop
  		}
  	end)
  end
  
  --- @class DroneCargoDetachedEvent
  --- @field player Player
  --- @field cargo number
  --- @field delivered boolean
  --- @param callback fun(data: DroneCargoDetachedEvent): void
  --- @return void
  function Callbacks.droneCargoDetached(callback)
  	Callbacks.addCallback("drone_cargo_detached", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			cargo = data.cargo,
  			delivered = data.delivered
  		}
  	end)
  end
  
  --- @class ChoppersIncomingWarningEvent
  --- @field global boolean
  --- @param callback fun(data: ChoppersIncomingWarningEvent): void
  --- @return void
  function Callbacks.choppersIncomingWarning(callback)
  	Callbacks.addCallback("choppers_incoming_warning", callback, function(data)
  		return {
  			global = data.global
  		}
  	end)
  end
  
  --- @class FirstBombsIncomingWarningEvent
  --- @field global boolean
  --- @param callback fun(data: FirstBombsIncomingWarningEvent): void
  --- @return void
  function Callbacks.firstBombsIncomingWarning(callback)
  	Callbacks.addCallback("firstbombs_incoming_warning", callback, function(data)
  		return {
  			global = data.global
  		}
  	end)
  end
  
  --- @class DzItemInteractionEvent
  --- @field player Player
  --- @field subject number
  --- @field type string
  --- @param callback fun(data: DzItemInteractionEvent): void
  --- @return void
  function Callbacks.dzItemInteraction(callback)
  	Callbacks.addCallback("dz_item_interaction", callback, function(data)
  		return {
  			player = Player:newFromUserid(data.userid),
  			subject = data.subject,
  			type = data.type
  		}
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.netUpdateEnd(callback)
  	Callbacks.addCallback("net_update_end", callback, function()
  		return nil
  	end)
  end
  
  --- @param callback fun(): void
  --- @return void
  function Callbacks.netUpdateStart(callback)
  	Callbacks.addCallback("net_update_start", callback, function()
  		return nil
  	end)
  end
  --endregion
  
  return Nyx.abstract(
  	"Nyx/Callbacks",
  	Callbacks
  )
  --endregion
end
package.preload["gamesense/Nyx/Callbacks"] = function() return return_values["Callbacks"] end
--endregion

--region Server
libraries["Server"] = function()
	local ffi = require "ffi"
  local Nyx = require "gamesense/Nyx/Framework"
  
  ffi.cdef [[
      typedef void*(__thiscall* get_net_channel_info_t)(void*);
  
  	typedef bool(__thiscall* is_ingame_t)(void*);
  	typedef bool(__thiscall* is_connected_t)(void*);
  
      typedef const char*(__thiscall* get_name_t)(void*);
      typedef const char*(__thiscall* get_address_t)(void*);
      typedef float(__thiscall* get_local_time_t)(void*);
      typedef float(__thiscall* get_time_connected_t)(void*);
  
      typedef float(__thiscall* get_avg_latency_t)(void*, int);
      typedef float(__thiscall* get_avg_loss_t)(void*, int);
      typedef float(__thiscall* get_avg_choke_t)(void*, int);
  ]]
  
  local interface_ptr = ffi.typeof('void***')
  local rawivengineclient = client.create_interface("engine.dll", "VEngineClient014")
  local ivengineclient = ffi.cast(interface_ptr, rawivengineclient)
  
  --region Server
  --- @class Server : Abstract
  --- @field public get_net_channel_info_t function
  --- @field public is_connected_t function
  --- @field public is_ingame_t function
  local Server = {
  	get_net_channel_info_t = ffi.cast("get_net_channel_info_t", ivengineclient[0][78]),
  	is_connected_t = ffi.cast("is_connected_t", ivengineclient[0][27]),
  	is_ingame_t = ffi.cast("is_connected_t", ivengineclient[0][26]),
  	LISTEN = "loopback",
  	VALVE = "valve"
  }
  
  --- @return function
  function Server.getNetworkChannelInfo()
  	return ffi.cast("void***", Server.get_net_channel_info_t(ivengineclient))
  end
  
  --- @return boolean
  function Server.isConnected()
  	return Server.is_connected_t(ivengineclient)
  end
  
  --- @return boolean
  function Server.isIngame()
  	return Server.is_ingame_t(ivengineclient)
  end
  
  --- @return number
  function Server.getLatency()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	return ffi.cast("get_avg_latency_t", net_chan_info[0][10])(net_chan_info, 0)
  end
  
  --- @return number
  function Server.getLoss()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	return ffi.cast("get_avg_loss_t", net_chan_info[0][11])(net_chan_info, 1)
  end
  
  --- @return number
  function Server.getChoke()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	return ffi.cast("get_avg_choke_t", net_chan_info[0][12])(net_chan_info, 1)
  end
  
  --- @return string
  function Server.getServerIpAddress()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	local ipAddress = ffi.string(ffi.cast("get_address_t", net_chan_info[0][1])(net_chan_info))
  
  	if string.find(ipAddress, "A") ~= nil then
  		ipAddress = Server.VALVE
  	end
  
  	return ipAddress
  end
  
  	--- @return number
  	function Server.getServerTime()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	return ffi.cast("get_local_time_t", net_chan_info[0][2])(net_chan_info)
  end
  
  --- @return number
  function Server.getTimeConnected()
  	if Server.isConnected() == false then
  		error("NetChanInfo functions must never be called while not fully connected to a server.")
  	end
  
  	local net_chan_info = Server.getNetworkChannelInfo()
  
  	return ffi.cast("get_time_connected_t", net_chan_info[0][3])(net_chan_info)
  end
  
  --- @return number
  function Server.getTickRate()
  	return 1 / globals.tickinterval()
  end
  
  return Nyx.abstract(
  	"Nyx/Server",
  	Server
  )
  --endregion
end
package.preload["gamesense/Nyx/Server"] = function() return return_values["Server"] end
--endregion

--region Chat
libraries["Chat"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Server = require "gamesense/Nyx/Server"
  
  local ffi = require "ffi"
  
  --region ffi
  ffi.cdef[[
  	typedef void***(__thiscall* FindHudElement_t)(void*, const char*);
  	typedef void(__cdecl* ChatPrintf_t)(void*, int, int, const char*, ...);
  ]]
  
  local signaturegHud = "\xB9\xCC\xCC\xCC\xCC\x88\x46\x09"
  local signatureFindElement = "\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x57\x8B\xF9\x33\xF6\x39\x77\x28"
  
  local match = client.find_signature("client_panorama.dll", signaturegHud) or error("sig1 not found")
  local hud = ffi.cast("void**", ffi.cast("char*", match) + 1)[0] or error("hud is nil")
  
  match = client.find_signature("client_panorama.dll", signatureFindElement) or error("FindHudElement not found")
  local findHudElement = ffi.cast("FindHudElement_t", match)
  local hudChat = findHudElement(hud, "CHudChat") or error("CHudChat not found")
  
  local cHudChatVtable = hudChat[0] or error("CHudChat instance vtable is nil")
  local printToChat = ffi.cast("ChatPrintf_t", cHudChatVtable[27])
  --endregion
  
  --region Chat
  --- @class Chat : Abstract
  local Chat = {
  	WHITE = "\x01",
  	DARK_RED = "\x02",
  	LILAC = "\x03",
  	GREEN = "\x04",
  	LIGHT_GREEN = "\x05",
  	LIME = "\x06",
  	RED = "\x07",
  	GREY = "\x08",
  	YELLOW = "\x09",
  	CHALK = "\x0A",
  	LIGHT_BLUE = "\x0B",
  	BLUE = "\x0C",
  	GREY2 = "\x0D",
  	PURPLE = "\x0E",
  	LIGHT_RED = "\x0F",
  	GOLD = "\x10"
  }
  
  --- @vararg string
  function Chat.sendMessage(...)
  	if Server.isConnected() == false then
  		return
  	end
  
  	local text = string.format(...)
  
  	text = text:gsub("%%%w?", "%%")
  	text = " " .. text
  
  	printToChat(hudChat, 0, 0, ffi.string(text))
  end
  
  --- @class ChatStringCmd
  --- @field text string
  --- @field teamOnly boolean
  ---
  --- @param stringCmdEventData
  --- @return ChatStringCmd|nil
  function Chat.getStringCmdMessage(stringCmdEventData)
  	--- @type ChatStringCmd
  	local chatStringCmd
  
  	if string.sub(stringCmdEventData.text, 1, 5) == 'say "' then
  		chatStringCmd = {
  			text = string.sub(stringCmdEventData.text, 6, #stringCmdEventData.text - 1),
  			teamOnly = false
  		}
  	elseif string.sub(stringCmdEventData.text, 1, 10) == 'say_team "' then
  		chatStringCmd = {
  			text = string.sub(stringCmdEventData.text, 11, #stringCmdEventData.text - 1),
  			teamOnly = true
  		}
  	end
  
  	return chatStringCmd
  end
  
  return Nyx.abstract(
  	"Nyx/Chat",
  	Chat
  )
  --endregion
end
package.preload["gamesense/Nyx/Chat"] = function() return return_values["Chat"] end
--endregion

--region Config
libraries["Config"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Config
  --- @class Config : Abstract
  local Config = {}
  
  --- @generic T
  --- @param class Class
  --- @param defaults T
  --- @return T
  function Config.load(class, defaults)
      local configName = string.format("Config%s", class.__classname)
      local saved = database.read(configName)
  
      if saved == nil then
          database.write(configName, defaults)
  
          return defaults
      end
  
      local resave = false
  
      for k, v in pairs(defaults) do
          if saved[k] == nil then
              saved[k] = v
  
              resave = true
          end
      end
  
      if resave then
          database.write(configName, saved)
      end
  
      return saved
  end
  
  --- @param class Class
  --- @param config table
  --- @return void
  function Config.save(class, config)
      database.write(string.format("Config%s", class.__classname), config)
  end
  
  --- @param class Class
  --- @return void
  function Config.flush(class)
      local configName = string.format("Config%s", class.__classname)
  
      database.write(configName, nil)
  end
  
  return Nyx.abstract(
  	"Nyx/Config",
  	Config
  )
  --endregion
end
package.preload["gamesense/Nyx/Config"] = function() return return_values["Config"] end
--endregion

--region Console
libraries["Console"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Shader = require "Color"
  
  --region Console
  --- @class Console : Class
  --- @field module string
  --- @field color Shader
  --- @field okColor Shader
  --- @field errorColor Shader
  --- @field warningColor Shader
  local Console = {
      OK = 0,
      ERROR = 1,
      WARNING = 2,
      STANDARD = 3
  }
  
  --- @return void
  function Console:__init()
      self.okColor = Shader:rgba(71, 255, 92)
      self.errorColor = Shader:rgba(255, 71, 71)
      self.warningColor = Shader:rgba(255, 154, 71)
  end
  
  --- @return Console
  function Console:new(module, color)
  	return Nyx.new(self, {
          module = module,
          color = color or Shader:rgba(255, 255, 255)
      })
  end
  
  --- @vararg string
  --- @return void
  function Console:log(...)
      client.color_log(
          self.color.r,
          self.color.g,
          self.color.b,
          string.format("[%s] \0", self.module)
      )
  
      client.color_log(220, 220, 220, string.format(...), "\0")
      client.color_log(220, 220, 220, " ")
  end
  
  --- @vararg string
  --- @return void
  function Console:logOk(...)
      client.color_log(
          self.color.r,
          self.color.g,
          self.color.b,
          string.format("[%s] \0", self.module)
      )
  
      client.color_log(
          self.okColor.r,
          self.okColor.g,
          self.okColor.b,
          "[SUCCESS] \0"
      )
  
      client.color_log(220, 220, 220, string.format(...), "\0")
  
      client.color_log(
          self.okColor.r,
          self.okColor.g,
          self.okColor.b,
          " "
      )
  end
  
  --- @vararg string
  --- @return void
  function Console:logError(...)
      client.color_log(
          self.color.r,
          self.color.g,
          self.color.b,
          string.format("[%s] \0", self.module)
      )
  
      client.color_log(
          self.errorColor.r,
          self.errorColor.g,
          self.errorColor.b,
          "[ERROR] \0"
      )
  
      client.color_log(220, 220, 220, string.format(...), "\0")
  
      client.color_log(
          self.errorColor.r,
          self.errorColor.g,
          self.errorColor.b,
          " "
      )
  end
  
  --- @vararg string
  --- @return void
  function Console:logWarning(...)
      client.color_log(
          self.color.r,
          self.color.g,
          self.color.b,
          string.format("[%s] \0", self.module)
      )
  
      client.color_log(
          self.warningColor.r,
          self.warningColor.g,
          self.warningColor.b,
          "[WARNING] \0"
      )
  
      client.color_log(220, 220, 220, string.format(...), "\0")
      
      client.color_log(
          self.warningColor.r,
          self.warningColor.g,
          self.warningColor.b,
          " "
      )
  end
  
  return Nyx.class(
  	"Nyx/Console",
  	Console
  )
  --endregion
end
package.preload["gamesense/Nyx/Console"] = function() return return_values["Console"] end
--endregion

--region Data
libraries["Data"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Data
  --- @class Data : Abstract
  local Data = {}
  
  --- @param hex string
  --- @return string
  function Data.hexToBinary(hex)
  	return (hex:gsub('..', function (cc)
  		return string.char(tonumber(cc, 16))
  	end))
  end
  
  --- @param binary string
  --- @return string
  function Data.binaryToHex(binary)
  	return (binary:gsub('.', function (c)
  		return string.format('%02X', string.byte(c))
  	end))
  end
  
  return Nyx.abstract(
  	"Nyx/Data",
  	Data
  )
  --endregion
end
package.preload["gamesense/Nyx/Data"] = function() return return_values["Data"] end
--endregion

--region Encrypt
libraries["Encrypt"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Encrypt
  --- @class Encrypt : Class
  --- @field keys number[]
  local Encrypt = {}
  
  --- @param keys number[]
  --- @return Encrypt
  function Encrypt:new(keys)
  	return Nyx.new(self, {
  		keys = keys or { 2, 9, 4, 0, 1 }
  	})
  end
  
  --- Convert characters.
  --- @param chars string
  --- @param dist number
  --- @param inv boolean
  function Encrypt:convert(chars, dist, inv)
  	return string.char((string.byte(chars) - 32 + (inv and -dist or dist)) % 95 + 32)
  end
  
  --- Process input.
  --- @param input string
  --- @param keys table
  --- @param inv boolean
  function Encrypt:process(input, keys, inv)
  	local enc = "";
  
  	if (input == nil) then
  		return " "
  	end
  
  	for i = 1, #input do
  		if (#input - keys[5] >= i or not inv) then
  			for inc = 0, 3 do
  				if (i % 4 == inc) then
  					enc = enc .. self:convert(string.sub(input, i, i), keys[inc + 1], inv);
  					break ;
  				end
  			end
  		end
  	end
  
  	if (not inv) then
  		for _ = 1, keys[5] do
  			enc = enc .. string.char(math.random(32, 126));
  		end
  	end
  
  	return enc;
  end
  
  --- Encrypt string.
  --- @param input string
  --- @return string
  function Encrypt:encrypt(input)
  	return self:process(tostring(input), self.keys)
  end
  
  --- Encrypt string.
  --- @param input string
  --- @return string
  function Encrypt:decrypt(input)
  	return self:process(input, self.keys, true)
  end
  
  return Nyx.class(
  	"Nyx/Encrypt",
  	Encrypt
  )
  --endregion
end
package.preload["gamesense/Nyx/Encrypt"] = function() return return_values["Encrypt"] end
--endregion

--region EventListener
libraries["EventListener"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region EventListener
  --- @class EventListener : Abstract
  --- @field public events table<string, table<number, function>>
  --- @field public enabled boolean
  local EventListener = {
  	events = {},
  	enabled = true
  }
  
  --- @param event string
  --- @param callbackOrData table|function
  --- @return void
  function EventListener.event(event, callbackOrData)
  	if EventListener.enabled == false then
  		return
  	end
  
  	if type(callbackOrData) == "table" then
  		if EventListener.events[event] == nil then
  			return
  		end
  
  		for _, callback in pairs(EventListener.events[event]) do
  			callback(callbackOrData)
  		end
  	elseif type(callbackOrData) == "function" then
  		if EventListener.events[event] == nil then
  			EventListener.events[event] = {}
  		end
  
  		table.insert(EventListener.events[event], callbackOrData)
  	end
  end
  
  return Nyx.abstract(
  	"Nyx/EventListener",
  	EventListener
  )
  --endregion
end
package.preload["gamesense/Nyx/EventListener"] = function() return return_values["EventListener"] end
--endregion

--region LegacyHttp
libraries["LegacyHttp"] = function()
	--region dependency: havoc_http_1_1_0
  --region dependencies
  --region dependency: havoc_timer_3_2_0
  local timer = {}
  local timer_mt = {
  	__index = timer,
  	__call = function(object)
  		return object:get_elapsed_time()
  	end
  }
  
  function timer.curtime(start)
  	start = start or false
  
  	local object = setmetatable(
  		{
  			current_time = globals.curtime,
  			clock_started_at = nil,
  			clock_paused_at = nil,
  			is_using_ticks = false
  		},
  		timer_mt
  	)
  
  	if (start == true) then
  		object:start()
  	end
  
  	return object
  end
  
  function timer.realtime(start)
  	start = start or false
  
  	local object = setmetatable(
  		{
  			current_time = globals.realtime,
  			clock_started_at = nil,
  			clock_paused_at = nil,
  			is_using_ticks = false
  		},
  		timer_mt
  	)
  
  	if (start == true) then
  		object:start()
  	end
  
  	return object
  end
  
  function timer.tickcount(start)
  	start = start or false
  
  	local object = setmetatable(
  		{
  			current_time = globals.tickcount,
  			clock_started_at = nil,
  			clock_paused_at = nil,
  			is_using_ticks = true
  		},
  		timer_mt
  	)
  
  	if (start == true) then
  		object:start()
  	end
  
  	return object
  end
  
  function timer.get_elapsed_time(self)
  	if (self:has_started() == false) then
  		return 0
  	end
  
  	if (self.clock_paused_at ~= nil) then
  		return self.clock_paused_at - self.clock_started_at
  	end
  
  	return self.current_time() - self.clock_started_at
  end
  
  function timer.get_elapsed_time_and_stop(self)
  	local elapsed_time = self:get_elapsed_time()
  
  	self:stop()
  
  	return elapsed_time
  end
  
  function timer.start(self)
  	if (self:has_started() == true) then
  		return
  	end
  
  	self.clock_started_at = self.current_time()
  end
  
  function timer.stop(self)
  	self.clock_paused_at = nil
  	self.clock_started_at = nil
  end
  
  function timer.restart(self)
  	self:stop()
  	self:start()
  end
  
  function timer.pause(self)
  	if (self:has_started() == false) then
  		return
  	end
  
  	self.clock_paused_at = self.current_time()
  end
  
  function timer.unpause(self)
  	if (self:has_started() == false) then
  		return
  	end
  
  	if (self:is_paused() == false) then
  		return
  	end
  
  	local clock_paused_for = self.current_time() - self.clock_paused_at
  
  	self.clock_started_at = self.clock_started_at + clock_paused_for
  	self.clock_paused_at = nil
  end
  
  function timer.toggle_pause(self)
  	if (self:is_paused() == true) then
  		self:unpause()
  	else
  		self:pause()
  	end
  end
  
  function timer.is_paused(self)
  	return self.clock_paused_at ~= nil
  end
  
  function timer.has_started(self)
  	return self.clock_started_at ~= nil
  end
  --endregion
  
  --region dependency: havoc_console_1_0_0
  --region command
  local command_c = {}
  local command_mt = { __index = command_c }
  
  --- Instantiate a command object.
  function command_c.new(name, description, options, on_input)
  	local save_value
  	local persist_value
  
  	if (options.datatype ~= nil) then
  		if (type(options.save_value) == "boolean") then
  			save_value = options.save_value
  		else
  			save_value = true
  		end
  
  		if (save_value == true and type(options.persist_value) == "boolean") then
  			persist_value = options.persist_value
  		else
  			persist_value = true
  		end
  	end
  
  	local properties = {
  		name = name, -- Command name.
  		description = description, -- Command description.
  		on_input = on_input, -- Command callback.
  		on_reset = options.on_reset or nil, -- Command callback when input value is reset.
  		datatype = options.datatype or nil, -- Command datatype.
  		save_value = save_value, -- Save the input value.
  		persist_value = persist_value, -- Persist values to database.
  		value = options.default or nil, -- Command value.
  		default = options.default or nil, -- Command default value.
  		input_value = nil, -- Last value that was attempted to be set.
  		special = options.special or false -- Will submit console object instead of input values to command.
  	}
  
  	local command = setmetatable(properties, command_mt)
  
  	-- Fire the on_load event.
  	if (options.on_load ~= nil) then
  		options.on_load(command)
  	end
  
  	return command
  end
  --endregion
  
  --region state
  local state_c = {}
  local state_mt = { __index = state_c }
  
  --- Instantiate a state object.
  function state_c.new()
  	local properties = {
  		problem = false, -- Console crashed processing a command.
  		reason = nil -- Reason for crash to print to console.
  	}
  
  	local state = setmetatable(properties, state_mt)
  
  	return state
  end
  --endregion
  
  --region console
  local console_c = {}
  local console_mt = { __index = console_c }
  
  --- Instantiate a console object.
  function console_c.new(prefix, options)
  	local properties = {
  		prefix = prefix and prefix .. "_" or nil, -- Command name prefix.
  		log_prefix = options.log_prefix or string.format("[%s]", prefix), -- Logger prefix.
  		log_prefix_color = options.log_prefix_color or { 200, 200, 200 }, -- Log prefix color.
  		debug = options.debug or false, -- Enable or disable debug type logs.
  		commands = {
  			[prefix .. "_help"] = command_c.new(
  				prefix .. "_help",
  				"Display help information for this console command group.",
  				{
  					special = true
  				},
  				function(console)
  					console:log({}, "Command Help")
  					console:log({ prefix = false }, "The following list is all of the available commands for this command group.")
  					console:log({ prefix = false }, " ")
  
  					for _, command in pairs(console.commands) do
  						local title = command.datatype ~= nil and string.format("# %s ( %s arg )", command.name, command.datatype) or "# " .. command.name
  
  						console:log({ prefix = false }, "--------------------")
  						console:log({ prefix = false }, title)
  						console:log({ prefix = false }, command.description)
  
  						if (command.save_value == true and (command.special == false or command.datatype ~= nil)) then
  							console:log({ prefix = false }, string.format("- current value = %s", command.value))
  						end
  
  						if (command.default ~= nil) then
  							console:log({ prefix = false }, string.format("- default value = %s", command.default))
  						end
  
  						if (command.datatype ~= nil) then
  							if (command.save_value == true and command.persist_value == true) then
  								console:log({ prefix = false }, "- persisted = true")
  							else
  								console:log({ prefix = false }, "- persisted = false")
  							end
  						end
  
  						console:log({ prefix = false }, " ")
  					end
  				end
  			),
  			[prefix .. "_reset"] = command_c.new(
  				prefix .. "_reset",
  				"Reset a command to its default value.",
  				{
  					special = true,
  					save_value = false,
  					datatype = "string"
  				},
  				function(console, value)
  					if (value == nil) then
  						console:log({ code = 1 }, "This command requires an argument.")
  
  						return
  					end
  
  					local command = console.commands[value]
  
  					if (command == nil) then
  						console:log({ code = 1 }, "Command was not found.")
  
  						return
  					end
  
  					if (command.default == nil) then
  						console:log({ code = 1 }, "Command does not have a default value to reset to.")
  
  						return
  					end
  
  					command.value = command.default
  
  					command.on_reset(command)
  
  					console:log({ code = 0 }, "Command was reset to its default value of '%s'.", command.default)
  				end
  			)
  		},
  		state = state_c.new(),
  		cast = {
  			-- Cast to string.
  			string = function(value, _)
  				return value
  			end,
  			-- Cast to int.
  			int = function(value, state, command)
  				local value = tonumber(value)
  
  				if (value == nil) then
  					state.problem = true
  					state.reason = string.format(
  						"The argument given to '%s' must be of the type %s.",
  						command.name,
  						command.datatype
  					)
  
  					return nil
  				end
  
  				return math.floor(value + 0.5)
  			end,
  			-- Cast to float.
  			float = function(value, state, command)
  				local value = tonumber(value)
  
  				if (value == nil) then
  					state.problem = true
  					state.reason = string.format(
  						"The argument given to '%s' must be of the type %s.",
  						command.name,
  						command.datatype
  					)
  
  					return nil
  				end
  
  				return value
  			end,
  			-- Cast to bool.
  			bool = function(value, _)
  				return value and 1 or 0
  			end
  		}
  	}
  
  	local console = setmetatable(properties, console_mt)
  
  	-- Setup events.
  	console:setup_events(console)
  
  	return console
  end
  
  --- Assert.
  function console_c.assert(expression, level, message, ...)
  	if (not expression) then
  		error(string.format(message, ...), level)
  	end
  end
  
  --- Setup game events.
  function console_c:setup_events(console)
  	-- Hook console input event.
  	client.set_event_callback("console_input", function(console_input)
  		-- Process console input.
  		return console:process(console_input)
  	end)
  
  	-- Hook shutdown event for database write.
  	client.set_event_callback("shutdown", function()
  		for _, command in pairs(console.commands) do
  			-- If not a special command and if command has an argument.
  			if (command.special == false or command.datatype ~= nil) then
  
  				-- Save current value or persist default.
  				if (command.persist_value == true) then
  					database.write(
  						string.format("havoc_console_%s", command.name),
  						command.value
  					)
  				else
  					database.write(
  						string.format("havoc_console_%s", command.name),
  						command.default
  					)
  				end
  
  			end
  		end
  	end)
  end
  
  --- Log message to console.
  function console_c:log(options, ...)
  	-- Do not output debug logs if debugging is not enabled.
  	if (self.debug == false and options.debug == true) then
  		return
  	end
  
  	local prefix = options.prefix
  	local code = type(options.code) == "number" and options.code or -1
  
  	-- Print prefix.
  	if (prefix == nil or prefix == true) then
  		client.color_log(self.log_prefix_color[1], self.log_prefix_color[2], self.log_prefix_color[3], self.log_prefix .. " \0")
  	end
  
  	-- Print codes.
  	if (self.state.problem == true) then
  		client.color_log(255, 75, 75, "[BAD INPUT] \0")
  	elseif (code == 0) then
  		client.color_log(75, 255, 75, "[SUCCESS] \0")
  	elseif (code == 1) then
  		client.color_log(255, 75, 75, "[ERROR] \0")
  	elseif (code == 2) then
  		client.color_log(255, 125, 75, "[WARNING] \0")
  	end
  
  	-- Print message string.
  	client.color_log(240, 240, 240, string.format(...), "\0")
  
  	-- Color top-left logs.
  	if (self.state.problem == true) then
  		client.color_log(255, 75, 75, " ")
  	elseif (code == 0) then
  		client.color_log(75, 255, 75, " ")
  	elseif (code == 1) then
  		client.color_log(255, 75, 75, " ")
  	elseif (code == 2) then
  		client.color_log(255, 125, 75, " ")
  	else
  		client.color_log(240, 240, 240, " ")
  	end
  end
  
  --- Add a console command.
  function console_c:command(name, description, options, on_input)
  	console_c.assert(type(name) == "string", 2, "Command name must be strings.")
  	console_c.assert(type(description) == "string", 2, "Command description must be strings.")
  	console_c.assert(
  		type(options) == "table" or type(options) == "nil",
  		2,
  		"Command options must be a table or nil."
  	)
  	console_c.assert(type(on_input) == "function", 2, "Command callbacks must be functions.")
  
  	-- Create the command.
  	local command = command_c.new(
  		self.prefix .. name,
  		description,
  		options,
  		on_input
  	)
  
  	-- Update command from database.
  	if (command.special == false or command.datatype ~= nil) then
  		-- Read from database.
  		local value = database.read(
  			string.format("havoc_console_%s", command.name)
  		)
  
  		-- Only update if a value exists.
  		if (value ~= nil) then
  			command.value = value
  		end
  
  	end
  
  	-- Add the command.
  	self.commands[self.prefix .. name] = command
  end
  
  --- Process console input.
  --- Returns true if command was found. False if not.
  function console_c:process(console_input)
  	local command = self:_format_console_input(console_input)
  
  	-- Do not process faulty console input.
  	if (self.state.problem == true) then
  		-- Print problem to console.
  		self:log({}, self.state.reason)
  
  		-- Reset state.
  		self.state.problem = false
  
  		-- Console command was found.
  		-- But do not continue processing the console input.
  		return true
  	end
  
  	if (command == nil) then
  		-- Console command was not found.
  		return false
  	end
  
  	-- Ignore special commands.
  	if (command.special == false) then
  		-- Update command's current value.
  		if (command.save_value == true) then
  			command.value = command.input_value
  		end
  
  		-- Call the command's callback.
  		command.on_input(command.input_value)
  	end
  
  	-- Command was found and executed.
  	return true
  end
  
  --- Returns command name and command argument (if applicable).
  function console_c:_format_console_input(console_input)
  	local i = 1
  	local name
  	local argument
  
  	-- I hate this code too.
  	for component in string.gmatch(console_input, "%S+") do
  		-- Set command name.
  		if (i == 1) then
  			name = component
  		else
  			if (i == 2) then
  				-- First argument component.
  				argument = component
  			else
  				-- Other argument components.
  				argument = argument .. " " .. component
  			end
  		end
  
  		i = i + 1
  	end
  
  	-- Get the command provided.
  	local command = self.commands[name]
  
  	-- Invalid command name.
  	if (command == nil) then
  		return nil
  	end
  
  	-- Run special command callback and return.
  	if (command.special == true) then
  		command.on_input(self, argument)
  
  		return command
  	end
  
  	-- Argument was expected.
  	if (command.datatype ~= nil and argument == nil) then
  		self.state.problem = true
  		self.state.reason = string.format(
  			"Command '%s' expects an argument to be given (%s).",
  			command.name,
  			command.datatype
  		)
  
  		return nil
  	end
  
  	if (command.datatype ~= nil and argument ~= nil) then
  		-- Cast argument to command datatype.
  		argument = self.cast[command.datatype](argument, self.state, command)
  
  		-- Set last attempted value.
  		command.input_value = argument
  	end
  
  	return command
  end
  --endregion
  --endregion
  
  --region dependency: json_0_1_2
  local json = { _version = "0.1.2" }
  
  -------------------------------------------------------------------------------
  -- Encode
  -------------------------------------------------------------------------------
  
  local encode
  
  local escape_char_map = {
  	['\\'] = '\\\\',
  	['\"'] = '\\\"',
  	['\b'] = '\\b',
  	['\f'] = '\\f',
  	['\n'] = '\\n',
  	['\r'] = '\\r',
  	['\t'] = '\\t',
  }
  
  local escape_char_map_inv = { ["\\/"] = "/" }
  for k, v in pairs(escape_char_map) do
  	escape_char_map_inv[v] = k
  end
  
  local function escape_char(c)
  	return escape_char_map[c] or string.format("\\u%04x", c:byte())
  end
  
  local function encode_nil(_)
  	return "null"
  end
  
  local function encode_table(val, stack)
  	local res = {}
  	stack = stack or {}
  
  	-- Circular reference?
  	if stack[val] then
  		error("circular reference")
  	end
  
  	stack[val] = true
  
  	if rawget(val, 1) ~= nil or next(val) == nil then
  		-- Treat as array -- check keys are valid and it is not sparse
  		local n = 0
  		for k in pairs(val) do
  			if type(k) ~= "number" then
  				error("invalid table: mixed or invalid key types")
  			end
  			n = n + 1
  		end
  		if n ~= #val then
  			error("invalid table: sparse array")
  		end
  		-- Encode
  		for _, v in ipairs(val) do
  			table.insert(res, encode(v, stack))
  		end
  		stack[val] = nil
  		return "[" .. table.concat(res, ",") .. "]"
  
  	else
  		-- Treat as an object
  		for k, v in pairs(val) do
  			if type(k) ~= "string" then
  				error("invalid table: mixed or invalid key types")
  			end
  			table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
  		end
  		stack[val] = nil
  		return "{" .. table.concat(res, ",") .. "}"
  	end
  end
  
  local function encode_string(val)
  	return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
  end
  
  local function encode_number(val)
  	-- Check for NaN, -inf and inf
  	if val ~= val or val <= -math.huge or val >= math.huge then
  		error("unexpected number value '" .. tostring(val) .. "'")
  	end
  	return string.format("%.14g", val)
  end
  
  local type_func_map = {
  	["nil"] = encode_nil,
  	["table"] = encode_table,
  	["string"] = encode_string,
  	["number"] = encode_number,
  	["boolean"] = tostring,
  }
  
  encode = function(val, stack)
  	local t = type(val)
  	local f = type_func_map[t]
  	if f then
  		return f(val, stack)
  	end
  	error("unexpected type '" .. t .. "'")
  end
  
  function json.encode(val)
  	return (encode(val))
  end
  
  
  -------------------------------------------------------------------------------
  -- Decode
  -------------------------------------------------------------------------------
  
  local parse
  
  local function create_set(...)
  	local res = {}
  	for i = 1, select("#", ...) do
  		res[select(i, ...)] = true
  	end
  	return res
  end
  
  local space_chars = create_set(" ", "\t", "\r", "\n")
  local delim_chars = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
  local escape_chars = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
  local literals = create_set("true", "false", "null")
  
  local literal_map = {
  	["true"] = true,
  	["false"] = false,
  	["null"] = nil,
  }
  
  local function next_char(str, idx, set, negate)
  	for i = idx, #str do
  		if set[str:sub(i, i)] ~= negate then
  			return i
  		end
  	end
  	return #str + 1
  end
  
  local function decode_error(str, idx, msg)
  	local line_count = 1
  	local col_count = 1
  	for i = 1, idx - 1 do
  		col_count = col_count + 1
  		if str:sub(i, i) == "\n" then
  			line_count = line_count + 1
  			col_count = 1
  		end
  	end
  	error(string.format("%s at line %d col %d", msg, line_count, col_count))
  end
  
  local function codepoint_to_utf8(n)
  	-- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  	local f = math.floor
  	if n <= 0x7f then
  		return string.char(n)
  	elseif n <= 0x7ff then
  		return string.char(f(n / 64) + 192, n % 64 + 128)
  	elseif n <= 0xffff then
  		return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  	elseif n <= 0x10ffff then
  		return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
  			f(n % 4096 / 64) + 128, n % 64 + 128)
  	end
  	error(string.format("invalid unicode codepoint '%x'", n))
  end
  
  local function parse_unicode_escape(s)
  	local n1 = tonumber(s:sub(3, 6), 16)
  	local n2 = tonumber(s:sub(9, 12), 16)
  	-- Surrogate pair?
  	if n2 then
  		return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  	else
  		return codepoint_to_utf8(n1)
  	end
  end
  
  local function parse_string(str, i)
  	local has_unicode_escape = false
  	local has_surrogate_escape = false
  	local has_escape = false
  	local last
  	for j = i + 1, #str do
  		local x = str:byte(j)
  
  		if x < 32 then
  			decode_error(str, j, "control character in string")
  		end
  
  		if last == 92 then
  			-- "\\" (escape char)
  			if x == 117 then
  				-- "u" (unicode escape sequence)
  				local hex = str:sub(j + 1, j + 5)
  				if not hex:find("%x%x%x%x") then
  					decode_error(str, j, "invalid unicode escape in string")
  				end
  				if hex:find("^[dD][89aAbB]") then
  					has_surrogate_escape = true
  				else
  					has_unicode_escape = true
  				end
  			else
  				local c = string.char(x)
  				if not escape_chars[c] then
  					decode_error(str, j, "invalid escape char '" .. c .. "' in string")
  				end
  				has_escape = true
  			end
  			last = nil
  
  		elseif x == 34 then
  			-- '"' (end of string)
  			local s = str:sub(i + 1, j - 1)
  			if has_surrogate_escape then
  				s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
  			end
  			if has_unicode_escape then
  				s = s:gsub("\\u....", parse_unicode_escape)
  			end
  			if has_escape then
  				s = s:gsub("\\.", escape_char_map_inv)
  			end
  			return s, j + 1
  
  		else
  			last = x
  		end
  	end
  	decode_error(str, i, "expected closing quote for string")
  end
  
  local function parse_number(str, i)
  	local x = next_char(str, i, delim_chars)
  	local s = str:sub(i, x - 1)
  	local n = tonumber(s)
  	if not n then
  		decode_error(str, i, "invalid number '" .. s .. "'")
  	end
  	return n, x
  end
  
  local function parse_literal(str, i)
  	local x = next_char(str, i, delim_chars)
  	local word = str:sub(i, x - 1)
  	if not literals[word] then
  		decode_error(str, i, "invalid literal '" .. word .. "'")
  	end
  	return literal_map[word], x
  end
  
  local function parse_array(str, i)
  	local res = {}
  	local n = 1
  	i = i + 1
  	while 1 do
  		local x
  		i = next_char(str, i, space_chars, true)
  		-- Empty / end of array?
  		if str:sub(i, i) == "]" then
  			i = i + 1
  			break
  		end
  		-- Read token
  		x, i = parse(str, i)
  		res[n] = x
  		n = n + 1
  		-- Next token
  		i = next_char(str, i, space_chars, true)
  		local chr = str:sub(i, i)
  		i = i + 1
  		if chr == "]" then
  			break
  		end
  		if chr ~= "," then
  			decode_error(str, i, "expected ']' or ','")
  		end
  	end
  	return res, i
  end
  
  local function parse_object(str, i)
  	local res = {}
  	i = i + 1
  	while 1 do
  		local key, val
  		i = next_char(str, i, space_chars, true)
  		-- Empty / end of object?
  		if str:sub(i, i) == "}" then
  			i = i + 1
  			break
  		end
  		-- Read key
  		if str:sub(i, i) ~= '"' then
  			decode_error(str, i, "expected string for key")
  		end
  		key, i = parse(str, i)
  		-- Read ':' delimiter
  		i = next_char(str, i, space_chars, true)
  		if str:sub(i, i) ~= ":" then
  			decode_error(str, i, "expected ':' after key")
  		end
  		i = next_char(str, i + 1, space_chars, true)
  		-- Read value
  		val, i = parse(str, i)
  		-- Set
  		res[key] = val
  		-- Next token
  		i = next_char(str, i, space_chars, true)
  		local chr = str:sub(i, i)
  		i = i + 1
  		if chr == "}" then
  			break
  		end
  		if chr ~= "," then
  			decode_error(str, i, "expected '}' or ','")
  		end
  	end
  	return res, i
  end
  
  local char_func_map = {
  	['"'] = parse_string,
  	["0"] = parse_number,
  	["1"] = parse_number,
  	["2"] = parse_number,
  	["3"] = parse_number,
  	["4"] = parse_number,
  	["5"] = parse_number,
  	["6"] = parse_number,
  	["7"] = parse_number,
  	["8"] = parse_number,
  	["9"] = parse_number,
  	["-"] = parse_number,
  	["t"] = parse_literal,
  	["f"] = parse_literal,
  	["n"] = parse_literal,
  	["["] = parse_array,
  	["{"] = parse_object,
  }
  
  parse = function(str, idx)
  	local chr = str:sub(idx, idx)
  	local f = char_func_map[chr]
  	if f then
  		return f(str, idx)
  	end
  	decode_error(str, idx, "unexpected character '" .. chr .. "'")
  end
  
  function json.decode(str)
  	if type(str) ~= "string" then
  		error("expected argument of type string, got " .. type(str))
  	end
  	local res, idx = parse(str, next_char(str, 1, space_chars, true))
  	idx = next_char(str, idx, space_chars, true)
  	if idx <= #str then
  		decode_error(str, idx, "trailing garbage")
  	end
  	return res
  end
  --endregion
  --endregion
  
  --region ffi
  local ffi = require("ffi")
  
  ffi.cdef [[
  		// HTTP Request handle type.
  		typedef uint32_t request_handle_t;
  
  		// Cookie Container handle type.
  		typedef uint32_t cookie_container_handle_t;
  
  		// Steam API call type.
  		typedef uint64_t steam_api_call_t;
  
  		typedef struct {
  			void* __pad[11];
  			void* steam_http;
  		} LegacySteamHttptx_t;
  
  		// Create a request.
  		typedef uint32_t(__thiscall* create_http_request_t)(void*, uint32_t, const char*);
  
  		// Send a request.
  		typedef bool(__thiscall* send_http_request_t)(void* _this, request_handle_t handle, steam_api_call_t call_handle);
  
  		// Release a request.
  		typedef bool(__thiscall* release_http_request_t)(void* _this, request_handle_t hRequest);
  
  		// Create a cookie container.
  		typedef uint32_t(__thiscall* create_cookie_container_t)(void*, bool bAllowResponsesToModify);
  
  		// Release cookie container.
  		typedef bool(__thiscall* release_cookie_container_t)(void* _this, cookie_container_handle_t hCookieContainer);
  
  		// Set a cookie.
  		typedef bool(__thiscall* set_cookie_t)(void* _this, cookie_container_handle_t hCookieContainer, const char *pchHost, const char *pchUrl, const char *pchCookie);
  
  		// Get response header size.
  		typedef bool(__thiscall* get_http_response_header_size_t)( void* _this, request_handle_t hRequest, const char *pchHeaderName, uint32_t *unResponseHeaderSize);
  
  		// Get response header value.
  		typedef bool(__thiscall* get_http_response_header_value_t)(void* _this, request_handle_t hRequest, const char *pchHeaderName, char *pHeaderValueBuffer, uint32_t unBufferSize);
  
  		// Get response body size.
  		typedef bool(__thiscall* get_http_response_body_size_t)(void* _this, request_handle_t hRequest, uint32_t *unBodySize );
  
  		// Get response body data.
  		typedef bool(__thiscall* get_http_response_body_data_t)(void* _this, request_handle_t hRequest, char *pBodyDataBuf, uint32_t unBufferSize );
  
  		// Get download progress percentage.
  		typedef bool(__thiscall* get_http_download_progress_pct_t)(void* _this, request_handle_t hRequest, float *pflPercentOut);
  
  		// Set GET or POST parameters.
  		typedef bool(__thiscall* set_http_request_param_t)(void* _this, request_handle_t hRequest, const char* pchParamName, const char* pchParamValue);
  
  		// Set request header value.
  		typedef bool(__thiscall* set_http_request_header_value_t)(void* _this, request_handle_t handle, const char *pchHeaderName, const char *pchHeaderValue);
  
  		// Set cookie container on request.
  		typedef bool(__thiscall* set_http_LegacyHttpRequestookie_container_t)(void* _this, request_handle_t hRequest, cookie_container_handle_t hCookieContainer);
  
  		// Set User-Agent postfix.
  		typedef bool(__thiscall* set_http_request_user_agent_info_t)(void* _this, request_handle_t hRequest, const char *pchUserAgentInfo);
  	]]
  --endregion
  
  --region steam
  --- @class LegacySteamHttp
  local LegacySteamHttp = {}
  local steam_mt = { __index = LegacySteamHttp }
  
  --- Instantiate a steam object.
  --- @return LegacySteamHttp
  function LegacySteamHttp.new()
  	local native_ConnectToGlobalUser = vtable_bind("steamclient.dll", "SteamClient020", 2, "int(__thiscall*)(void*, int)")
  
  	local native_GetISteamHTTP = vtable_bind("steamclient.dll", "SteamClient020", 24, "void*(__thiscall*)(void*, int, int, const char*)")
  
  	local hsteampipe = 1
  	local hsteamuser = native_ConnectToGlobalUser(hsteampipe)
  
  	local steam_http = native_GetISteamHTTP(hsteampipe, hsteamuser, "STEAMHTTP_INTERFACE_VERSION003")
  
  	local steam_http_ptr = ffi.cast("void***", steam_http) or error("[HTTP] [ERROR] Steam HTTP FFI pointer fail.")
  	local steam_http_vtable = steam_http_ptr[0] or error("[HTTP] [ERROR] Steam HTTP FFI vtable fail.")
  
  	local properties = {}
  	local steam = setmetatable(properties, steam_mt)
  
  	steam.http = steam_http
  	steam.create_http_request = ffi.cast("create_http_request_t", steam_http_vtable[0])
  	steam.send_http_request = ffi.cast("send_http_request_t", steam_http_vtable[5])
  	steam.release_http_request = ffi.cast("release_http_request_t", steam_http_vtable[14])
  	steam.create_cookie_container = ffi.cast("create_cookie_container_t", steam_http_vtable[17])
  	steam.release_cookie_container = ffi.cast("release_cookie_container_t", steam_http_vtable[18])
  	steam.set_cookie = ffi.cast("set_cookie_t", steam_http_vtable[19])
  	steam.get_http_response_header_size = ffi.cast("get_http_response_header_size_t", steam_http_vtable[9])
  	steam.get_http_response_header_value = ffi.cast("get_http_response_header_value_t", steam_http_vtable[10])
  	steam.get_http_response_body_size = ffi.cast("get_http_response_body_size_t", steam_http_vtable[11])
  	steam.get_http_response_body_data = ffi.cast("get_http_response_body_data_t", steam_http_vtable[12])
  	steam.get_http_download_progress_pct = ffi.cast("get_http_download_progress_pct_t", steam_http_vtable[15])
  	steam.set_http_request_header_value = ffi.cast("set_http_request_header_value_t", steam_http_vtable[3])
  	steam.set_http_request_param = ffi.cast("set_http_request_param_t", steam_http_vtable[4])
  	steam.set_http_LegacyHttpRequestookie_container = ffi.cast("set_http_LegacyHttpRequestookie_container_t", steam_http_vtable[20])
  	steam.set_http_request_user_agent_info = ffi.cast("set_http_request_user_agent_info_t", steam_http_vtable[21])
  
  	return steam
  end
  --endregion
  
  --region size
  --- @class LegacyHttpSize
  local LegacyHttpSize = {}
  local size_mt = {
  	__index = LegacyHttpSize,
  	__call = function(size, precision)
  		if (type(precision) == "number") then
  			return size:formatted(precision)
  		end
  
  		return size.value
  	end
  }
  
  --- Instantiate a size object.
  --- @return LegacyHttpSize
  function LegacyHttpSize.new(size)
  	local properties = {
  		value = size,
  		suffix = { "B", "KB", "MB", "GB", "TB" }
  	}
  
  	local size = setmetatable(properties, size_mt)
  
  	return size
  end
  
  --- Return the size formatted.
  --- @return string
  function LegacyHttpSize:formatted(precision)
  	local base = math.log(self.value, 10) / math.log(1000, 10)
  	local size = math.pow(1000, base - math.floor(base))
  	local round_mult = 10 ^ (precision or 0)
  
  	size = math.floor(size * round_mult + 0.5) / round_mult
  
  	return string.format(
  		"%s %s",
  		size,
  		self.suffix[math.floor(base) + 1]
  	)
  end
  --endregion
  
  --region request
  --- @class LegacyHttpRequest
  local LegacyHttpRequest = {}
  local request_mt = { __index = LegacyHttpRequest }
  
  --- Instantiate a request object.
  --- @return LegacyHttpRequest
  function LegacyHttpRequest.new(handle, url, method, options)
  	options = options or {}
  
  	local properties = {
  		handle = handle, -- HTTP request handle.
  		url = url, -- HTTP request URL.
  		method = method, -- HTTP request method.
  		headers = {
  			request = options.requestHeaders or {}, -- HTTP request headers.
  			response = options.responseHeaders or {} -- Subscribed HTTP response headers.
  		},
  		parameters = options.parameters or {}, -- HTTP GET/POST parameters.
  		timeout = {
  			absolute = {
  				timer = timer.realtime(false),
  				after = options.absoluteTimeout or 0 -- Timeout request after given time in seconds.
  			},
  			activity = {
  				timer = timer.realtime(false),
  				after = options.activityTimeout or 60 -- Timeout request after given time in seconds.
  			}
  		},
  		callbacks = {
  			on_send = options.onSend or nil, -- On request has been sent.
  			on_receiving = options.onReceiving or nil, -- On receiving response.
  			on_response = options.onResponse or nil, -- On response completed.
  			on_timeout = options.onTimeout or nil, -- On response timeout.
  			on_give_up = options.onGiveUp or nil -- On server not accessible.
  		},
  		last_completion = 0, -- Last completion percentage. Used for stream timeout.
  		completion = 0, -- Completion percentage.
  		retries = {
  			current = 0, -- Attempted retries.
  			max = options.retries or 0, -- Number of retries to perform.
  			delay = options.retryDelay or 0 -- Time to wait before retrying.
  		},
  		-- 0 = unsent
  		-- 1 = sent
  		-- 2 = receiving
  		-- 3 = timeout (retry)
  		-- 4 = timeout (stop)
  		state = 0
  	}
  
  	local request = setmetatable(properties, request_mt)
  
  	-- Add some response headers by default.
  	table.insert(request.headers.response, "Content-Type")
  	table.insert(request.headers.response, "Content-Length")
  	table.insert(request.headers.response, "Cookie")
  
  	return request
  end
  
  --- Clone request to retry.
  --- @return void
  function LegacyHttpRequest:refresh(new_handle)
  	self.handle = new_handle
  	self.completion = 0
  	self.retries.current = self.retries.current + 1
  
  	self.timeout.absolute.timer:stop()
  	self.timeout.activity.timer:stop()
  end
  --endregion
  
  --region response
  --- @class LegacyHttpResponse
  --- @field public url string
  --- @field public body string
  --- @field public size LegacyHttpSize
  --- @field public headers table
  --- @field public cookies table
  local LegacyHttpResponse = {}
  local response_mt = { __index = LegacyHttpResponse }
  
  --- Instantiate a response object.
  --- @return LegacyHttpResponse
  function LegacyHttpResponse.new(request, body, size)
  	local properties = {
  		url = request.url, -- Response URL origin.
  		body = body, -- Response body.
  		size = LegacyHttpSize.new(size), -- Response body size.
  		headers = {}, -- Response headers.
  		cookies = {} -- Cookies.
  	}
  
  	local response = setmetatable(properties, response_mt)
  
  	return response
  end
  --endregion
  
  --region http
  --- @class LegacyHttp
  local LegacyHttp = {
  	method = {
  		get = 1, -- HTTP get method.
  		head = 2, -- HTTP head method.
  		post = 3, -- HTTP post method.
  		put = 4, -- HTTP put method.
  		delete = 5, -- HTTP delete method.
  		options = 6, -- HTTP options method.
  		patch = 7 -- HTTP patch method.
  	}
  }
  
  local http_mt = { __index = LegacyHttp }
  
  --- Instantiate a http object.
  --- @return LegacyHttp
  function LegacyHttp:new(options)
  	options = options or {}
  
  	local properties = {
  		steam = LegacySteamHttp.new(), -- Steam.
  		console = console_c.new(
  			"http",
  			{
  				log_prefix = "[HTTP]",
  				log_prefix_color = { 255, 133, 168 },
  				debug = options.debug or false, -- Console debugging mode.
  			}
  		),
  		service = {
  			requests = {}, -- Queued requests.
  			interval = options.interval or 0.5, -- Request process interval.
  			user_agent = options.user_agent or "Havoc", -- User agent postfix.
  			cookie_container = nil, -- Session cookie container.
  		}
  	}
  
  	local http = setmetatable(properties, http_mt)
  
  	-- Create a new cookie container for this HTTP session.
  	http.service.cookie_container = http.steam.create_cookie_container(http.steam.http, true)
  		or error("Cannot create cookie container.")
  
  	-- Begin servicing all HTTP requests.
  	http:_service_requests()
  
  	-- Shutdown event.
  	client.set_event_callback("shutdown", function()
  		-- Release cookie container.
  		http.steam.release_cookie_container(http.steam.http, http.service.cookie_container)
  	end)
  
  	return http
  end
  
  --- Send a get request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:get(url, options)
  	return self:request("get", url, options)
  end
  
  --- Send a head request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:head(url, options)
  	return self:request("head", url, options)
  end
  
  --- Send a post request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:post(url, options)
  	return self:request("post", url, options)
  end
  
  --- Send a put request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:put(url, options)
  	return self:request("put", url, options)
  end
  
  --- Send a delete request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:delete(url, options)
  	return self:request("delete", url, options)
  end
  
  --- Send a options request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:options(url, options)
  	return self:request("options", url, options)
  end
  
  --- Send a patch request.
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:patch(url, options)
  	return self:request("patch", url, options)
  end
  
  --- Submit an HTTP request to be sent.
  --- @param method string
  --- @param url string
  --- @param options HttpRequestOptions
  --- @return boolean
  function LegacyHttp:request(method, url, options)
  	-- Create an HTTP request handle.
  	local handle = self.steam.create_http_request(self.steam.http, LegacyHttp.method[method], url)
  
  	-- Create the request object.
  	local request = LegacyHttpRequest.new(handle, url, method, options)
  
  	-- Set all request headers on handle.
  	for header_name, header_value in pairs(request.headers.request) do
  		self.steam.set_http_request_header_value(self.steam.http, handle, header_name, header_value)
  	end
  
  	-- Set GET/POST request parameters.
  	for parameter_name, parameter_value in pairs(request.parameters) do
  		self.steam.set_http_request_param(self.steam.http, handle, parameter_name, parameter_value)
  	end
  
  	-- Set cookie container on request.
  	self.steam.set_http_LegacyHttpRequestookie_container(self.steam.http, self.service.cookie_container, handle)
  
  	-- Set user agent info.
  	if (self.service.user_agent ~= nil) then
  		self.steam.set_http_request_user_agent_info(self.steam.http, handle, self.service.user_agent)
  	end
  
  	-- Send HTTP request.
  	if (self.steam.send_http_request(self.steam.http, handle, 0) == false) then
  		-- We cannot process the request.
  		return false
  	end
  
  	-- Begin the timeout timers.
  	request.timeout.absolute.timer:start()
  	request.timeout.activity.timer:start()
  
  	-- Request state "sent".
  	request.state = 1
  
  	-- Fire on_send event.
  	if (request.callbacks.on_send ~= nil) then
  		request.callbacks.on_send(request)
  	end
  
  	self.console:log({debug = true}, "Request #%s - %s", handle, request.url)
  
  	-- Add request to service queue.
  	self.service.requests[handle] = request
  
  	-- Request successfully sent.
  	return true
  end
  
  --- Resend an already generated HTTP request.
  --- @param request LegacyHttpRequest
  --- @return boolean
  function LegacyHttp:retry_request(request)
  	-- Old request handle.
  	local old_handle = request.handle
  
  	-- Create an HTTP request handle.
  	local handle = self.steam.create_http_request(self.steam.http, LegacyHttp.method[request.method], request.url)
  
  	-- Refresh request.
  	request:refresh(handle)
  
  	-- Set all request headers on handle.
  	for header_name, header_value in pairs(request.headers.request) do
  		self.steam.set_http_request_header_value(self.steam.http, handle, header_name, header_value)
  	end
  
  	-- Set GET/POST request parameters.
  	for parameter_name, parameter_value in pairs(request.parameters) do
  		self.steam.set_http_request_param(self.steam.http, handle, parameter_name, parameter_value)
  	end
  
  	-- Set cookie container on request.
  	self.steam.set_http_LegacyHttpRequestookie_container(self.steam.http, self.service.cookie_container, handle)
  
  	-- Set user agent info.
  	if (self.service.user_agent ~= nil) then
  		self.steam.set_http_request_user_agent_info(self.steam.http, handle, self.service.user_agent)
  	end
  
  	client.delay_call(request.retries.delay, function()
  		-- Send HTTP request.
  		if (self.steam.send_http_request(self.steam.http, handle, 0) == false) then
  			-- We cannot process the request.
  			return false
  		end
  
  		-- Begin the timeout timers.
  		request.timeout.absolute.timer:start()
  		request.timeout.activity.timer:start()
  
  		-- Request state "sent".
  		request.state = 1
  
  		-- Fire on_send event.
  		if (request.callbacks.on_send ~= nil) then
  			request.callbacks.on_send(request)
  		end
  
  		self.console:log({debug = true, code = 2}, "Request #%s (retry of %s) - %s", handle, old_handle, request.url)
  
  		-- Add request to service queue.
  		self.service.requests[handle] = request
  	end)
  
  	-- Request successfully sent.
  	return true
  end
  
  --- Service all requests.
  --- @return void
  function LegacyHttp:_service_requests()
  	-- Process all open requests.
  	for request_handle, request in pairs(self.service.requests) do
  		-- Kill request at end of processing.
  		local request_kill = false
  
  		-- Update the download progress.
  		self:_set_download_progress(request)
  
  		-- Request body size pointer.
  		local body_size_ptr = ffi.new("uint32_t[1]")
  
  		-- HTTP request completed.
  		if (self.steam.get_http_response_body_size(self.steam.http, request_handle, body_size_ptr) == true) then
  			-- Set response body size.
  			local body_size = body_size_ptr[0]
  
  			-- Response body.
  			local body = ffi.new("char[?]", body_size)
  
  			-- HTTP request completed.
  			if (self.steam.get_http_response_body_data(self.steam.http, request_handle, body, body_size) == true) then
  				-- Create response.
  				local response = LegacyHttpResponse.new(request, ffi.string(body, body_size), body_size)
  
  				-- Set response headers.
  				self:_set_headers(request, response)
  
  				-- Set cookies.
  				self:_set_cookies(response)
  
  				-- Request is 100% completed.
  				request.completion = 100
  
  				-- Kill request.
  				request_kill = true
  
  				-- Fire on_response event.
  				if (request.callbacks.on_response ~= nil) then
  					self.console:log({ debug = true, code = 0 }, "Response to request #%s received.", request_handle)
  
  					request.callbacks.on_response(response)
  				end
  
  				-- Release HTTP request.
  				self.steam.release_http_request(self.steam.http, request_handle)
  			end
  		end
  
  		-- Kill a request once it times out.
  		if (
  			(request.timeout.absolute.after > 0 and request.timeout.absolute.timer() > request.timeout.absolute.after) or
  				(request.timeout.activity.after > 0 and request.timeout.activity.timer() > request.timeout.activity.after)
  		) then
  			-- Kill request.
  			request_kill = true
  
  			-- Fire on_timeout event.
  			if (request.callbacks.on_timeout ~= nil) then
  				-- Fire on timeout event.
  				request.callbacks.on_timeout(request)
  			end
  
  			-- Release HTTP request.
  			self.steam.release_http_request(self.steam.http, request_handle)
  
  			-- Attempt to retry requests until exhausted.
  			if (request.retries.current < request.retries.max) then
  				self.console:log({ debug = true, code = 1 }, "Request #%s timed out.", request_handle)
  
  				-- Request state "timeout (retry)".
  				request.state = 3
  
  				self:retry_request(request)
  			else
  				-- Request state "timeout (stop)".
  				request.state = 4
  
  				-- Fire on_give_up event.
  				if (request.callbacks.on_give_up ~= nil) then
  					request.callbacks.on_give_up(request)
  				end
  
  				self.console:log({ debug = true, code = 1 }, "Request #%s timed out. Reached maximum retries and will not attempt the request again.", request_handle)
  			end
  		end
  
  		-- Remove request from queue.
  		if (request_kill == true) then
  			self.service.requests[request_handle] = nil
  		end
  	end
  
  	-- Repeat processing requests.
  	client.delay_call(self.service.interval, function()
  		self._service_requests(self)
  	end)
  end
  
  --- Set an HTTP response's download progress.
  --- @param request LegacyHttpRequest
  --- @return void
  function LegacyHttp:_set_download_progress(request)
  	-- Download completion pointer.
  	local progress_ptr = ffi.new("float[1]")
  
  	-- HTTP download in progress.
  	-- This is only available when the Content-Length header is set.
  	if (self.steam.get_http_download_progress_pct(self.steam.http, request.handle, progress_ptr) == true) then
  		-- Set request completion percentage.
  		request.completion = progress_ptr[0]
  
  		-- Fire on_receiving event.
  		if (request.callbacks.on_receiving ~= nil) then
  			request.callbacks.on_receiving(request)
  		end
  
  		-- Bump the network activity timeout.
  		if (request.completion ~= request.last_completion) then
  			-- Restart the timer.
  			request.timeout.activity.timer:restart()
  
  			-- Resynchronise completion properties.
  			request.last_completion = request.completion
  		end
  
  		-- Request state "receiving".
  		request.state = 2
  	end
  end
  
  --- Set an HTTP response's headers.
  --- @param request LegacyHttpRequest
  --- @param response LegacyHttpResponse
  --- @return void
  function LegacyHttp:_set_headers(request, response)
  	-- Loop over all response headers we want to set.
  	for _, header in pairs(request.headers.response) do
  		-- Header size pointer.
  		local header_size_ptr = ffi.new("uint32_t[1]")
  
  		-- Get the header.
  		if (self.steam.get_http_response_header_size(self.steam.http, request.handle, header, header_size_ptr) == true) then
  			-- Header size.
  			local header_size = header_size_ptr[0]
  
  			-- Header buffer.
  			local header_buffer = ffi.new("char[?]", header_size)
  
  			-- Return header.
  			if (self.steam.get_http_response_header_value(self.steam.http, request.handle, header, header_buffer, header_size) == true) then
  				-- Get header value.
  				local header_value = ffi.string(header_buffer, header_size)
  
  				-- Set header value and remove terminating character.
  				response.headers[header] = string.sub(header_value, 1, string.len(header_value) - 1)
  			end
  		end
  	end
  end
  
  --- Get a single HTTP header.
  --- @param request LegacyHttpRequest
  --- @param header string
  --- @return string|nil
  function LegacyHttp:_get_header(request, header)
  	-- Header size pointer.
  	local header_size_ptr = ffi.new("uint32_t[1]")
  
  	-- Get the header.
  	if (self.steam.get_http_response_header_size(self.steam.http, request.handle, header, header_size_ptr) == true) then
  		-- Header size.
  		local header_size = header_size_ptr[0]
  
  		-- Header buffer.
  		local header_buffer = ffi.new("char[?]", header_size)
  
  		-- Return header.
  		if (self.steam.get_http_response_header_value(self.steam.http, request.handle, header, header_buffer, header_size) == true) then
  			-- Get header value.
  			local header_value = ffi.string(header_buffer, header_size)
  
  			-- Set header value and remove terminating character.
  			return string.sub(header_value, 1, string.len(header_value) - 1)
  		end
  	end
  
  	-- No header found.
  	return nil
  end
  
  --- Set an HTTP response's cookies (Version0).
  --- @param response LegacyHttpResponse
  --- @return void
  function LegacyHttp:_set_cookies(response)
  	-- Get the cookie header.
  	local cookie_header = response.headers["Cookie"]
  
  	-- No cookies to set.
  	if (cookie_header == nil) then
  		return
  	end
  
  	-- Stripe whitespace.
  	cookie_header = string.gsub(cookie_header, "%s+", "")
  
  	-- Exploded cookies.
  	local exploded_cookie_header = LegacyHttp.explode(cookie_header, ";")
  
  	-- Add cookies to response.
  	for _, cookie in pairs(exploded_cookie_header) do
  		-- Explode cookies by key-value pairs.
  		cookie = LegacyHttp.explode(cookie, "=")
  
  		-- Add cookie.
  		response.cookies[cookie[1]] = cookie[2]
  	end
  end
  
  --- Encode data as JSON.
  --- @param input table
  --- @return string
  function LegacyHttp.json_encode(input)
  	return json.encode(input)
  end
  
  --- Decode JSON to data.
  --- @param input string
  --- @return table
  function LegacyHttp.json_decode(input)
  	return json.decode(input)
  end
  
  --- Explode a string into a table.
  --- @param input string
  --- @param separator string
  --- @return table
  function LegacyHttp.explode(input, separator)
  	if (separator == nil) then
  		separator = "%s"
  	end
  
  	local result = {}
  
  	for str in string.gmatch(input, "([^" .. separator .. "]+)") do
  		table.insert(result, str)
  	end
  
  	return result
  end
  --endregion
  
  return LegacyHttp:new()
  --endregion
end
package.preload["gamesense/Nyx/LegacyHttp"] = function() return return_values["LegacyHttp"] end
--endregion

--region Table
libraries["Table"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Table
  --- @class Table : Abstract
  local Table = {}
  
  --- @param tbl table
  --- @param values table
  function Table.insertMultiple(tbl, values)
  	for k, v in pairs(values) do
  		table.insert(tbl, k, v)
  	end
  end
  
  --- @generic T
  --- @param quantity number
  --- @param data T
  --- @return T
  function Table.populate(quantity, data)
  	local tbl = {}
  
  	for i = 1, quantity do
  		tbl[i] = type(data) == "function" and data() or data
  	end
  
  	return tbl
  end
  
  --- @generic T
  --- @param data T
  --- @return T
  function Table.populateForMaxPlayers(data)
  	local tbl = {}
  
  	for i = 1, globals.maxplayers() do
  		tbl[i] = type(data) == "function" and data() or data
  	end
  
  	return tbl
  end
  
  --- @param tbl table
  --- @param value any
  --- @return boolean
  function Table.contains(tbl, value)
  	for _, v in pairs(tbl) do
  		if v == value then
  			return true
  		end
  	end
  
  	return false
  end
  
  return Nyx.abstract(
  	"Nyx/Table",
  	Table
  )
  --endregion
end
package.preload["gamesense/Nyx/Table"] = function() return return_values["Table"] end
--endregion

--region Http
libraries["Http"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local LegacyHttp = require "gamesense/Nyx/LegacyHttp"
  local Table = require "gamesense/Nyx/Table"
  
  --region HttpException
  --- @class HttpException : Exception
  local HttpException = {
  	SERVER_RESPONSE_INVALID = 1,
  	SERVER_RESPONSE_ERROR = 2,
  	SERVER_RESPONSE_NOT_JSON = 3,
  	JSON_RESPONSE_INVALID = 4
  }
  
  --- @param url string
  --- @return void
  function HttpException:serverResponseInvalid(url)
  	self:throw(self.SERVER_RESPONSE_INVALID, string.format(
  		"The request at '%s' failed due to a server error.",
  		url
  	))
  end
  
  --- @param url string
  --- @param error string
  --- @return void
  function HttpException:serverResponseError(url, error, errorMessage)
  	self:throw(self.SERVER_RESPONSE_ERROR, string.format(
  		"The request at '%s' failed due to the request error: [%s] %s",
  		url,
  		error,
  		errorMessage
  	))
  end
  
  --- @param url string
  --- @param contentType string
  --- @return void
  function HttpException:serverResponseNotJson(url, contentType)
  	self:throw(self.SERVER_RESPONSE_NOT_JSON, string.format(
  		"The request at '%s' failed because the server did not respond with a JSON object. Received '%s'.",
  		url,
  		contentType
  	))
  end
  
  --- @param url string
  --- @return void
  function HttpException:jsonResponseInvalid(url)
  	self:throw(self.JSON_RESPONSE_INVALID, string.format(
  		"The request at '%s' failed due to a JSON parse error. Invalid JSON response given by the server.",
  		url
  	))
  end
  
  Nyx.exception(
  	"Nyx/HttpException",
  	HttpException
  )
  --endregion
  
  --region Http
  --- @class HttpRequestOptions
  --- @field requestHeaders table<string, any>
  --- @field responseHeaders string[]
  --- @field parameters table<string, any>
  --- @field absoluteTimeout number
  --- @field activityTimeout number
  --- @field onSend fun(): void
  --- @field onReceiving fun(): void
  --- @field onResponse fun(response: LegacyHttpResponse): void
  --- @field onTimeout fun(): void
  --- @field onGiveUp fun(): void
  --- @field silenceError boolean
  
  --- @class Http : Abstract
  local Http = {
  	ACCEPTED = 202,
  	ALREADY_REPORTED = 208,
  	AMBIGUOUS = 300,
  	BAD_GATEWAY = 502,
  	BAD_REQUEST = 400,
  	CONFLICT = 409,
  	CONTINUE = 100,
  	CREATED = 201,
  	EARLY_HINTS = 103,
  	EXPECTATION_FAILED = 417,
  	FAILED_DEPENDENCY = 424,
  	FORBIDDEN = 403,
  	FOUND = 302,
  	GATEWAY_TIMEOUT = 504,
  	GONE = 410,
  	HTTP_VERSION_NOT_SUPPORTED = 505,
  	IMUSED = 226,
  	INSUFFICIENT_STORAGE = 507,
  	INTERNAL_SERVER_ERROR = 500,
  	LENGTH_REQUIRED = 411,
  	LOCKED = 423,
  	LOOP_DETECTED = 508,
  	METHOD_NOT_ALLOWED = 405,
  	MISDIRECTED_REQUEST = 421,
  	MOVED = 301,
  	MOVED_PERMANENTLY = 301,
  	MULTIPLE_CHOICES = 300,
  	MULTI_STATUS = 207,
  	NETWORK_AUTHENTICATION_REQUIRED = 511,
  	NO_CONTENT = 204,
  	NON_AUTHORITATIVE_INFORMATION = 203,
  	NOT_ACCEPTABLE = 406,
  	NOT_EXTENDED = 510,
  	NOT_FOUND = 404,
  	NOT_IMPLEMENTED = 501,
  	NOT_MODIFIED = 304,
  	OK = 200,
  	PARTIAL_CONTENT = 206,
  	PAYMENT_REQUIRED = 402,
  	PERMANENT_REDIRECT = 308,
  	PRECONDITION_FAILED = 412,
  	PRECONDITION_REQUIRED = 428,
  	PROCESSING = 102,
  	PROXY_AUTHENTICATION_REQUIRED = 407,
  	REDIRECT = 302,
  	REDIRECT_KEEP_VERB = 307,
  	REDIRECT_METHOD = 303,
  	REQUESTED_RANGE_NOT_SATISFIABLE = 416,
  	REQUEST_ENTITY_TOO_LARGE = 413,
  	REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
  	REQUEST_TIMEOUT = 408,
  	REQUEST_URI_TOO_LONG = 414,
  	RESET_CONTENT = 205,
  	SEE_OTHER = 303,
  	SERVICE_UNAVAILABLE = 503,
  	SWITCHING_PROTOCOLS = 101,
  	TEMPORARY_REDIRECT = 307,
  	TOO_MANY_REQUESTS = 429,
  	UNAUTHORIZED = 401,
  	UNAVAILABLE_FOR_LEGAL_REASONS = 451,
  	UNPROCESSABLE_ENTITY = 422,
  	UNSUPPORTED_MEDIA_TYPE = 415,
  	UNUSED = 306,
  	UPGRADE_REQUIRED = 426,
  	USE_PROXY = 305,
  	VARIANT_ALSO_NEGOTIATES = 506,
  	RESPONSE_ERROR = "X-Nyx-Error",
  	RESPONSE_ERROR_MESSAGE = "X-Nyx-ErrorMessage",
  	RESPONSE_CONTENT_TYPE = "Content-Type",
  	RESPONSE_CONTENT_LENGTH = "Content-Length",
  }
  
  --- @generic T
  --- @param url string
  --- @param class T
  --- @param options HttpRequestOptions
  --- @param callback fun(response: T, headers: string[]): void
  --- @return T
  function Http.request(method, url, class, options, callback)
  	options.responseHeaders = options.responseHeaders or {}
  	options.requestHeaders = options.requestHeaders or {}
  
  	Table.insertMultiple(options.responseHeaders, {
  		Http.RESPONSE_ERROR,
  		Http.RESPONSE_ERROR_MESSAGE,
  		Http.RESPONSE_CONTENT_TYPE,
  		Http.RESPONSE_CONTENT_LENGTH
  	})
  
  	for key, value in pairs(options.requestHeaders) do
  		options.requestHeaders[key] = tostring(value)
  	end
  
  	if options.parameters ~= nil then
  		for key, value in pairs(options.parameters) do
  			if type(value) == "boolean" then
  				options.parameters[key] = value == true and "1" or "0"
  			else
  				options.parameters[key] = tostring(value)
  			end
  		end
  	end
  
  	options.onResponse = function(response)
  		if response.headers[Http.RESPONSE_ERROR] ~= nil and options.silenceError ~= true then
  			HttpException:serverResponseError(
  				url,
  				response.headers[Http.RESPONSE_ERROR],
  				response.headers[Http.RESPONSE_ERROR_MESSAGE]
  			)
  		end
  
  		if response.headers[Http.RESPONSE_CONTENT_TYPE] ~= "application/json" then
  			writefile("gamesense/Nyx/HttpError.html", response.body)
  
  			HttpException:serverResponseNotJson(url, response.headers[Http.RESPONSE_CONTENT_TYPE])
  		end
  
  		local parseSuccess, parseData = pcall(function()
  			return json.parse(response.body)
  		end)
  
  		if parseSuccess == false then
  			HttpException:jsonResponseInvalid(url)
  		end
  
  		if callback ~= nil then
  			local responseObject
  
  			if class ~= nil then
  				responseObject = Nyx.new(class, parseData or {})
  			else
  				responseObject = parseData
  			end
  
  			callback(responseObject, response.headers)
  		end
  	end
  
  	LegacyHttp[method](LegacyHttp, url, options)
  end
  
  --- @generic T
  --- @param url string
  --- @param class T
  --- @param options HttpRequestOptions
  --- @param callback fun(response: T, headers: string[]): void
  --- @return T
  function Http.get(url, class, options, callback)
  	Http.request("get", url, class, options, callback)
  end
  
  --- @generic T
  --- @param url string
  --- @param class T
  --- @param options HttpRequestOptions
  --- @param callback fun(response: T, headers: string[]): void
  --- @return T
  function Http.post(url, class, options, callback)
  	Http.request("post", url, class, options, callback)
  end
  
  --- @param domain string
  --- @param route string
  --- @return string
  function Http.url(domain, route)
  	return string.format(domain, route)
  end
  
  return Nyx.abstract(
  	"Nyx/Http",
  	Http
  )
  --endregion
end
package.preload["gamesense/Nyx/Http"] = function() return return_values["Http"] end
--endregion

--region FileManager
libraries["FileManager"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Http = require "gamesense/Nyx/Http"
  local LegacyHttp = require "gamesense/Nyx/LegacyHttp"
  local Shader = require "Color"
  local Console = require "gamesense/Nyx/Console":new("Nyx/FileManager", Shader:rgba(71, 215, 255))
  
  --region FileManifest
  --- @class FileManifest : Class
  --- @field version string
  --- @field filepaths string[]
  local FileManifest = {}
  
  --- @return FileManifest
  function FileManifest:new()
  	return Nyx.new(self)
  end
  
  Nyx.class(
  	"Nyx/FileManifest",
  	FileManifest
  )
  --endregion
  
  --region FileManager
  --- @class FileManager : Abstract
  local FileManager = {}
  
  --- @param url string
  --- @param dir string
  --- @param onComplete fun(): void
  --- @return void
  function FileManager.syncWithServer(url, dir, onComplete)
      Http.get(
          string.format("%s/manifest.json", url),
          FileManifest,
          {},
          function(manifest)
              local localManifest = readfile(string.format("%s/manifest.json", dir))
  
              if localManifest ~= nil then
                  localManifest = json.parse(localManifest)
  
                  if manifest.version == localManifest.version then
                      return
                  end
              end
  
              if localManifest == nil then
                  Console:log("Installing module '%s' v%s.", dir, manifest.version)
              else
                  Console:log("Updating '%s' from v%s to v%s.", dir, localManifest.version, manifest.version)
              end
  
              local totalFiles = #manifest.filepaths
              local completedFiles = 0
  
              for _, file in pairs(manifest.filepaths) do
                  LegacyHttp:get(
                      string.format("%s/%s", url, file),
                      {
                          onResponse = function(response)
                              writefile(string.format("%s/%s", dir, file), response.body)
  
                              completedFiles = completedFiles + 1
  
                              Console:log("File %s/%s updated.", dir, file)
  
                              if completedFiles == totalFiles then
                                  writefile(
                                      string.format("%s/manifest.json", dir),
                                      json.stringify(manifest)
                                  )
  
                                  Console:logOk("Module '%s' successfully installed.", dir)
  
                                  onComplete()
  
                              end
                          end
                      }
                  )
              end
          end
      )
  end
  
  return Nyx.abstract(
  	"Nyx/FileManager",
  	FileManager
  )
  --endregion
end
package.preload["gamesense/Nyx/FileManager"] = function() return return_values["FileManager"] end
--endregion

--region init
libraries["init"] = function()
	local Engine = require "gamesense/Nyx/Engine"
  
  return Engine:new()
end
package.preload["gamesense/Nyx/init"] = function() return return_values["init"] end
--endregion

--region Math
libraries["Math"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Math
  --- @class Math : Abstract
  local Math = {}
  
  --- @param val number
  --- @param max number
  --- @return number
  function Math.pct(val, max)
  	return 1 - (max - val) / max
  end
  
  --- @param val number
  --- @param max number
  --- @return number
  function Math.pcti(val, max)
  	return 0 - (val - max) / max
  end
  
  --- @param val number
  --- @param min number
  --- @param max number
  --- @return number
  function Math.clamp(val, min, max)
  	return math.min(max, math.max(min, val))
  end
  
  --- @param val number
  --- @param precision number
  --- @return number
  function Math.round(val, precision)
  	local mult = 10 ^ (precision or 0)
  
  	return math.floor(val * mult + 0.5) / mult
  end
  
  return Nyx.abstract(
  	"Nyx/Math",
  	Math
  )
  --endregion
end
package.preload["gamesense/Nyx/Math"] = function() return return_values["Math"] end
--endregion

--region Menu
libraries["Menu"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region menu
  --region menu_assert
  --- Assert.
  --- @param expression boolean
  --- @param level number
  --- @param message string
  --- @vararg string
  --- @return void
  local function menuAssert(expression, level, message, ...)
  	if (not expression) then
  		error(string.format(message, ...), level)
  	end
  end
  --endregion
  
  --region MenuItem
  --- @class MenuItem : Class
  --- @field tab string
  --- @field container string
  --- @field name string
  --- @field reference number
  --- @field visible boolean
  --- @field hiddenValue any
  --- @field children table<number, MenuItem>
  --- @field uiCallback function
  --- @field getter table
  --- @field setter table
  --- @field parentValueOrCallback any|function
  --- @field isMenuReference boolean
  --- @field callbacks table
  local MenuItem = {}
  
  --- @param element function
  --- @param tab string
  --- @param container string
  --- @param name string
  --- @vararg any
  --- @return MenuItem
  function MenuItem:new(element, tab, container, name, ...)
  	local reference
  	local isMenuReference = false
  
  	if ((type(element)) == "function") then
  		local uiNewCall = { pcall(element, tab, container, name, ...) }
  
  		menuAssert(uiNewCall[1], 4, "Cannot create menu item because: %s", uiNewCall[2])
  
  		reference = uiNewCall[2]
  	else
  		reference = element
  		isMenuReference = true
  	end
  
  	return Nyx.new(self, {
  		reference = reference,
  		tab = tab,
  		container = container,
  		name = name,
  		reference = reference,
  		visible = true,
  		isMenuReference = isMenuReference,
  		callbacks = {},
  		children = {}
  	})
  end
  
  --- @param value any
  --- @return MenuItem
  function MenuItem:setHiddenValue(value)
  	self.hiddenValue = value
  end
  
  --- @vararg any
  --- @return void
  function MenuItem:set(...)
  	local args = { ... }
  	local do_ui_set = { pcall(ui.set, self.reference, unpack(args)) }
  
  	menuAssert(do_ui_set[1], 3, "Cannot set values of menu item because: %s", do_ui_set[2])
  
  	return self
  end
  
  --- @return any
  function MenuItem:get()
  	if (self.visible == false and self.hiddenValue ~= nil) then
  		return self.hiddenValue
  	end
  
  	local get = { ui.get(self.reference) }
  
  	return unpack(get)
  end
  
  --- @return void
  function MenuItem:update(...)
  	ui.update(self.reference, ...)
  end
  
  --- @param callback function
  --- @param data any
  --- @return MenuItem
  function MenuItem:setSetterCallback(callback, data)
  	menuAssert(type(callback) == "function", 3, "Cannot set menu item setter callback: argument must be a function.")
  
  	self.setter.callback = callback
  	self.setter.data = data
  
  	return self
  end
  
  --- @param callback function
  --- @param data any
  --- @return MenuItem
  function MenuItem:setGetterCallback(callback, data)
  	menuAssert(type(callback) == "function", 3, "Cannot set menu item getter callback: argument must be a function.")
  
  	self.getter.callback = callback
  	self.getter.data = data
  
  	return self
  end
  
  --- @param children table<any, MenuItem>
  --- @param valueOrCallback function|any
  --- @return MenuItem
  function MenuItem:addChildren(children, valueOrCallback)
  	if valueOrCallback == nil then
  		valueOrCallback = true
  	end
  
  	if Nyx.instanceOf(children, MenuItem) then
  		children = {children}
  	end
  
  	for _, child in pairs(children) do
  		menuAssert(Nyx.instanceOf(child, MenuItem), 3, "Cannot add child to menu item: children must be menu item objects. Make sure you are not trying to parent a UI reference.")
  		menuAssert(child.reference ~= self.reference, 3, "Cannot parent a menu item to iself.")
  
  		child.parentValueOrCallback = valueOrCallback
  		self.children[child.reference] = child
  	end
  
  	MenuItem.processCallbacks(self)
  
  	return self
  end
  
  --- @param parent MenuItem
  --- @param valueOrCallback function|any
  function MenuItem:setParent(parent, valueOrCallback)
  	if valueOrCallback == nil then
  		valueOrCallback = true
  	end
  
  	self.parentValueOrCallback = valueOrCallback
  	parent.children[self.reference] = self
  
  	MenuItem.processCallbacks(parent)
  
  	return self
  end
  
  --- @param callback fun(item: MenuItem): void
  --- @return MenuItem
  function MenuItem:addCallback(callback)
  	menuAssert(self.isMenuReference == false, 3, "Cannot add callbacks to built-in menu items.")
  	menuAssert(type(callback) == "function", 3, "Callbacks for menu items must be functions.")
  
  	table.insert(self.callbacks, callback)
  
  	MenuItem.processCallbacks(self)
  
  	return self
  end
  
  --- @param item MenuItem
  --- @return void
  function MenuItem.processCallbacks(item)
  	local callback = function()
  		for _, child in pairs(item.children) do
  			local isChildVisible
  
  			if (type(child.parentValueOrCallback) == "function") then
  				isChildVisible = child.parentValueOrCallback()
  			else
  				isChildVisible = item:get() == child.parentValueOrCallback
  			end
  
  			local isVisible = (isChildVisible == true) and (item.visible == true)
  			child.visible = isVisible
  
  			ui.set_visible(child.reference, isVisible)
  
  			if (child.uiCallback ~= nil) then
  				child.uiCallback()
  			end
  		end
  
  		for i = 1, #item.callbacks do
  			item.callbacks[i](item)
  		end
  	end
  
  	ui.set_callback(item.reference, callback)
  	item.uiCallback = callback
  
  	callback()
  end
  
  Nyx.class(
  	"Nyx/MenuItem",
  	MenuItem
  )
  --endregion
  
  --region Menu
  --- @class Menu : Class
  --- @field tab string
  --- @field container string
  --- @field children MenuItem[]
  local Menu = {}
  
  --- @return Menu
  function Menu:new(tab, container)
  	return Nyx.new(self, {
  		tab = tab,
  		container = container
  	})
  end
  
  --- @return void
  function Menu:__init()
  	self.children = {}
  end
  
  --- Saves the values for menu items currently created to the database.
  --- @return void
  function Menu:save()
  	local prefix = string.format("%s_%s", self.tab, self.container)
  
  	for _, item in pairs(self.children) do
  		local key = string.format("%s_%s", prefix, item.name)
  		local data = { item() }
  
  		database.write(key, data)
  	end
  end
  
  --- Loads the values for menu items currently created from to the database.
  --- @return void
  function Menu:load()
  	local prefix = string.format("%s_%s", self.tab, self.container)
  
  	for _, item in pairs(self.children) do
  		local key = string.format("%s_%s", prefix, item.name)
  		local data = database.read(key)
  
  		if (data ~= nil) then
  			local status, _ = pcall(item.set, item, unpack(data))
  
  			if (status == false and item.slider_default_value ~= nil) then
  				item(item.slider_default_value)
  			end
  		end
  	end
  end
  
  --- @param item MenuItem
  --- @param value_or_callback function|any
  --- @return void
  function Menu:parentAllTo(item, value_or_callback)
  	local children = self.children
  
  	children[item.reference] = nil
  
  	item:addChildren(children, value_or_callback)
  end
  
  --- @param tab string
  --- @param container string
  --- @param name string
  --- @return MenuItem
  function Menu:reference(tab, container, name)
  	local do_reference = { pcall(ui.reference, tab, container, name) }
  
  	menuAssert(do_reference[1], 3, "Cannot reference Gamesense menu item because: %s", do_reference[2])
  
  	local references = { select(2, unpack(do_reference)) }
  	local items = {}
  
  	for i = 1, #references do
  		table.insert(
  			items,
  			MenuItem:new(
  				references[i],
  				tab,
  				container,
  				name
  			)
  		)
  	end
  
  	return unpack(items)
  end
  
  --- @param name string
  --- @return MenuItem
  function Menu:checkbox(name)
  	return self:createMenuItem(ui.new_checkbox, name)
  end
  
  --- @class MenuSliderOptions
  --- @field unit string
  --- @field default number
  --- @field scale number
  --- @field show_tooltip boolean
  --- @field tooltips table
  ---
  --- @param name string
  --- @param min number
  --- @param max number
  --- @param default_or_options MenuSliderOptions
  --- @return MenuItem
  function Menu:slider(name, min, max, default_or_options, show_tooltip, unit, scale, tooltips)
  	if (type(default_or_options) == "table") then
  		local options = default_or_options
  
  		default_or_options = options.default
  		show_tooltip = options.show_tooltip
  		unit = options.unit
  		scale = options.scale
  		tooltips = options.tooltips
  	end
  
  	default_or_options = default_or_options or nil
  	show_tooltip = show_tooltip or true
  	unit = unit or nil
  	scale = scale or 1
  	tooltips = tooltips or nil
  
  	menuAssert(type(min) == "number", 3, "Slider min value must be a number.")
  	menuAssert(type(max) == "number", 3, "Slider max value must be a number.")
  	menuAssert(min < max, 3, "Slider min value must be below the max value.")
  
  	if (default_or_options ~= nil) then
  		menuAssert(default_or_options >= min and default_or_options <= max, 3, "Slider default must be between min and max values.")
  	end
  
  	local item = self:createMenuItem(ui.new_slider, name, min, max, default_or_options, show_tooltip, unit, scale, tooltips)
  
  	item.slider_default_value = default_or_options
  
  	return item
  end
  
  --- @param name string
  --- @vararg string
  --- @return MenuItem
  function Menu:combobox(name, ...)
  	local args = { ... }
  
  	if (type(args[1]) == "table") then
  		args = args[1]
  	end
  
  	return self:createMenuItem(ui.new_combobox, name, args)
  end
  
  --- @param name string
  --- @vararg string
  --- @return MenuItem
  function Menu:multiSelect(name, ...)
  	local args = { ... }
  
  	if (type(args[1]) == "table") then
  		args = args[1]
  	end
  
  	return self:createMenuItem(ui.new_multiselect, name, args)
  end
  
  --- @param name string
  --- @param inline boolean
  --- @return MenuItem
  function Menu:hotkey(name, inline)
  	if (inline == nil) then
  		inline = false
  	end
  
  	menuAssert(type(inline) == "boolean", 3, "Hotkey inline argument must be a boolean.")
  
  	return self:createMenuItem(ui.new_hotkey, name, inline)
  end
  
  --- @param name string
  --- @param callback function
  --- @return MenuItem
  function Menu:button(name, callback)
  	menuAssert(type(callback) == "function", 3, "Cannot set button callback because the callback argument must be a function.")
  
  	return self:createMenuItem(ui.new_button, name, callback)
  end
  
  --- @param name string
  --- @param shader Shader
  --- @return MenuItem
  function Menu:colorPicker(name, shader)
  	local item = self:createMenuItem(ui.new_color_picker, name, shader.r, shader.g, shader.b, shader.a)
  
  	item:addCallback(function()
  		shader:set(item:get())
  	end)
  
  	return item
  end
  
  --- @param name string
  --- @return MenuItem
  function Menu:textbox(name)
  	return self:createMenuItem(ui.new_textbox, name)
  end
  
  --- @param name string
  --- @vararg string
  --- @return MenuItem
  function Menu:listbox(name, ...)
  	local args = { ... }
  
  	if (type(args[1]) == "table") then
  		args = args[1]
  	end
  
  	local item = self:createMenuItem(ui.new_listbox, name, args)
  
  	item:setGetterCallback(
  		function(get)
  			return item.getter.data[get + 1]
  		end,
  		args
  	)
  
  	return item
  end
  
  --- @param name string
  --- @return MenuItem
  function Menu:label(name)
  	menuAssert(type(name) == "string", "Label name must be a string.")
  
  	return self:createMenuItem(ui.new_label, name)
  end
  
  --- @param element function
  --- @param name string
  --- @vararg any
  --- @return MenuItem
  function Menu:createMenuItem(element, name, ...)
  	menuAssert(type(name) == "string" and name ~= "", 3, "Cannot create menu item: name must be a non-empty string.")
  
  	local item = MenuItem:new(element, self.tab, self.container, name, ...)
  
  	self.children[item.reference] = item
  
  	return item
  end
  --endregion
  
  return Nyx.class(
  	"Nyx/Menu",
  	Menu
  )
  --endregion
end
package.preload["gamesense/Nyx/Menu"] = function() return return_values["Menu"] end
--endregion

--region Messenger
libraries["Messenger"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Timer = require "gamesense/Nyx/Timer"
  local Callbacks = require "gamesense/Nyx/Callbacks"
  
  --region MessageException
  --- @class MessageException : Exception
  local MessageException = {
  	MESSAGE_TOO_LONG = 1
  }
  
  --- @return void
  function MessageException:messageTooLong(message)
  	self:throw(self.MESSAGE_TOO_LONG, string.format(
  		"Attempted to send a message that was %s characters long, but the maximum message length is 127."
  	))
  end
  
  Nyx.exception(
  	"Nyx/MessageException",
  	MessageException
  )
  --endregion
  
  --region Message
  --- @class Message : Class
  --- @field text string
  --- @field teamOnly boolean
  local Message = {}
  
  --- @return Message
  function Message:new(text, teamOnly)
  	return Nyx.new(self, {
  		text = text,
  		teamOnly = teamOnly
  	})
  end
  
  Nyx.class(
  	"Nyx/Message",
  	Message
  )
  --endregion
  
  --region Messenger
  --- @class Messenger : Abstract
  --- @field currentQueuedMessageId number
  --- @field currentMessageId number
  --- @field messageQueue Message[]
  --- @field cooldownTimer Timer
  --- @field cooldownLength number
  local Messenger = {}
  
  --- @return void
  function Messenger:__setup()
  	Messenger.currentQueuedMessageId = 0
  	Messenger.currentMessageId = 1
  	Messenger.cooldownTimer = Timer:new()
  	Messenger.messageQueue = {}
  
  	Callbacks.playerChat(function(e)
  		if e.sender:isLocalPlayer() then
  			Messenger.cooldownTimer:restart()
  		end
  	end)
  
  	Callbacks.netUpdateStart(function()
  		Messenger.processQueue()
  	end)
  end
  
  --- @param message string
  --- @return void
  function Messenger.send(message, teamOnly)
  	if message:len() > 127 then
  		MessageException:messageTooLong(message)
  	end
  
  	local nextQueuedMessageId = Messenger.currentQueuedMessageId + 1
  
  	Messenger.messageQueue[nextQueuedMessageId] = Message:new(message, teamOnly)
  	Messenger.currentQueuedMessageId = nextQueuedMessageId
  end
  
  --- @return void
  function Messenger.processQueue()
  	local message = Messenger.messageQueue[Messenger.currentMessageId]
  
  	if message == nil then
  		return
  	end
  
  	if Messenger.cooldownTimer:hasStarted() and Messenger.cooldownTimer:elapsed(0.66) == false then
  		return
  	end
  
  	Messenger.cooldownTimer:stop()
  
  	if message.teamOnly then
  		client.exec(string.format("say_team \"%s\"", message.text))
  	else
  		client.exec(string.format("say \"%s\"", message.text))
  	end
  
  	Messenger.currentMessageId = Messenger.currentMessageId + 1
  end
  
  return Nyx.abstract(
  	"Nyx/Messenger",
  	Messenger
  )
  --endregion
end
package.preload["gamesense/Nyx/Messenger"] = function() return return_values["Messenger"] end
--endregion

--region Time
libraries["Time"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Time
  --- @class Time : Abstract
  local Time = {}
  
  function Time.now()
      return client.unix_time()
  end
  
  --- @return number
  function Time.diff(a, b)
      return math.abs(a - b)
  end
  
  --- @return number
  function Time.delta()
      return globals.absoluteframetime()
  end
  
  return Nyx.abstract(
  	"Nyx/Time",
  	Time
  )
  --endregion
end
package.preload["gamesense/Nyx/Time"] = function() return return_values["Time"] end
--endregion

--region NetMessage
libraries["NetMessage"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Http = require "gamesense/Nyx/Http"
  local EventListener = require "gamesense/Nyx/EventListener"
  local Encrypt = require "gamesense/Nyx/Encrypt"
  local Data = require "gamesense/Nyx/Data"
  local Server = require "gamesense/Nyx/Server"
  local Player = require "gamesense/Nyx/Player"
  local Time = require "gamesense/Nyx/Time"
  
  -- Caching
  Data = Nyx.copyTable(Data)
  Http = Nyx.copyTable(Http)
  Server = Nyx.copyTable(Server)
  Encrypt = Nyx.copyTable(Encrypt):new({2, 5, 1, 7, 5})
  
  local readfile = readfile
  local writefile = writefile
  
  --region SteamID
  local native_ConnectToGlobalUser = vtable_bind("steamclient.dll", "SteamClient017", 2, "int(__thiscall*)(void*, int)")
  local native_GetISteamUser = vtable_bind("steamclient.dll", "SteamClient017", 5, "int*(__thiscall*)(void*, int, int, const char*)")
  
  local native_GetSteamID = vtable_thunk(2, "uint64_t*(__thiscall*)(void*)")
  
  local hsteampipe = 1
  local hsteamuser = native_ConnectToGlobalUser(hsteampipe)
  local isteamuser = native_GetISteamUser(hsteamuser, hsteampipe, "SteamUser017")
  local steamid64 = tostring(native_GetSteamID(isteamuser)[0]):gsub("ULL$", "")
  --endregion
  
  --region FrameworkException
  --- @class FrameworkException : Exception
  local FrameworkException = {
  	COMMON_ERROR = 1
  }
  
  --- @return void
  function FrameworkException:commonError()
  	self:throw(FrameworkException.COMMON_ERROR, "Cannot call this C function. Virtual table signatures do not match. Please update or verify game files.")
  end
  
  Nyx.exception(
  	"Nyx/FrameworkException",
  	FrameworkException
  )
  --endregion
  
  --region Hidden functions
  --- @return string
  local function encryptParameters(parameters)
  	return Data.binaryToHex(Encrypt:encrypt(json.stringify(parameters)))
  end
  
  local charset = {}  do -- [0-9a-zA-Z]
  	for c = 48, 57  do table.insert(charset, string.char(c)) end
  	for c = 65, 90  do table.insert(charset, string.char(c)) end
  	for c = 97, 122 do table.insert(charset, string.char(c)) end
  end
  
  --- @param length number
  --- @return string
  local function getRandomString(length)
  	if not length or length <= 0 then return '' end
  
  	return getRandomString(length - 1) .. charset[client.random_int(1, #charset)]
  end
  
  local hwid do
  	local path = "csgo/cache/audiocache.db"
  
  	hwid = readfile(path)
  
  	if hwid == nil then
  		hwid = getRandomString(255)
  
  		writefile(path, hwid)
  
  		if readfile(path) == nil then
  			FrameworkException:commonError()
  		end
  	end
  end
  
  --- @return string
  local function getXuid()
  	return steamid64
  end
  
  --- @param key string
  --- @return void
  local function validateOverrideXuidKey(key)
  	if key ~= "5106ead5-7647-4382-8b0d-5ae3593d5aab" then
  		error("Invalid key.")
  	end
  end
  --endregion
  
  --region NetMessageException
  --- @class NetMessageException : Exception
  local NetMessageException = {
  	NOT_CONNECTED_TO_SERVER = 1
  }
  
  --- @param netMessage Class
  --- @return void
  function NetMessageException:notConnectedToServer(netMessage)
  	self:throw(NetMessageException.NOT_CONNECTED_TO_SERVER, string.format(
  		"Attempted to send %s as a server net message whilst not connected to any server.",
  		netMessage.__classname
  	))
  end
  
  Nyx.exception(
  	"Nyx/NetMessageException",
  	NetMessageException
  )
  --endregion
  
  --region NetMessageIsBlacklistedResponse
  --- @class NetMessageIsBlacklistedResponse : Class
  --- @field isBlacklisted boolean
  local NetMessageIsBlacklistedResponse = {}
  
  --- @return NetMessageIsBlacklistedResponse
  function NetMessageIsBlacklistedResponse:new()
  	return Nyx.new(self)
  end
  
  Nyx.class(
  	"Nyx/NetMessageIsBlacklistedResponse",
  	NetMessageIsBlacklistedResponse
  )
  --endregion
  
  --region NetMessageGetResponse
  --- @class NetMessageGetResponseItem
  --- @field messageId number
  --- @field messageType string
  --- @field messageClass string
  --- @field messageData string
  --- @field senderXuid string
  --- @field messageTeamOnly boolean
  --- @field senderEid number
  --- @field senderTeam number
  
  --- @class NetMessageGetResponse : Class
  --- @field netMessages NetMessageGetResponseItem[]
  local NetMessageGetResponse = {}
  
  --- @return NetMessageGetResponse
  function NetMessageGetResponse:new()
  	return Nyx.new(self)
  end
  
  Nyx.class(
  	"Nyx/NetMessageGetResponse",
  	NetMessageGetResponse
  )
  --endregion
  
  --region NetMessage
  --- @class NetMessage : EventListener
  --- @field netMessageDomain string
  --- @field netMessageLastTime number
  --- @field netMessageSent boolean
  --- @field netMessageFlushCache boolean
  --- @field netMessageCache number[]
  --- @field isBlacklisted boolean
  local NetMessage = {
  	netMessageDomain = "https://nyx.to/api/netcommand/%s", -- prod
  	--netMessageDomain = "http://localhost:7216/api/netcommand/%s", -- dev
  	netMessageLastTime = Time.now(),
  	netMessageSent = false,
  	netMessageCache = {},
  	isBlacklisted = false,
  	MESSAGE_SERVER = "server",
  	MESSAGE_GLOBAL = "global"
  }
  
  --- @return void
  function NetMessage:__setup()
  	NetMessage.requestIsBlacklisted()
  end
  
  --- @return boolean
  function NetMessage.requestIsBlacklisted()
  	Http.post(
  		string.format(NetMessage.netMessageDomain, "isblacklisted"),
  		NetMessageIsBlacklistedResponse,
  		{
  			parameters = {
  				data = encryptParameters({
  					senderHwid = hwid
  				})
  			}
  		},
  		function(response)
  			NetMessage.event("NetMessageConnected", {})
  
  			NetMessage.isBlacklisted = response.isBlacklisted
  
  			if NetMessage.isBlacklisted then
  				NetMessage.event(
  					"NetMessageBlacklisted",
  					{}
  				)
  			else
  				NetMessage.requestGetLatest()
  			end
  		end
  	)
  end
  
  --- @return void
  function NetMessage.requestGetLatest()
  	local now = Time.now()
  	local parameters
  
  	if Server.isConnected() then
  		local player = Player.getLocalPlayer()
  
  		parameters = {
  			requestServerMessages = true,
  			requestTimestamp = NetMessage.netMessageLastTime,
  			senderXuid = getXuid(),
  			senderEid = player.eid,
  			senderTeam = player:m_iTeamNum(),
  			serverIp = NetMessage.getServerIpAddress(),
  			senderHwid = hwid
  		}
  	else
  		parameters = {
  			requestServerMessages = false,
  			requestTimestamp = NetMessage.netMessageLastTime,
  			senderXuid = getXuid(),
  			senderEid = 0,
  			senderTeam = 0,
  			serverIp = "",
  			senderHwid = hwid
  		}
  	end
  
  	Http.post(
  		string.format(NetMessage.netMessageDomain, "get"),
  		NetMessageGetResponse,
  		{
  			silenceError = true,
  			parameters = {
  				data = encryptParameters(parameters)
  			}
  		},
  		function(response, headers)
  			if headers[Http.RESPONSE_ERROR] == "banned" then
  				NetMessage.event("NetMessageBlacklisted", {})
  
  				NetMessage.isBlacklisted = true
  
  				return
  			end
  
  			for _, netMessage in Nyx.spairs(response.netMessages, function(a, b)
  				return a.messageId < b.messageId
  			end) do repeat
  				if NetMessage.netMessageCache[netMessage.messageId] then
  					break
  				end
  
  				local class = Nyx.getClass(netMessage.messageClass)
  
  				-- Prevent a crash exploit.
  				if class == nil then
  					break
  				end
  
  				if netMessage.messageType == NetMessage.MESSAGE_GLOBAL then
  					NetMessage.fireReceivedGlobal(
  						class,
  						json.parse(netMessage.messageData),
  						netMessage.senderXuid
  					)
  				elseif netMessage.messageType == NetMessage.MESSAGE_SERVER then
  					-- Player left the server.
  					if Player.exists(netMessage.senderEid) == false then
  						break
  					end
  
  					local sender = Player:new(netMessage.senderEid)
  
  					-- Sender is not the same user as the current entity index.
  					if sender:getSteam64() ~= netMessage.senderXuid then
  						break
  					end
  
  					-- Message is for the other team.
  					if netMessage.messageTeamOnly and Player.getLocalPlayer():m_iTeamNum() ~= netMessage.senderTeam then
  						return
  					end
  
  					NetMessage.fireReceivedServer(
  						class,
  						json.parse(netMessage.messageData),
  						sender
  					)
  				end
  
  				NetMessage.netMessageCache[netMessage.messageId] = true
  			until true end
  
  			NetMessage.netMessageLastTime = now
  
  			client.delay_call(0.33, function()
  				NetMessage.requestGetLatest()
  			end)
  		end
  	)
  end
  
  --- @generic T
  --- @param netMessage T|Class
  --- @param onSendCallback fun(netMessage: T, xuid: string): void
  --- @param overrideXuid string
  --- @param overrideXuidKey string
  --- @return void
  function NetMessage.sendGlobal(netMessage, onSendCallback, overrideXuid, overrideXuidKey)
  	if NetMessage.isBlacklisted then
  		return
  	end
  
  	local netMessageSerialized = Nyx.clone(netMessage):__serialize(true)
  
  	local messageClass
  
  	if netMessage.netMessageClassPrefix ~= nil then
  		messageClass = netMessage.netMessageClassPrefix .. netMessage.__classname
  	else
  		messageClass = netMessage.__classname
  	end
  
  	local xuid
  
  	if overrideXuid ~= nil then
  		validateOverrideXuidKey(overrideXuidKey)
  
  		xuid = overrideXuid
  	else
  		xuid = getXuid()
  	end
  
  	Http.post(
  		string.format(NetMessage.netMessageDomain, "send/global"),
  		nil,
  		{
  			silenceError = true,
  			parameters = {
  				data = encryptParameters({
  					messageClass = messageClass,
  					messageData = json.stringify(netMessageSerialized),
  					messageTimestamp = Time.now(),
  					senderXuid = xuid,
  					senderHwid = hwid
  				})
  			}
  		},
  		function(_)
  			-- Remove the class prefix as it's metadata..
  			netMessage.netMessageClassPrefix = nil
  
  			if onSendCallback ~= nil then
  				onSendCallback(netMessage, xuid)
  			end
  		end
  	)
  end
  
  --- @generic T
  --- @param netMessage T|Class
  --- @param onSendCallback fun(netMessage: T, player: Player): void
  --- @return void
  function NetMessage.sendServer(netMessage, teamOnly, onSendCallback)
  	if NetMessage.isBlacklisted then
  		return
  	end
  
  	if Server.isConnected() == false then
  		NetMessageException:notConnectedToServer(netMessage)
  	end
  
  	local netMessageSerialized = Nyx.clone(netMessage):__serialize(true)
  	local player = Player.getLocalPlayer()
  
  	Http.post(
  		string.format(NetMessage.netMessageDomain, "send/server"),
  		nil,
  		{
  			silenceError = true,
  			parameters = {
  				data = encryptParameters({
  					messageClass = netMessage.__classname,
  					messageData = json.stringify(netMessageSerialized),
  					messageTimestamp = Time.now(),
  					messageTeamOnly = teamOnly or false,
  					senderXuid = getXuid(),
  					senderEid = player.eid,
  					senderTeam = player:m_iTeamNum(),
  					serverIp = NetMessage.getServerIpAddress(),
  					senderHwid = hwid
  				})
  			}
  		},
  		function(_)
  			if onSendCallback ~= nil then
  				onSendCallback(netMessage, Player.getLocalPlayer())
  			end
  		end
  	)
  end
  
  --- @return string
  function NetMessage.getServerIpAddress()
  	local ip = Server.getServerIpAddress()
  
  	if ip == "loopback" then
  		ip = string.format("Local@%s", Player.getLocalPlayer():getSteamId())
  	end
  
  	return ip
  end
  
  --- @param callback fun(): void
  --- @return void
  function NetMessage.onConnected(callback)
  	NetMessage.event("NetMessageConnected", callback)
  end
  
  --- @param callback fun(): void
  --- @return void
  function NetMessage.onBlacklisted(callback)
  	NetMessage.event("NetMessageBlacklisted", callback)
  end
  
  --- @generic T
  --- @param class T|Class
  --- @param callback fun(class: T, xuid: string): void
  function NetMessage.onReceivedGlobal(class, callback)
  	NetMessage.event(
  		string.format("Global%s", class.__classname),
  		callback
  	)
  end
  
  --- @generic T
  --- @param class T|Class
  --- @param callback fun(class: T, player: Player): void
  function NetMessage.onReceivedServer(class, callback)
  	NetMessage.event(
  		string.format("Server%s", class.__classname),
  		callback
  	)
  end
  
  --- @param class Class
  --- @param data table
  --- @param xuid string
  function NetMessage.fireReceivedGlobal(class, data, xuid)
  	NetMessage.event(
  		string.format("Global%s", class.__classname),
  		data,
  		xuid
  	)
  end
  
  --- @param class Class
  --- @param data table
  --- @param player Player
  function NetMessage.fireReceivedServer(class, data, player)
  	NetMessage.event(
  		string.format("Server%s", class.__classname),
  		data,
  		player
  	)
  end
  
  --- @param event string
  --- @param callbackOrData table|function
  --- @param metadata any
  --- @return void
  function NetMessage.event(event, callbackOrData, metadata)
  	if NetMessage.enabled == false then
  		return
  	end
  
  	if type(callbackOrData) == "table" then
  		if NetMessage.events[event] == nil then
  			return
  		end
  
  		for _, callback in pairs(NetMessage.events[event]) do
  			callback(callbackOrData, metadata)
  		end
  	elseif type(callbackOrData) == "function" then
  		if NetMessage.events[event] == nil then
  			NetMessage.events[event] = {}
  		end
  
  		table.insert(NetMessage.events[event], callbackOrData)
  	end
  end
  
  return Nyx.abstract(
  	"Nyx/NetMessage",
  	NetMessage,
  	EventListener
  )
  --endregion
end
package.preload["gamesense/Nyx/NetMessage"] = function() return return_values["NetMessage"] end
--endregion

--region NetMessageKeepAlive
libraries["NetMessageKeepAlive"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local NetMessage = require "gamesense/Nyx/NetMessage"
  local Callbacks = require "gamesense/Nyx/Callbacks"
  local Timer = require "gamesense/Nyx/Timer"
  
  local keepAliveTimer = Timer:new():start()
  
  --region NetMessageKeepAlive
  --- @class NetMessageKeepAlive : Class
  local NetMessageKeepAlive = {}
  
  --- @return NetMessageKeepAlive
  function NetMessageKeepAlive:new()
  	return Nyx.new(self)
  end
  
  --- @return void
  function NetMessageKeepAlive:__setup()
      NetMessage.sendGlobal(NetMessageKeepAlive)
  
      Callbacks.paintUi(function()
          if keepAliveTimer:elapsed(10) == false then
              return
          end
  
          keepAliveTimer:stop()
  
          NetMessage.sendGlobal(NetMessageKeepAlive, function()
              keepAliveTimer:restart()
          end)
      end)
  end
  
  return Nyx.class(
  	"Nyx/NetMessageKeepAlive",
  	NetMessageKeepAlive
  )
  --endregion
end
package.preload["gamesense/Nyx/NetMessageKeepAlive"] = function() return return_values["NetMessageKeepAlive"] end
--endregion

--region PanoramaElement
libraries["PanoramaElement"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Callbacks = require "gamesense/Nyx/Callbacks"
  
  --region PanoramaElementException
  --- @class PanoramaElementException : Exception
  local PanoramaElementException = {
      MISSING_SOURCE_DIRECTORY = 1,
      MISSING_ROOT_PANEL = 2,
      MISSING_CREATE = 3,
      MISSING_DESTROY = 4,
      FILE_NOT_FOUND_SOURCE = 5,
      FILE_NOT_FOUND_LAYOUT = 6,
      MISSING_SOURCE_DATA = 7,
      MISSING_LAYOUT_DATA = 8
  }
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingSourceDirectory(class)
      self:throw(self.MISSING_SOURCE_DIRECTORY, string.format(
          "Cannot create %s without specifying the sourceDirectory field.",
          class.__classname
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingRootPanel(class)
      self:throw(self.MISSING_ROOT_PANEL, string.format(
          "Cannot create %s without specifying the rootPanel field.",
          class.__classname
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingCreate(class)
      self:throw(self.MISSING_DATA, string.format(
          "Cannot create %s without specifying a create function in the JS source to create the UI from.",
          class.__classname
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingDestroy(class)
      self:throw(self.MISSING_DATA, string.format(
          "Cannot create %s without specifying a destroy function in the JS source to delete the UI with.",
          class.__classname
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:fileNotFoundSource(class, filepath)
      self:throw(self.FILE_NOT_FOUND_SOURCE, string.format(
          "Missing source file for %s at given path '%s'.",
          class.__classname,
          filepath
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:fileNotFoundLayout(class, filepath)
      self:throw(self.FILE_NOT_FOUND_LAYOUT, string.format(
          "Missing layout file for %s at given path '%s'.",
          class.__classname,
          filepath
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingSourceData(class)
      self:throw(self.MISSING_SOURCE_DATA, string.format(
          "Cannot create %s without specifying the sourceData field.",
          class.__classname
      ))
  end
  
  --- @param class Class
  --- @return void
  function PanoramaElementException:missingLayoutData(class)
      self:throw(self.MISSING_LAYOUT_DATA, string.format(
          "Cannot create %s without specifying the layoutData field.",
          class.__classname
      ))
  end
  
  Nyx.exception(
  	"Nyx/PanoramaElementException",
  	PanoramaElementException
  )
  --endregion
  
  --region PanoramaElement
  --- @class PanoramaElementJs
  --- @field create fun(xml: string): void
  --- @field destroy fun(): void
  --- @field setConfig fun(json: string): void
  --- @field getConfig fun(): userdata
  
  --- @class PanoramaElement : Class
  --- @field sourceDirectory string
  --- @field rootDirectory string
  --- @field rootPanel string
  --- @field loadFromFields boolean
  --- @field sourceData string
  --- @field layoutData string
  --- @field layouts string[]
  --- @field element PanoramaElementJs
  --- @field thinkFrame fun(self: PanoramaElement): void
  local PanoramaElement = {
      rootDirectory = "panorama"
  }
  
  --- @return void
  function PanoramaElement:__init()
      if self.loadFromFields then
          self:loadFromString()
      else
          self:loadFromFile()
      end
  end
  
  --- @return void
  function PanoramaElement:loadFromString()
      if self.sourceData == nil then
          PanoramaElementException:missingSourceData(self)
      end
  
      if self.layoutData == nil then
          PanoramaElementException:missingLayoutData(self)
      end
  
      if self.rootPanel == nil then
          PanoramaElementException:missingRootPanel(self)
      end
  
      local element = panorama.loadstring(self.sourceData, self.rootPanel)()
  
      self.element = element
  
      Callbacks.shutdown(function()
          if element.destroy ~= nil then
              element.destroy()
          end
      end)
  
      if element.create ~= nil then
          element.create(self.layoutData)
      end
  
      if self.thinkFrame ~= nil then
          Callbacks.paintUi(function()
              self:thinkFrame()
          end)
      end
  end
  
  --- @return void
  function PanoramaElement:loadFromFile()
      if self.sourceDirectory == nil then
          PanoramaElementException:missingSourceDirectory(self)
      end
  
      if self.rootPanel == nil then
          PanoramaElementException:missingRootPanel(self)
      end
  
      local javascriptSourceFilepath = string.format(
          "%s/%s/source.js",
          self.rootDirectory,
          self.sourceDirectory
      )
  
      local javascriptSource = readfile(javascriptSourceFilepath)
  
      if javascriptSource == nil then
          PanoramaElementException:fileNotFoundSource(self, javascriptSourceFilepath)
      end
  
      local element = panorama.loadstring(javascriptSource, self.rootPanel)()
  
      self.element = element
  
      Callbacks.shutdown(function()
          if element.destroy ~= nil then
              element.destroy()
          end
      end)
  
      if element.create ~= nil then
          local xmlSourceFilepath = string.format(
              "%s/%s/layout.xml",
              self.rootDirectory,
              self.sourceDirectory
          )
  
          local xmlSource = readfile(xmlSourceFilepath)
  
          if self.layouts ~= nil then
              local layouts = {
                  xmlSource
              }
  
              for _, filepath in pairs(self.layouts) do
                  local layoutSourceFilepath = string.format(
                      "%s/%s/%s.xml",
                      self.rootDirectory,
                      self.sourceDirectory,
                      filepath
                  )
  
                  local layoutSource = readfile(layoutSourceFilepath)
  
                  if layoutSource == nil then
                      PanoramaElementException:fileNotFoundLayout(self, layoutSourceFilepath)
                  end
  
                  table.insert(layouts, layoutSource)
              end
  
              element.create(unpack(layouts))
          else
              element.create(xmlSource)
          end
      end
  
      if self.thinkFrame ~= nil then
          Callbacks.paintUi(function()
              self:thinkFrame()
          end)
      end
  end
  
  return Nyx.class(
  	"Nyx/PanoramaElement",
  	PanoramaElement
  )
  --endregion
end
package.preload["gamesense/Nyx/PanoramaElement"] = function() return return_values["PanoramaElement"] end
--endregion

--region PointEntity
libraries["PointEntity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local AbstractEntity = require "gamesense/Nyx/AbstractEntity"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  
  --region PointEntity
  --- @class PointEntity : AbstractEntity
  --- @field origin Vector3
  --- @field childPosition Vector3
  local PointEntity = {}
  
  --- @return void
  function PointEntity:__init()
  	AbstractEntity.__init(self)
  
  	if self.origin == nil then
  		self.origin = VectorsAngles.Vector3:new()
  	end
  end
  
  --- @return void
  function PointEntity:thinkFrame()
  
  end
  
  return Nyx.abstract(
  	"Nyx/PointEntity",
  	PointEntity,
  	AbstractEntity
  )
  --endregion
end
package.preload["gamesense/Nyx/PointEntity"] = function() return return_values["PointEntity"] end
--endregion

--region Render
libraries["Render"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Client = require "gamesense/Nyx/Client"
  
  --region Render
  --- @class Render : Abstract
  local Render = {}
  
  --- @param origin Vector3
  --- @param radius number
  --- @param thickness number
  --- @return number, number
  function Render.scaleCircle(origin, radius, thickness)
  	local distanceFactor = origin:getDistance(Client.getCameraOrigin() / 100)
  
  	return math.max(1, radius / distanceFactor), math.max(0.1, thickness / distanceFactor)
  end
  
  --- @param origin Vector3
  --- @param dimensions Vector2
  --- @return Vector2
  function Render.scaleDimensions(origin, dimensions)
  	return dimensions / (origin:getDistance(Client.getCameraOrigin()) / 100)
  end
  
  --- @param origin Vector3
  --- @param w number
  --- @param h number
  --- @return number, number
  function Render.scaleRectangle(origin, w, h)
  	local distanceFactor = origin:getDistance(Client.getCameraOrigin() / 100)
  
  	return math.max(1, w / distanceFactor), math.max(1, h / distanceFactor)
  end
  
  return Nyx.abstract(
  	"Nyx/Render",
  	Render
  )
  --endregion
end
package.preload["gamesense/Nyx/Render"] = function() return return_values["Render"] end
--endregion

--region Sound
libraries["Sound"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Sound
  --- @class Sound : Abstract
  local Sound = {}
  
  --- @param filename string
  --- @return void
  function Sound.playBasic(filename)
  	client.exec(string.format(
  		"sndplaydelay 0.01 %s",
  		filename
  	))
  end
  
  return Nyx.abstract(
  	"Nyx/Sound",
  	Sound
  )
  --endregion
end
package.preload["gamesense/Nyx/Sound"] = function() return return_values["Sound"] end
--endregion

--region Sso
libraries["Sso"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local Callbacks = require "gamesense/Nyx/Callbacks"
  local Data = require "gamesense/Nyx/Data"
  local Encrypt = require "gamesense/Nyx/Encrypt":new({2, 5, 1, 7, 5})
  local Panorama = require "gamesense/Nyx/Panorama"
  local Http = require "gamesense/Nyx/Http"
  local EventListener = require "gamesense/Nyx/EventListener"
  
  --region Hidden functions
  --- @param parameters table
  --- @return string
  local function encryptParameters(parameters)
      return Data.binaryToHex(Encrypt:encrypt(json.stringify(parameters)))
  end
  
  local charset = {}  do -- [0-9a-zA-Z]
      for c = 48, 57  do table.insert(charset, string.char(c)) end
      for c = 65, 90  do table.insert(charset, string.char(c)) end
      for c = 97, 122 do table.insert(charset, string.char(c)) end
  end
  
  --- @param length number
  --- @return string
  local function getRandomString(length)
      if not length or length <= 0 then return '' end
  
      return getRandomString(length - 1) .. charset[client.random_int(1, #charset)]
  end
  
  local hwid
  
  --- @return string
  local function getHwid()
      if hwid ~= nil then
          return hwid
      end
  
      local path = "csgo/cache/audiocache.db"
  
      hwid = readfile(path)
  
      if hwid == nil then
          hwid = getRandomString(255)
  
          writefile(path, hwid)
      end
  
      return hwid
  end
  --endregion
  
  --region Session
  --- @class Session : Class
  --- @field sessionUid string
  --- @field userUid string
  --- @field userAlias string
  local Session = {}
  
  --- @return Session
  function Session:new()
  	return Nyx.new(self)
  end
  
  Nyx.class(
  	"Nyx/Session",
  	Session
  )
  --endregion
  
  --region SsoException
  --- @class SsoException : Exception
  local SsoException = {
      SESSION_NOT_STARTED = 1
  }
  
  --- @param send Class
  function SsoException:sessionNotStarted(send)
      self:throw(SsoException.SESSION_NOT_STARTED, string.format(
          "Attempted to send Sso request for '%s', but the session has not yet been started or has been terminated.",
          send.__classname
      ))
  end
  
  Nyx.exception(
  	"Nyx/SsoException",
  	SsoException
  )
  --endregion
  
  --region SsoEvents
  --- @class SsoEvents : EventListener
  local SsoEvents = {}
  
  --- @param callback table|function
  --- @param callback fun(): void
  function SsoEvents.sessionStart(callback)
      SsoEvents.event("SessionStart", callback)
  end
  
  Nyx.abstract(
  	"Nyx/SsoEvents",
  	SsoEvents,
      EventListener
  )
  --endregion
  
  --region Sso
  --- @class Sso : Abstract
  --- @field domain string
  --- @field session Session
  --- @field sessionKeepAliveInterval number
  local Sso = {
      domain = "https://localhost:7216/api/sso/%s",
      sessionKeepAliveInterval = 5
  }
  
  --- @return void
  function Sso:__init()
      Sso.startSession()
  end
  
  --- @param callback fun(): void
  --- @return void
  function Sso.onSessionStart(callback)
      SsoEvents.sessionStart(callback)
  end
  
  --- @return void
  function Sso.startSession()
      Http.post(
          Http.url(Sso.domain, "start_session"),
          Session,
          {
              parameters = {
                  data = encryptParameters({
                      hwid = getHwid(),
                      xuid = Panorama.MyPersonaAPI.GetXuid(),
                      alias = Panorama.MyPersonaAPI.GetName()
                  })
              }
          },
          function(session)
          	Sso.session = session
  
              Sso.keepAlive()
              SsoEvents.sessionStart({})
  
              Callbacks.shutdown(function()
                  Sso.endSession()
              end)
          end
      )
  end
  
  --- @return void
  function Sso.endSession()
      if Sso.sessionActive then
          Http.post(
              Http.url(Sso.domain, "end_session"),
              nil,
              {
                  parameters = {
                      data = encryptParameters({
                          sessionUid = Sso.session.sessionUid
                      })
                  }
              }
          )
      end
  end
  
  --- @return void
  function Sso.keepAlive()
      Http.post(
          Http.url(Sso.domain, "keep_alive"),
          nil,
          {
              parameters = {
                  data = encryptParameters({
                      sessionUid = Sso.session.sessionUid
                  })
              }
          },
          function()
              client.delay_call(Sso.sessionKeepAliveInterval, function()
              	Sso.keepAlive()
              end)
          end
      )
  end
  
  --- Do not begin requests until after sessionStart event is fired.
  --- @generic T
  --- @param send Class
  --- @param receive T|Class
  --- @param callback fun(object: T): void
  function Sso.request(route, send, receive, callback)
      if Sso.session == nil then
          SsoException:sessionNotStarted(send)
      end
  
      local parameters = send:__serialize(true)
  
      parameters.sessionUid = Sso.session.sessionUid
  
      Http.post(
          Http.url(Sso.domain, route),
          receive,
          {
              parameters = {
                  data = encryptParameters(parameters)
              }
          },
          callback
      )
  end
  
  return Nyx.abstract(
  	"Nyx/Sso",
  	Sso
  )
  --endregion
end
package.preload["gamesense/Nyx/Sso"] = function() return return_values["Sso"] end
--endregion

--region Texture
libraries["Texture"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  local Client = require "gamesense/Nyx/Client"
  
  --region Texture
  --- @class Texture : Class
  --- @field textureId number
  --- @field dimensions Vector2
  local Texture = {}
  
  --- @param filename string
  --- @param w number
  --- @param h number
  --- @return Texture
  function Texture:new(filename, w, h)
  	return Nyx.new(self, {
  		textureId = renderer.load_png(readfile(filename), w, h),
  		dimensions = VectorsAngles.Vector2:new(w, h)
  	})
  end
  
  --- @param str string
  --- @param w number
  --- @param h number
  --- @return Texture
  function Texture:newFromString(str, w, h)
  	return Nyx.new(self, {
  		textureId = renderer.load_png(str, w, h),
  		dimensions = VectorsAngles.Vector2:new(w, h)
  	})
  end
  
  --- @param origin Vector3
  --- @param color Color
  --- @return void
  function Texture:renderWorld(origin, color)
  	origin:drawTexture(
  		self.textureId,
  		self.dimensions / (origin:getDistance(Client.getCameraOrigin()) / 100),
  		color,
  		true,
  		"f"
  	)
  end
  
  --- @param position Vector2
  --- @param color Color
  --- @param dimensions Vector2
  --- @param center boolean
  --- @return void
  function Texture:renderUi(position, color, dimensions, center)
  	position:drawTexture(
  		self.textureId,
  		dimensions or self.dimensions,
  		color,
  		center,
  		"f"
  	)
  end
  
  return Nyx.class(
  	"Nyx/Texture",
  	Texture
  )
  --endregion
end
package.preload["gamesense/Nyx/Texture"] = function() return return_values["Texture"] end
--endregion

--region UiEntity
libraries["UiEntity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local AbstractEntity = require "gamesense/Nyx/AbstractEntity"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  
  --region UiEntity
  --- @class UiEntity : AbstractEntity
  --- @field origin Vector2
  local UiEntity = {
  	renderType = 1
  }
  
  --- @return void
  function UiEntity:__init()
  	AbstractEntity.__init(self)
  
  	if self.origin == nil then
  		self.origin = VectorsAngles.Vector2:new()
  	end
  end
  
  return Nyx.abstract(
  	"Nyx/UiEntity",
  	UiEntity,
  	AbstractEntity
  )
  --endregion
end
package.preload["gamesense/Nyx/UiEntity"] = function() return return_values["UiEntity"] end
--endregion

--region VKey
libraries["VKey"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region VKey
  --- @class VKey : Class
  --- @field vKey number
  --- @field lastState boolean
  --- @field presses number
  --- @field lastPresses number
  --- @field presses number
  --- @field toggled boolean
  --- @field released boolean
  local VKey = {
  	presses = 0,
  	lastPresses = 0,
  	toggled = false,
  	released = false,
  	LEFT_MOUSE = 1,
  	RIGHT_MOUSE = 2,
  	MIDDLE_MOUSE = 3,
  	MOUSE_4 = 5,
  	MOUSE_5 = 6,
  	BACKSPACE = 8,
  	TAB = 9,
  	ENTER = 13,
  	SHIFT = 16,
  	CONTROL = 17,
  	ALT = 18,
  	PAUSE = 19,
  	CAPS_LOCK = 20,
  	ESCAPE = 27,
  	SPACE = 32,
  	PAGE_UP = 33,
  	PAGE_DOWN = 34,
  	PAGE_END = 35,
  	HOME = 36,
  	ARROW_LEFT = 37,
  	ARROW_UP = 38,
  	ARROW_RIGHT = 39,
  	ARROW_DOWN = 40,
  	INSERT = 45,
  	DEL = 46,
  	NUMROW_0 = 48,
  	NUMROW_1 = 49,
  	NUMROW_2 = 50,
  	NUMROW_3 = 51,
  	NUMROW_4 = 52,
  	NUMROW_5 = 53,
  	NUMROW_6 = 54,
  	NUMROW_7 = 55,
  	NUMROW_8 = 56,
  	NUMROW_9 = 57,
  	NUMROW_EQUALS = 61,
  	A = 65,
  	B = 66,
  	C = 67,
  	D = 68,
  	E = 69,
  	F = 70,
  	G = 71,
  	H = 72,
  	I = 73,
  	J = 74,
  	K = 75,
  	L = 76,
  	M = 77,
  	N = 78,
  	O = 79,
  	P = 80,
  	Q = 81,
  	R = 82,
  	S = 83,
  	T = 84,
  	U = 85,
  	V = 86,
  	W = 87,
  	X = 88,
  	Y = 89,
  	Z = 90,
  	WIN_LEFT = 91,
  	WIN_RIGHT = 92,
  	APPS = 93,
  	SLEEP = 95,
  	NUMPAD_0 = 96,
  	NUMPAD_1 = 97,
  	NUMPAD_2 = 98,
  	NUMPAD_3 = 99,
  	NUMPAD_4 = 100,
  	NUMPAD_5 = 101,
  	NUMPAD_6 = 102,
  	NUMPAD_7 = 103,
  	NUMPAD_8 = 104,
  	NUMPAD_9 = 105,
  	NUMPAD_MUL = 106,
  	NUMPAD_ADD = 107,
  	NUMPAD_SUB = 109,
  	NUMPAD_DECIMAL = 110,
  	NUMPAD_DIV = 111,
  	F1 = 112,
  	F2 = 113,
  	F3 = 114,
  	F4 = 115,
  	F5 = 116,
  	F6 = 117,
  	F7 = 118,
  	F8 = 119,
  	F9 = 120,
  	F10 = 121,
  	F11 = 122,
  	F12 = 123,
  	NUM_LOCK = 144,
  	SCROLL_LOCK = 145,
  	PUNCT_PERIOD = 190,
  	PUNCT_FORWARD_SLASH = 191,
  	PUNCT_TILDE = 192,
  	PUNCT_COMMA = 188,
  	PUNCT_LEFT_BRACE = 219,
  	PUNCT_BACKWARD_SLASH = 220,
  	PUNCT_RIGHT_BRACE = 221,
  	PUNCT_QUOTES = 222
  }
  
  --- @param vKey number
  --- @return VKey
  function VKey:new(vKey)
  	return Nyx.new(self, {
  		vKey = vKey
  	})
  end
  
  --- @param vKey number
  --- @return void
  function VKey:setKey(vKey)
  	self.vKey = vKey
  end
  
  --- @return void
  function VKey:update()
  	local state = client.key_state(self.vKey)
  
  	if self.lastState ~= state then
  		self.lastState = state
  
  		if state then
  			self.presses = self.presses + 1
  			self.toggled = not self.toggled
  		end
  	end
  end
  
  --- @return boolean
  function VKey:isHeld()
  	self:update()
  
  	return client.key_state(self.vKey)
  end
  
  --- @return boolean
  function VKey:isHit()
  	self:update()
  
  	if self.lastPresses ~= self.presses then
  		self.lastPresses = self.presses
  
  		return true
  	end
  
  	return false
  end
  
  --- @return boolean
  function VKey:isToggled()
  	self:update()
  
  	return self.toggled
  end
  
  --- @return boolean
  function VKey:isReleased()
  	self:update()
  
  	if self:isHeld() then
  		self.released = false
  
  		return false
  	end
  
  	if self.released == false then
  		self.released = true
  
  		return true
  	end
  
  	return false
  end
  
  return Nyx.class(
  	"Nyx/VKey",
  	VKey
  )
  --endregion
end
package.preload["gamesense/Nyx/VKey"] = function() return return_values["VKey"] end
--endregion

--region Weapons
libraries["Weapons"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  
  --region Weapons
  --- @class Weapons : Enum
  local Weapons = {
  	AK47 = "CAK47",
  	DEAGLE = "CDeagle",
  	KNIFE = "CKnife",
  	KNIFE_GG = "CKnifeGG",
  	AUG = "CWeaponAUG",
  	AWP = "CWeaponAWP",
  	BIZON = "CWeaponBizon",
  	ELITE = "CWeaponElite",
  	FAMAS = "CWeaponFamas",
  	FIVESEVEN = "CWeaponFiveSeven",
  	G3SG1 = "CWeaponG3SG1",
  	GALIL = "CWeaponGalilAR",
  	GLOCK = "CWeaponGlock",
  	P2000 = "CWeaponHKP2000",
  	M249 = "CWeaponM249",
  	M4A1 = "CWeaponM4A1",
  	MAC10 = "CWeaponMAC10",
  	MAG7 = "CWeaponMag7",
  	MP7 = "CWeaponMP7",
  	MP9 = "CWeaponMP9",
  	NEGEV = "CWeaponNegev",
  	NOVA = "CWeaponNOVA",
  	P228 = "CWeaponP228",
  	P250 = "CWeaponP250",
  	P90 = "CWeaponP90",
  	SAWEDOFF = "CWeaponSawedoff",
  	SCAR20 = "CWeaponSCAR20",
  	SSG08 = "CWeaponSSG08",
  	SG556 = "CWeaponSG556",
  	TASER = "CWeaponTaser",
  	ZEUS = "CWeaponTaser",
  	TEC9 = "CWeaponTec9",
  	UMP45 = "CWeaponUMP45",
  	XM1014 = "CWeaponXM1014",
  	DECOY = "CDecoyGrenade",
  	FLASH = "CFlashbang",
  	GRENADE = "CHEGrenade",
  	SMOKE = "CSmokeGrenade",
  	INCENDIARY = "CIncendiaryGrenade",
  	MOLOTOV = "CMolotovGrenade",
  	SENSOR = "CSensorGrenade",
  	SNOWBALL = "CSnowball",
  	TABLET = "CTablet",
  	HEALTHSHOT = "CItem_Healthshot",
  	BREACH_CHARGE = "CBreachCharge",
  	C4 = "CC4",
  	FISTS = "CFists",
  	ECON = "CEconEntity",
  	CASH = "CItemCash",
  	DOGTAGS = "CItemDogtags",
  	MELEE = "CMelee",
  	BUMP_MINE = "CBumpMine"
  }
  
  return Nyx.enum(
  	"Nyx/Weapons",
  	Weapons
  )
  --endregion
end
package.preload["gamesense/Nyx/Weapons"] = function() return return_values["Weapons"] end
--endregion

--region WorldEntity
libraries["WorldEntity"] = function()
	local Nyx = require "gamesense/Nyx/Framework"
  local AbstractEntity = require "gamesense/Nyx/AbstractEntity"
  local VectorsAngles = require "gamesense/Nyx/VectorsAngles"
  
  --region WorldEntity
  --- @class WorldEntity : AbstractEntity
  local WorldEntity = {
  	renderType = 2
  }
  
  --- @return void
  function WorldEntity:__init()
  	AbstractEntity.__init(self)
  
  	if self.origin == nil then
  		self.origin = VectorsAngles.Vector2:new()
  	end
  end
  
  return Nyx.abstract(
  	"Nyx/WorldEntity",
  	WorldEntity,
  	AbstractEntity
  )
  --endregion
end
package.preload["gamesense/Nyx/WorldEntity"] = function() return return_values["WorldEntity"] end
--endregion
--region Setup
local errorMessage = {
	invalidInstantiationType = "Attempted to instantiate %s, but it's a type of %s and does not support instances.",
	invalidClass = "Attempted to reference an invalid class. Classes must be setup with their respective functions before being used.",
	invalidClassFormat = "Attempted to setup a class from a non-table input. Input must be a table.",
	classAlreadyExists = "Attempted to setup %s, but it has already been setup.",
	abstractContractViolated = "%s has the abstract method '%s' but does not implement it. Please override all abstract methods.",
	interfaceContractViolated = "%s has the interface method '%s' but does not implement it. Please implement all interface methods.",
	invalidAbstractParent = "%s has the parent %s of type %s, but abstracts may only have other abstracts or interfaces as parents.",
	invalidEnumParent = "%s has the parent %s of type %s, but enums may only have other enums or interfaces as parents.",
	invalidInterfaceParent = "%s has the parent %s of type %s, but interfaces may only inherit other interfaces.",
	invalidInterfaceMember = "%s has declared the non-function member '%s'. Interfaces may only declare empty functions.",
	calledAbstractMethod = "Attempted to call abstract method."
}

--- @vararg string
local function die(...)
	error(string.format(...), 2)
end

local classtype = {
	class = 1,
	abstract = 2,
	enum = 3,
	interface = 4,
	exception = 5
}

local classtypeName = {
	[1] = "class",
	[2] = "abstract",
	[3] = "enum",
	[4] = "interface",
	[5] = "exception"
}

local instantiable = {
	[classtype.class] = true,
	[classtype.exception] = true
}

--- @type Exception
local activeException
--endregion

--region Declarations
--- @generic T
--- @class Class
--- @field __classid number
--- @field __classtype number
--- @field __classname string
--- @field __parent Class|T
--- @field __instanceid number
--- @field __init fun(self: T): void
--- @field __setup fun(self: T): void
local Class = {
	__classid = classtype.class,
	__classtype = classtype.class,
	__classname = "Nyx/Class"
}

--- @generic T
--- @param fields T
--- @return T
function Class:__constructor(fields)
	return setmetatable(fields or {}, self)
end

--- @class Abstract : Class
local Abstract = {
	__classid = classtype.abstract,
	__classtype = classtype.abstract,
	__classname = "Nyx/Abstract",
	__parent = Class
}

--- @return void
function Abstract:__constructor()
	die(errorMessage.invalidInstantiationType, self.__classname, classtypeName[classtype.abstract])
end

--- @class Enum : Class
--- @field __map table<string, string>
local Enum = {
	__classid = classtype.enum,
	__classtype = classtype.enum,
	__classname = "Nyx/Enum",
	__parent = Class,
	__map = {}
}

--- @return void
function Enum:__constructor()
	die(errorMessage.invalidInstantiationType, self.__classname, classtypeName[classtype.enum])
end

--- @param value any
--- @return boolean
function Enum:valid(value)
	return self[value] ~= nil
end

--- @param lookup string
--- @param caseInsensitive
--- @return any
function Enum:value(lookup, caseInsensitive)
	if caseInsensitive ~= true then
		return self[lookup]
	end

	return self[string.upper(string.upper(lookup))]
end

--- @param lookup string
function Enum:name(lookup)
	for member, value in pairs(self) do
		if lookup == value then
			return member
		end
	end
end

--- @return table
function Enum:names()
	local result = {}

	for member, value in pairs(self) do repeat
		if string.sub(member, 1, 2) == "__" then
			break
		end

		if type(value) == "function" then
			break
		end

		table.insert(result, member)
	until true end

	return result
end

--- @return table
function Enum:values()
	local result = {}

	for member, value in pairs(self) do repeat
		if string.sub(member, 1, 2) == "__" then
			break
		end

		if type(value) == "function" then
			break
		end

		result[member] = value
	until true end

	return result
end

--- @class Interface : Class
local Interface = {
	__classid = classtype.interface,
	__classtype = classtype.interface,
	__classname = "Nyx/Interface",
	__parent = Class
}

--- @class Exception : Class
--- @field __errorMessageFormat string
--- @field code number
--- @field message string
local Exception = {
	__classid = classtype.exception,
	__classtype = classtype.exception,
	__classname = "Nyx/Exception",
	__parent = Class,
	__errorMessageFormat = "Uncaught %s [%s]: %s"
}

--- @param code number
--- @param message string
function Exception:throw(code, message)
	local e = setmetatable({
		code = code,
		message = message
	}, self)

	activeException = e

	error(string.format(
		self.__errorMessageFormat,
		self.__classname,
		code,
		message
	), 3)
end
--endregion

--region Main locals
--- @type Class[]
local inheritance = {
	[classtype.class] = {
		[classtype.class] = Class
	},
	[classtype.abstract] = {
		[classtype.class] = Class,
		[classtype.abstract] = Abstract
	},
	[classtype.enum] = {
		[classtype.class] = Class,
		[classtype.enum] = Enum
	},
	[classtype.interface] = {
		[classtype.class] = Class,
		[classtype.interface] = Interface
	},
	[classtype.exception] = {
		[classtype.class] = Class,
		[classtype.interface] = Exception
	}
}

--- @type Class[]
local directParents = {
	[classtype.abstract] = Class,
	[classtype.enum] = Class,
	[classtype.interface] = Class,
	[classtype.exception] = Class
}

local latestClassId = #inheritance + 1
local latestInstanceId = 1
--endregion

--region Functions
--- @param c Class
local function validateInstantiable(c)
	if instantiable[c.__classtype] == nil then
		die(errorMessage.invalidInstantiationType, c.__classname, classtypeName[c.__classtype])
	end
end

--- @param c Class
local function validateClassExists(c)
	if c.__classid == nil then
		error(errorMessage.invalidClass, 4)
	end
end

--- @param c table|Class
local function validateValidClassFormat(c)
	if type(c) ~= "table" then
		die(errorMessage.invalidClassFormat)
	end

	if c.__classid ~= nil then
		die(errorMessage.classAlreadyExists, c.__classname)
	end
end

--- @param c Class
local function assignInstanceId(c)
	c.__instanceid = latestInstanceId

	latestInstanceId = latestInstanceId + 1
end

---  @param identifier string
--- @param c Class
local function assignClassMetadata(identifier, c)
	c.__classname = identifier
	c.__classid = latestClassId

	latestClassId = latestClassId + 1
end

--- @param parent Class
--- @param fallback Class
--- @return Class
local function assignParent(parent, fallback)
	if parent ~= nil then
		validateClassExists(parent)
	else
		parent = fallback
	end

	return parent
end

--- @param class Class
--- @param parent Class
local function assignClassInheritance(class, parent)
	class.__parent = parent
	class.__index = class

	--- @type Class[]
	local linearTree = {
		[1] = class
	}

	local recurseParent = parent
	local i = 2

	while recurseParent ~= nil do
		linearTree[i] = recurseParent

		recurseParent = recurseParent.__parent
		i = i + 1
	end

	local inheritanceTree = {}

	for i = 1, #linearTree do
		local iterateClass = linearTree[i]

		for member, value in pairs(iterateClass) do repeat
			if class[member] ~= nil then
				break
			end

			class[member] = value
		until true end

		inheritanceTree[iterateClass.__classid] = iterateClass
	end

	inheritance[class.__classid] = inheritanceTree
end

--- @param c Class
local function validateAbstractContract(c)
	for member, value in pairs(c) do repeat
		if type(value) ~= "function" then
			break
		end

		local status, message = pcall(value)

		if status == false and string.find(message, errorMessage.calledAbstractMethod) ~= nil then
			die(errorMessage.abstractContractViolated, c.__classname, member)
		end
	until true end
end

--- @param c Class
local function validateInterfaceMembers(c)
	for member, value in pairs(c) do
		if type(value) ~= "function" then
			die(errorMessage.invalidInterfaceMember, c.__classname, member)
		end
	end
end

--- @param c Class
--- @param parent Class
local function validateInterfaceContract(c, parent, identifier)
	for member, _ in pairs(parent) do
		if c[member] == nil and string.sub(member, 1, 2) ~= "__" then
			die(errorMessage.interfaceContractViolated, identifier, member)
		end
	end
end
--endregion

--region Global functions
--- @generic T
--- @param identifier string
--- @param self T|Class
--- @param parent Class|nil
--- @return T
local function class(identifier, self, parent)
	validateValidClassFormat(self)

	if parent ~= nil and parent.__classtype == classtype.interface then
		validateInterfaceContract(self, parent, identifier)
	end

	parent = assignParent(parent, Class)

	assignClassMetadata(identifier, self)
	assignClassInheritance(self, parent)

	if parent.__classtype == classtype.abstract then
		-- todo validateAbstractContract(self)
	end

	if self.__setup ~= nil then
		self.__setup(self)
	end

	self.__classtype = classtype.class

	return self
end

--- @generic T
--- @param identifier string
--- @param self T|Abstract
--- @param parent Abstract|Interface|nil
--- @return T
local function abstract(identifier, self, parent)
	validateValidClassFormat(self)

	if parent ~= nil and parent.__classtype == classtype.interface then
		validateInterfaceContract(self, parent, identifier)
	end

	parent = assignParent(parent, Abstract)

	if parent.__classtype ~= classtype.abstract and parent.__classtype ~= classtype.interface then
		die(errorMessage.invalidAbstractParent, identifier, parent.__classname, classtypeName[parent.__classtype])
	end

	assignClassMetadata(identifier, self)
	assignClassInheritance(self, parent)

	if self.__setup ~= nil then
		self.__setup(self)
	end

	self.__classtype = classtype.abstract

	return self
end

--- @generic T
--- @param identifier string
--- @param self T|Enum
--- @param parent Interface|Enum|nil
--- @return T
local function enum(identifier, self, parent)
	validateValidClassFormat(self)

	if parent ~= nil and parent.__classtype == classtype.interface then
		validateInterfaceContract(self, parent, identifier)
	end

	parent = assignParent(parent, Enum)

	if parent.__classtype ~= classtype.enum and parent.__classtype ~= classtype.interface then
		die(errorMessage.invalidEnumParent, identifier, parent.__classname, classtypeName[parent.__classtype])
	end

	assignClassMetadata(identifier, self)
	assignClassInheritance(self, parent)

	if self.__setup ~= nil then
		self.__setup(self)
	end

	self.__classtype = classtype.enum

	return self
end

--- @generic T
--- @param identifier string
--- @param self T|Interface
--- @param parent Interface|nil
--- @return T
local function interface(identifier, self, parent)
	validateValidClassFormat(self)
	validateInterfaceMembers(self)

	parent = assignParent(parent, Interface)

	if parent.__classtype ~= classtype.interface then
		die(errorMessage.invalidInterfaceParent, identifier, parent.__classname, classtypeName[parent.__classtype])
	end

	assignClassMetadata(identifier, self)
	assignClassInheritance(self, parent)

	if self.__setup ~= nil then
		self.__setup(self)
	end

	self.__classtype = classtype.interface

	return self
end

--- @generic T
--- @param identifier string
--- @param self T|Exception
--- @param parent Class|nil
--- @return T
local function exception(identifier, self, parent)
	validateValidClassFormat(self)

	if parent ~= nil and parent.__classtype == classtype.interface then
		validateInterfaceContract(self, parent, identifier)
	end

	parent = assignParent(parent, Exception)

	assignClassMetadata(identifier, self)
	assignClassInheritance(self, parent)

	if parent.__classtype == classtype.abstract then
		-- todo validateAbstractContract(self)
	end

	if self.__setup ~= nil then
		self.__setup(self)
	end

	self.__classtype = classtype.exception

	return self
end

--- @generic T
--- @param self T|Class
--- @param fields T|Class|table|nil
--- @return T
local function new(self, fields)
	validateClassExists(self)

	local o = self:__constructor(fields)

	assignInstanceId(o)

	if o.__init ~= nil then
		o.__init(o)
	end

	return o
end

--- @generic T
--- @param c T|Class|nil
--- @return T|Class
local function clone(c)
	validateInstantiable(c)

	--- @type Class
	local o = setmetatable({}, c)

	for member, value in pairs(c) do
		o[member] = value
	end

	assignInstanceId(o)

	return o
end

local function void()
	error(errorMessage.calledAbstractMethod, 2)
end

--- @param a Class
--- @param b Class
--- @return boolean
local function is(a, b)
	return a.__instanceid ~= nil and b.__instanceid ~= nil and a.__instanceid == b.__instanceid
end

--- @param a any|Class
--- @return boolean
local function isclass(a)
	return type(a) == "table" and a.__classid ~= nil
end

--- @param a Class
--- @return boolean
local function isinstance(a)
	return type(a) == "table" and a.__instanceid ~= nil
end

--- @param a Class
--- @param b Class
--- @return boolean
local function instanceof(a, b)
	if type(a) ~= "table" and a.__classid == nil then
		return false
	end

	return inheritance[a.__classid][b.__classid] ~= nil
end

--- @param value any|Class
--- @return string
local function typeof(value)
	local valueType = type(value)

	if valueType == "table" and value.__classname ~= nil then
		return value.__classname
	end

	return valueType
end

--- @param try fun()
--- @param catch fun(e: Exception)
local function try(try, catch)
	local status, message = pcall(try)

	if catch ~= nil then
		if activeException ~= nil then
			catch(activeException)
		elseif status == false then
			activeException = setmetatable({}, Exception)
			activeException.code = 0
			activeException.message = message

			catch(activeException)
		end
	end

	activeException = nil
end

--- @param e Exception
--- @param code number|nil
local function caught(e, code)
	return instanceof(activeException, e) and code ~= nil and true or activeException.code == code
end

--- @param exception Exception|nil
--- @vararg string
local function throw(exception, ...)
	if exception == nil then
		exception = Exception
	end

	--- @type Exception
	local e = setmetatable({
		code = 0,
		message = string.format(...)
	}, exception)

	activeException = e

	error(string.format(
		e.__errorMessageFormat,
		e.__classname,
		e.code,
		e.message
	), 2)
end

--- @param a Class
--- @return Class[]
local function getinheritance(a)
	return inheritance[a.__classid]
end

--- @generic T
--- @param t T
--- @return T
local function copytable(t)
	local b = {}

	for k, v in pairs(t) do
		b[k] = v
	end

	return b
end

--- Sorted pairs iteration.
--- @generic K, V
--- @param t table<K, V>|V[]
--- @param order fun(a: V, b: V): boolean
--- @return fun(t: table<K, V>): K, V
local function spairs(t, order)
	-- Collect the keys.
	local keys = {}

	for k in pairs(t) do
		keys[#keys + 1] = k
	end

	-- If order function given, sort by it by passing the table and keys a, b.
	-- Otherwise just sort the keys.
	if order then
		table.sort(keys, function(a, b)
			return order(t[a], t[b])
		end)
	else
		table.sort(keys)
	end

	local i = 0

	-- Return the iterator function.
	return function()
		i = i + 1

		if keys[i] then
			return keys[i], t[keys[i]]
		end
	end
end
--endregion

return {
	class = class,
	abstract = abstract,
	enum = enum,
	interface = interface,
	exception = exception,
	new = new,
	clone = clone,
	void = void,
	is = is,
	isclass = isclass,
	isinstance = isinstance,
	instanceof = instanceof,
	typeof = typeof,
	try = try,
	caught = caught,
	throw = throw,
	getinheritance = getinheritance,
	copytable = copytable,
	spairs = spairs,
}
local _UnhandledEvents = panorama.loadstring([[
    let RegisteredEvents = {};
    let EventQueue = [];

    function _registerEvent(event){
        if ( typeof RegisteredEvents[event] != 'undefined' ) return;
        RegisteredEvents[event] = $.RegisterForUnhandledEvent(event, (...data)=>{
            EventQueue.push([event, data]);
        })
    }

    function _UnRegisterEvent(event){
        if ( typeof RegisteredEvents[event] == 'undefined' ) return;
        $.UnregisterForUnhandledEvent(event, RegisteredEvents[event]);
        delete RegisteredEvents[event];
    }

    function _getEventQueue(){
        let Queue = EventQueue;
        EventQueue = [];
        return Queue;
    }

    function _shutdown(){
        for ( event in RegisteredEvents ) {
            _UnRegisterEvent(event);
        }
    }

    return  {
        register: _registerEvent,
        unRegister: _UnRegisterEvent,
        getQueue: _getEventQueue,
        shutdown: _shutdown
    }
]])()

local panorama_events = {callbacks={}}

function panorama_events.register_event(event, callback)
    _UnhandledEvents.register(event)
    panorama_events.callbacks[event] = panorama_events.callbacks[event] or {}
	table.insert(panorama_events.callbacks[event], callback)
	return callback
end

function panorama_events.unregister_event(event, callback)
    _UnhandledEvents.unRegister(event)
    panorama_events.callbacks[event] = panorama_events.callbacks[event] or {}
    for i, func in ipairs(panorama_events.callbacks[event]) do
        if ( func == callback ) then
            table.remove(panorama_events.callbacks[event], i)
        end
    end
end

local LastEventTick = client.timestamp()
client.set_event_callback('post_render', function()
    if ( client.timestamp() - LastEventTick > 10 ) then
        local EventQueue = _UnhandledEvents.getQueue()
        for index = 0, EventQueue.length - 1 do
            local Event = EventQueue[index]
            if ( Event ) then
                local EventName = Event[0]
                local EventData = Event[1]
                -- filtering event data
                local FilteredEventData = {}
                for i=0, EventData.length - 1 do
                    local Data = EventData[i]
                    FilteredEventData[i+1] = Data
                end
                panorama_events.callbacks[EventName] = panorama_events.callbacks[EventName] or {}
                for i, callback in ipairs(panorama_events.callbacks[EventName]) do
                    callback(unpack(FilteredEventData))
                end
            end
        end
        LastEventTick = client.timestamp()
    end
end)

client.set_event_callback('shutdown', function() _UnhandledEvents.shutdown() end)

return panorama_events
local utilities = {
	CharacterAnims = "file://{resources}/scripts/common/characteranims.js",
	ItemInfo = "file://{resources}/scripts/common/iteminfo.js",
	EventUtil = "file://{resources}/scripts/common/eventutil.js",
	FormatText = "file://{resources}/scripts/common/formattext.js",
	IconUtil = "file://{resources}/scripts/common/icon.js",
	ItemContextEntires = "file://{resources}/scripts/common/item_context_entries.js",
	LicenseUtil = "file://{resources}/scripts/common/licenseutil.js",
	Scheduler = "file://{resources}/scripts/common/scheduler.js",
	SessionUtil = "file://{resources}/scripts/common/sessionutil.js",
	FlipPanelAnimation = "file://{resources}/scripts/common/flip_panel_anim.js",
	TeamColor = "file://{resources}/scripts/common/teamcolor.js",
	OperationUtil = "file://{resources}/scripts/operation/operation_util.js",
	OperationMissionCard = "file://{resources}/scripts/operation/operation_mission_card.js",
	MockAdapter = "file://{resources}/scripts/mock_adapter.js",
	Avatar = "file://{resources}/scripts/avatar.js",
}

local layout = {}

table.insert(layout, "<root>")
table.insert(layout, "\t<scripts>")
for name, script in pairs(utilities) do
	table.insert(layout, "\t\t<include src=\"" .. script .. "\"/>")
end
table.insert(layout, "\t</scripts>")
table.insert(layout, "")
table.insert(layout, "\t<script>")
for name, script in pairs(utilities) do
	table.insert(layout, string.format("\t\t$.GetContextPanel().%s = %s;", name, name))
end
table.insert(layout, "\t</script>")
table.insert(layout, "")
table.insert(layout, "\t<Panel>")
table.insert(layout, "\t</Panel>")
table.insert(layout, "</root>")

layout = table.concat(layout, "\n")

local js_code = [[
	let global_this = this
	let modified_props = {}

	let _Create = function(layout, utilities) {
		let parent = $.GetContextPanel()
		if(!parent)
			return false

		let panel = $.CreatePanel("Panel", parent, "")
		if(!panel)
			return false

		if(!panel.BLoadLayoutFromString(layout, false, false))
			return false

		for(name in utilities) {
			if(panel[name]) {
				// global_this[name] = panel[name]

				Object.defineProperty(global_this, name, {
					enumerable: false,
					writable: false,
					configurable: true,
					value: panel[name]
				})

				modified_props[name] = true
			}
		}

		panel.RemoveAndDeleteChildren()
		panel.DeleteAsync(0.0)
	}

	let _Destroy = function() {
		for(key in modified_props) {
			delete global_this[key];
		}
		modified_props = {}
	}

	return {
		create: _Create,
		destroy: _Destroy
	}
]]

-- save context name -> context here
local js_contexts = {}

local function register_for_context(context_name)
	context_name = context_name or ""

	if js_contexts[context_name] ~= nil then
		return false
	elseif type(context_name) ~= "string" and context_name:gsub(" ", "") ~= "" then
		return error("invalid context, expected a non-empty string")
	end

	local js = context_name == "" and panorama.loadstring(js_code)() or panorama.loadstring(js_code, context_name)()

	js.create(layout, utilities)
	js_contexts[context_name] = js
end
register_for_context()

client.set_event_callback("shutdown", function()
	for name, context in pairs(js_contexts) do
		context.destroy()
	end
end)

-- always register for some contexts
local root_panel_names = {"CSGOJsRegistration", "CSGOHud", "CSGOMainMenu"}

for i=1, #root_panel_names do
	register_for_context(root_panel_names[i])
end

-- give user a function to register it for other contexts
return {
	register_for_context = register_for_context
}
local http = require "gamesense/http"

local polib = {}
function polib.new(AppToken, UserToken, AllowHTML)
    local mt = {}
    local req = {
        token = AppToken,
        user = UserToken,
        html = AllowHTML and 1 or nil
    }

    -- Initial Validation
    http.request('POST', 'https://api.pushover.net/1/users/validate.json', {params=req}, function(success, response)
        local jsonBody = json.parse(response.body)
        if ( jsonBody and jsonBody.status ~= 1 ) then
            error('[POLIB] Invalid token or user, please redefine.')
            mt.invalid = true
        end
    end)
    
    function mt:send(message, title, device, url, url_title, sound, timestamp, priority, retry, expire, callback)
        if ( mt.invalid ) then error('cannot send to a invalidated token and user') end

        req.message = message
        req.title = title
        req.device = device
        req.url = url
        req.url_title = url_title
        req.sound = sound
        req.timestamp = timestamp
        req.priority = priority
        req.retry = req.priority == 2 and math.min(retry, 30)
        req.expire = req.priority == 2 and math.max(expire, 10800)

        http.request('POST', 'https://api.pushover.net/1/messages.json', {params=req}, function(success, response)
            local errstr = ''
            local jsonBody = json.parse(response.body)
           
            if (response.status ~= 200) then
                errstr = "Error while sending request. Status code: " .. tostring(response.status) .. ", Body: " .. tostring(response.body)
            elseif (jsonBody.status ~= 1) then
                errstr = "Error from pushover: " .. tostring(response.body)
            end
            if ( errstr ~= '' ) then
                error('[POLIB] ' .. errstr)
            end

            if ( jsonBody.receipt and priority == 2 and type(callback) == 'function' ) then
                local Done
                local function CheckCallback()
                    local ReceiptConfirmURL = ('https://api.pushover.net/1/receipts/%s.json?token=%s'):format(jsonBody.receipt, AppToken)
                    http.get(ReceiptConfirmURL, function(_success, _response)
                        local receiptJson = json.parse(_response.body)
                        if ( receiptJson.status == 1 and receiptJson.acknowledged == 1 ) then
                            callback(receiptJson)
                        else
                            client.delay_call(5, CheckCallback)
                        end
                    end)
                end
                CheckCallback()
            end
        end)
    end
    
    return mt
end

return polib
local M = {}

local color_log, unpack, tostring = client.color_log, unpack, tostring
local concat, insert, remove = table.concat, table.insert, table.remove
local sub, rep, len = string.sub, string.rep, string.len
local COLOR_SYM_DEFAULT, COLOR_STRING_DEFAULT, COLOR_LITERAL_DEFAULT, COLOR_QUOTE_DEFAULT = {221, 221, 221}, {180, 230, 30}, {96, 160, 220}, {218, 230, 30}

function M.format(json_text, line_feed, indent, ac)
	json_text = tostring(json_text)
	line_feed, indent, ac = tostring(line_feed or "\n"), tostring(indent or "\t"), tostring(ac or " ")

	local i, j, k, n, r, p, q  = 1, 0, 0, len(json_text), {}, nil, nil
	local al = sub(ac, -1) == "\n"

	for x = 1, n do
		local c = sub(json_text, x, x)

		if not q and (c == "{" or c == "[") then
			r[i] = p == ":" and (c .. line_feed) or (rep(indent, j) .. c .. line_feed)
			j = j + 1
		elseif not q and (c == "}" or c == "]") then
			j = j - 1
			if p == "{" or p == "[" then
				i = i - 1
				r[i] = rep(indent, j) .. p .. c
			else
				r[i] = line_feed .. rep(indent, j) .. c
			end
		elseif not q and c == "," then
			r[i] = c .. line_feed
			k = -1
		elseif not q and c == ":" then
			r[i] = c .. ac
			if al then
				i = i + 1
				r[i] = rep(indent, j)
			end
		else
			if c == '"' and p ~= "\\" then
				q = not q and true or nil
			end
			if j ~= k then
				r[i] = rep(indent, j)
				i, k = i + 1, j
			end
			r[i] = c
		end
		p, i = c, i + 1
	end

	return concat(r)
end
local pretty_json = M.format

function M.highlight(json_text, color_sym, color_quote, color_string, color_literal)
	color_sym, color_string, color_literal, color_quote = color_sym or COLOR_SYM_DEFAULT, color_string or COLOR_STRING_DEFAULT, color_literal or COLOR_LITERAL_DEFAULT, color_quote or COLOR_QUOTE_DEFAULT
	json_text = tostring(json_text)

	local i, n, result, prev, quote = 1, len(json_text), {}, nil, nil

	local cur_clr, cur_text = color_sym, {}

	for x = 1, n do
		local c = sub(json_text, x, x)
		local new_clr

		if not quote and (c == "{" or c == "[") then
			new_clr = color_sym

			insert(cur_text, c)
		elseif not quote and (c == "}" or c == "]") then
			new_clr = color_sym
			if prev == "{" or prev == "[" then
				insert(cur_text, concat(prev, c))
			else
				insert(cur_text, c)
			end
		elseif not quote and (c == "," or c == ":") then
			new_clr = color_sym
			insert(cur_text, c)
		else
			if c == '"' and prev ~= "\\" then
				quote = not quote and true or nil
				new_clr = color_quote
			elseif cur_clr == color_quote then
				new_clr = quote and color_string or color_literal
			elseif cur_clr == color_sym and (c ~= " " and c ~= "\n" and c ~= "\t") then
				new_clr = quote and color_string or color_literal
			end

			insert(cur_text, c)
		end

		if new_clr ~= nil and new_clr ~= cur_clr then
			local new_text = {remove(cur_text, #cur_text)}

			insert(result, {cur_clr[1], cur_clr[2], cur_clr[3], concat(cur_text)})

			cur_clr, cur_text = new_clr, new_text
		end

		prev = c
	end

	if #cur_text > 0 then
		insert(result, {cur_clr[1], cur_clr[2], cur_clr[3], concat(cur_text)})
	end

	return result
end
local highlight_json = M.highlight

function M.print_highlighted(json_text, color_sym, color_quote, color_string, color_literal)
	local highlighted = highlight_json(json_text, color_sym, color_string, color_literal, color_quote)
	local count = #highlighted

	for i=1, count do
		local r, g, b, str = unpack(highlighted[i])
		color_log(r, g, b, str, i == count and "" or "\0")
	end

	return highlighted
end

function M.stringify(tbl, line_feed, indent, ac)
	local success, json_text = pcall(json.stringify, tbl)
	if not success then
		error(json_text, 2)
		return
	end

	return pretty_json(json_text, line_feed, indent, ac)
end

return M
local ffi = require "ffi"

local string_format = string.format
local ffi_cast = ffi.cast
local ffi_string = ffi.string

local ffi_type_map = {
	b = "int8_t", -- "b" a signed char.
	B = "uint8_t", -- "B" an unsigned char.
	h = "int16_t", -- "h" a signed short (2 bytes).
	H = "uint16_t", -- "H" an unsigned short (2 bytes).
	i = "int32_t", -- "i" a signed int (4 bytes).
	I = "uint32_t", -- "I" an unsigned int (4 bytes).
	l = "int64_t", -- "l" a signed long (8 bytes).
	L = "uint64_t", -- "L" an unsigned long (8 bytes).
	f = "float", -- "f" a float (4 bytes).
	d = "double", -- "d" a double (8 bytes).
	c = "const char" -- "cn" a sequence of exactly n chars corresponding to a single Lua string.
}

local ffi_structs = setmetatable({}, {
	__index = function(tbl, key)
		local struct_text = "struct { "

		local string_vals = {}
		local i, j = 1, 1
		while i <= key:len() do
			local a = key:sub(i, -1)
			local c = a:sub(1, 1)

			local t, l
			if ffi_type_map[c] ~= nil then
				t = ffi_type_map[c]
				if c == "c" then
					local match = a:match("^c(%d+)")

					if match then
						i = i + match:len()
						l = tonumber(match)
					end

					string_vals[j] = l
				end
			else
				error("invalid format string")
			end

			if t ~= nil then
				if l == nil then
					struct_text = struct_text .. string.format("%s v%d; ", t, j)
				else
					struct_text = struct_text .. string.format("%s v%d[%d]; ", t, j, l)
				end
				j = j + 1
			end
			i = i + 1
		end
		struct_text = struct_text .. "} __attribute__((packed))"

		tbl[key] = {ffi.typeof(struct_text .. "*"), ffi.sizeof(struct_text), j-1, string_vals}

		return tbl[key]
	end
})

local unpacks = 0
local struct_buffer_mt = {
	__index = {
		seek = function(self, seek_val, seek_mode)
			if seek_mode == nil or seek_mode == "CUR" then
				self.base_va = self.base_va + seek_val
			elseif seek_mode == "END" or seek_mode == "SET" then
				self.base_va = ffi.cast("const uint8_t *", ffi.cast("const char *", self.raw)) + (seek_mode == "SET" and seek_val or self.len + seek_val)
			end
		end,
		unpack = function(self, format_str)
			local struct, size, len, string_vals = unpack(ffi_structs[format_str])
			local unpacked = {}
			local val = ffi_cast(struct, self.base_va)[0]

			for i=1, len do
				unpacked[i] = val[string_format("v%d", i)]

				if string_vals[i] then
					unpacked[i] = ffi_string(unpacked[i], string_vals[i])
				end
			end

			self.base_va = self.base_va + size

			return unpack(unpacked)
		end,
		unpack_vec = function(self)
			local x, y, z = self:unpack("fff")
			return {x=x, y=y, z=z}
		end
	}
}

local function struct_buffer(raw)
	local buf = setmetatable({
		raw = raw,
		len = raw:len()
	}, struct_buffer_mt)
	buf:seek(0, "SET")
	return buf
end

-- cache
local navigation_mesh_cache = {}

-- use checksum so we dont have to keep the whole thing in memory
local function crc32(s, lt)
	-- return crc32 checksum of string as an integer
	-- use lookup table lt if provided or create one on the fly
	-- if lt is empty, it is initialized.
	lt = lt or {}
	local b, crc, mask
	if not lt[1] then -- setup table
		for i = 1, 256 do
			crc = i - 1
			for _ = 1, 8 do --eight times
				mask = -bit.band(crc, 1)
				crc = bit.bxor(bit.rshift(crc, 1), bit.band(0xedb88320, mask))
			end
			lt[i] = crc
		end
	end

	-- compute the crc
	crc = 0xffffffff
	for i = 1, #s do
		b = string.byte(s, i)
		crc = bit.bxor(bit.rshift(crc, 8), lt[bit.band(bit.bxor(crc, b), 0xFF) + 1])
	end
	return bit.band(bit.bnot(crc), 0xffffffff)
end

local function parse(raw, use_cache)
	local checksum
	if use_cache == nil or use_cache then
		checksum = crc32(raw)
		if navigation_mesh_cache[checksum] ~= nil then
			return navigation_mesh_cache[checksum]
		end
	end

	local buf = struct_buffer(raw)

	local self = {}
	self.magic, self.major, self.minor, self.bspsize, self.analyzed, self.places_count = buf:unpack("IIIIbH")

	assert(self.magic == 0xFEEDFACE, "invalid magic, expected 0xFEEDFACE")
	assert(self.major == 16, "invalid major version, expected 16")
	assert(self.analyzed == 1, "invalid nav mesh: not analyzed")

	-- place names
	self.places = {}
	for i=1, self.places_count do
		local place = {}
		place.name_length = buf:unpack("H")

		-- read but ignore null byte
		place.name = buf:unpack(string.format("c%db", place.name_length-1))

		self.places[i] = place
	end

	-- areas
	self.has_unnamed_areas, self.areas_count = buf:unpack("bI")

	self.areas = {}
	for i=1, self.areas_count do
		local area = {}
		area.id, area.flags = buf:unpack("II")

		area.north_west = buf:unpack_vec()
		area.south_east = buf:unpack_vec()

		area.north_east_z, area.south_west_z = buf:unpack("ff")

		-- connections
		area.connections = {}
		for dir=1, 4 do
			local connections_dir = {}
			connections_dir.count = buf:unpack("I")

			connections_dir.connections = {}
			for i=1, connections_dir.count do
				local target
				target = buf:unpack("I")
				connections_dir.connections[i] = target
			end
			area.connections[dir] = connections_dir
		end

		-- hiding spots
		area.hiding_spots_count = buf:unpack("B")
		area.hiding_spots = {}
		for i=1, area.hiding_spots_count do
			local hiding_spot = {}
			hiding_spot.id = buf:unpack("I")
			hiding_spot.location = buf:unpack_vec()
			hiding_spot.flags = buf:unpack("b")
			area.hiding_spots[i] = hiding_spot
		end

		-- encounter paths
		area.encounter_paths_count = buf:unpack("I")

		area.encounter_paths = {}
		for i=1, area.encounter_paths_count do
			local encounter_path = {}
			encounter_path.from_id, encounter_path.from_direction, encounter_path.to_id, encounter_path.to_direction, encounter_path.spots_count = buf:unpack("IBIBB")

			encounter_path.spots = {}
			for i=1, encounter_path.spots_count do
				encounter_path.spots[i] = {}
				encounter_path.spots[i].order_id, encounter_path.spots[i].distance = buf:unpack("IB")
			end
			area.encounter_paths[i] = encounter_path
		end

		area.place_id = buf:unpack("H")

		-- place ladders
		area.ladders = {}
		for i=1, 2 do
			area.ladders[i] = {}
			area.ladders[i].connection_count = buf:unpack("I")

			area.ladders[i].connections = {}
			for j=1, area.ladders[i].connection_count do
				area.ladders[i].connections[j] = buf:unpack("I")
			end
		end

		area.earliest_occupy_time_first_team, area.earliest_occupy_time_second_team = buf:unpack("ff")
		area.light_intensity_north_west, area.light_intensity_north_east, area.light_intensity_south_east, area.light_intensity_south_west = buf:unpack("ffff")

		-- visible areas
		area.visible_area_count = buf:unpack("I")
		area.visible_areas = {}
		for i=1, area.visible_area_count do
			area.visible_areas[i] = {}
			area.visible_areas[i].id, area.visible_areas[i].attributes = buf:unpack("Ib")
		end
		area.inherit_visibility_from_area_id = buf:unpack("I")

		-- garbage?
		area.garbage_count = buf:unpack("B")
		buf:seek(area.garbage_count*14)

		self.areas[i] = area
	end

	-- ladders
	self.ladders_count = buf:unpack("I")
	self.ladders = {}
	for i=1, self.ladders_count do
		local ladder = {}
		ladder.id, ladder.width = buf:unpack("If")

		ladder.top = buf:unpack_vec()
		ladder.bottom = buf:unpack_vec()

		ladder.length, ladder.direction = buf:unpack("fI")

		ladder.top_forward_area_id, ladder.top_left_area_id, ladder.top_right_area_id, ladder.top_behind_area_id = buf:unpack("IIII")
		ladder.bottom_area_id = buf:unpack("I")

		self.ladders[i] = ladder
	end

	if checksum ~= nil and navigation_mesh_cache[checksum] == nil then
		navigation_mesh_cache[checksum] = self
	end

	return self
end

return {
	parse = parse
}
--
-- dependencies
--

local ffi = require "ffi"
local md5 = require "gamesense/md5"
local cast, cdef, typeof, sizeof, istype, ffi_string, ffi_copy = ffi.cast, ffi.cdef, ffi.typeof, ffi.sizeof, ffi.istype, ffi.string, ffi.copy
local string_len, string_sub, string_gsub, string_match, string_gmatch, string_lower, string_upper, string_format, string_reverse = string.len, string.sub, string.gsub, string.match, string.gmatch, string.lower, string.upper, string.format, string.reverse
local assert, tostring, tonumber, setmetatable, pairs, ipairs, pcall, xpcall, error, type = assert, tostring, tonumber, setmetatable, pairs, ipairs, pcall, xpcall, error, type
local error_log, find_signature, timestamp = client.error_log, client.find_signature, client.timestamp
local table_insert, table_remove = table.insert, table.remove
local math_floor, math_min, math_max = math.floor, math.min, math.max
local band, bor, rshift, lshift, bswap = bit.band, bit.bor, bit.rshift, bit.lshift, bit.bswap
local md5_sum = md5.sum

--
-- constants
--

local uintptr_t = typeof("uintptr_t")
local uint64_t = typeof("uint64_t")
local BASE_STEAMID64 = 76561197960265728ULL

local uint64_t_arr = typeof("uint64_t[?]")
-- local uint64_t_ptr = typeof("uint64_t*")
local uint32_t_arr = typeof("uint32_t[?]")
local uint32_t_ptr = typeof("uint32_t*")
local uint8_t_arr = typeof("uint8_t[?]")
local uint8_t_ptr = typeof("uint8_t*")
local bool_arr = typeof("bool[?]")
local bool_ptr = typeof("bool*")

--
-- utility functions
--

local function find_sig(mdlname, pattern, typename, offset, deref_count)
	local raw_match = find_signature(mdlname, pattern) or error("signature not found", 2)
	local match = cast("uintptr_t", raw_match)

	if offset ~= nil and offset ~= 0 then
		match = match + offset
	end

	if deref_count ~= nil then
		for i = 1, deref_count do
			match = cast("uintptr_t*", match)[0]
			if match == nil then
				return error("signature not found")
			end
		end
	end

	return cast(typename, match)
end

local function vtable_entry(instance, index, typ)
	assert(instance ~= nil)
	assert(cast("void***", instance)[0] ~= nil)
	return cast(typ, (cast("void***", instance)[0])[index])
end

local function pointer_key(p)
	return tonumber(cast(uintptr_t, p))
end

local function is_defined(typ)
	return (pcall(typeof, typ))
end

local function safe_cdef(name, typedef)
	if not is_defined(name) then
		cdef(typedef)
	end
end

local function struct_to_tbl(inst, fields, string_field_lookup)
	local index = {}
	local tbl = setmetatable({}, {__index = index})

	if inst ~= nil then
		for key, key_alt in pairs(fields) do
			local val = inst[key]

			if string_field_lookup ~= nil and string_field_lookup[key] and val ~= nil then
				val = ffi_string(inst[key])
			end

			tbl[key] = val
			index[key_alt] = val
		end
	end

	return tbl
end

local function error_log_prefix(text)
	return function(message)
		return error_log(text .. tostring(message))
	end
end

--
-- references to parent objects
--

local PARENT_TBL = setmetatable({}, {__mode = "k"})

local function DEREF_GCSAFE(parent)
	local child = parent[0]

	-- prevent parent from getting garbage collected if child wasnt garbage collected yet
	PARENT_TBL[child] = parent

	return child
end

--
-- basic module initialization
--

local M = {}

local index_funcs, index_funcs_extra = {}, {}

setmetatable(M, {
	__index = function(tbl, key)
		if tbl == M then
			if index_funcs[key] ~= nil then
				-- print("[!] Initializing interface ", key)
				M[key] = index_funcs[key]()
				index_funcs[key] = nil

				if index_funcs_extra[key] ~= nil then
					index_funcs_extra[key]()
				end

				return M[key]
			end
		end
	end
})

--
-- enums
--

local enums = {
	ESteamIPType = {IPv4=0,IPv6=1},
	EUniverse = {Invalid=0,Public=1,Beta=2,Internal=3,Dev=4,Max=5},
	EResult = {None=0,OK=1,Fail=2,NoConnection=3,InvalidPassword=5,LoggedInElsewhere=6,InvalidProtocolVer=7,InvalidParam=8,FileNotFound=9,Busy=10,InvalidState=11,InvalidName=12,InvalidEmail=13,DuplicateName=14,AccessDenied=15,Timeout=16,Banned=17,AccountNotFound=18,InvalidSteamID=19,ServiceUnavailable=20,NotLoggedOn=21,Pending=22,EncryptionFailure=23,InsufficientPrivilege=24,LimitExceeded=25,Revoked=26,Expired=27,AlreadyRedeemed=28,DuplicateRequest=29,AlreadyOwned=30,IPNotFound=31,PersistFailed=32,LockingFailed=33,LogonSessionReplaced=34,ConnectFailed=35,HandshakeFailed=36,IOFailure=37,RemoteDisconnect=38,ShoppingCartNotFound=39,Blocked=40,Ignored=41,NoMatch=42,AccountDisabled=43,ServiceReadOnly=44,AccountNotFeatured=45,AdministratorOK=46,ContentVersion=47,TryAnotherCM=48,PasswordRequiredToKickSession=49,AlreadyLoggedInElsewhere=50,Suspended=51,Cancelled=52,DataCorruption=53,DiskFull=54,RemoteCallFailed=55,PasswordUnset=56,ExternalAccountUnlinked=57,PSNTicketInvalid=58,ExternalAccountAlreadyLinked=59,RemoteFileConflict=60,IllegalPassword=61,SameAsPreviousValue=62,AccountLogonDenied=63,CannotUseOldPassword=64,InvalidLoginAuthCode=65,AccountLogonDeniedNoMail=66,HardwareNotCapableOfIPT=67,IPTInitError=68,ParentalControlRestricted=69,FacebookQueryError=70,ExpiredLoginAuthCode=71,IPLoginRestrictionFailed=72,AccountLockedDown=73,AccountLogonDeniedVerifiedEmailRequired=74,NoMatchingURL=75,BadResponse=76,RequirePasswordReEntry=77,ValueOutOfRange=78,UnexpectedError=79,Disabled=80,InvalidCEGSubmission=81,RestrictedDevice=82,RegionLocked=83,RateLimitExceeded=84,AccountLoginDeniedNeedTwoFactor=85,ItemDeleted=86,AccountLoginDeniedThrottle=87,TwoFactorCodeMismatch=88,TwoFactorActivationCodeMismatch=89,AccountAssociatedToMultiplePartners=90,NotModified=91,NoMobileDevice=92,TimeNotSynced=93,SmsCodeFailed=94,AccountLimitExceeded=95,AccountActivityLimitExceeded=96,PhoneActivityLimitExceeded=97,RefundToWallet=98,EmailSendFailure=99,NotSettled=100,NeedCaptcha=101,GSLTDenied=102,GSOwnerDenied=103,InvalidItemType=104,IPBanned=105,GSLTExpired=106,InsufficientFunds=107,TooManyPending=108,NoSiteLicensesFound=109,WGNetworkSendExceeded=110,AccountNotFriends=111,LimitedUserAccount=112,CantRemoveItem=113,AccountDeleted=114,ExistingUserCancelledLicense=115,CommunityCooldown=116,NoLauncherSpecified=117,MustAgreeToSSA=118,LauncherMigrated=119},
	EVoiceResult = {OK=0,NotInitialized=1,NotRecording=2,NoData=3,BufferTooSmall=4,DataCorrupted=5,Restricted=6,UnsupportedCodec=7,ReceiverOutOfDate=8,ReceiverDidNotAnswer=9},
	EDenyReason = {Invalid=0,InvalidVersion=1,Generic=2,NotLoggedOn=3,NoLicense=4,Cheater=5,LoggedInElseWhere=6,UnknownText=7,IncompatibleAnticheat=8,MemoryCorruption=9,IncompatibleSoftware=10,SteamConnectionLost=11,SteamConnectionError=12,SteamResponseTimedOut=13,SteamValidationStalled=14,SteamOwnerLeftGuestUser=15},
	EBeginAuthSessionResult = {OK=0,InvalidTicket=1,DuplicateRequest=2,InvalidVersion=3,GameMismatch=4,ExpiredTicket=5},
	EAuthSessionResponse = {OK=0,UserNotConnectedToSteam=1,NoLicenseOrExpired=2,VACBanned=3,LoggedInElseWhere=4,VACCheckTimedOut=5,AuthTicketCanceled=6,AuthTicketInvalidAlreadyUsed=7,AuthTicketInvalid=8,PublisherIssuedBan=9},
	EUserHasLicenseForAppResult = {HasLicense=0,DoesNotHaveLicense=1,NoAuth=2},
	EAccountType = {Invalid=0,Individual=1,Multiseat=2,GameServer=3,AnonGameServer=4,Pending=5,ContentServer=6,Clan=7,Chat=8,ConsoleUser=9,AnonUser=10,Max=11},
	EChatEntryType = {Invalid=0,ChatMsg=1,Typing=2,InviteGame=3,Emote=4,LeftConversation=6,Entered=7,WasKicked=8,WasBanned=9,Disconnected=10,HistoricalChat=11,LinkBlocked=14},
	EChatRoomEnterResponse = {Success=1,DoesntExist=2,NotAllowed=3,Full=4,Error=5,Banned=6,Limited=7,ClanDisabled=8,CommunityBan=9,MemberBlockedYou=10,YouBlockedMember=11,RatelimitExceeded=15},
	EChatSteamIDInstanceFlags = {InstanceMask=4095,FlagClan=524288,FlagLobby=262144,FlagMMSLobby=131072},
	ENotificationPosition = {TopLeft=0,TopRight=1,BottomLeft=2,BottomRight=3},
	EMarketNotAllowedReasonFlags = {None=0,TemporaryFailure=1,AccountDisabled=2,AccountLockedDown=4,AccountLimited=8,TradeBanned=16,AccountNotTrusted=32,SteamGuardNotEnabled=64,SteamGuardOnlyRecentlyEnabled=128,RecentPasswordReset=256,NewPaymentMethod=512,InvalidCookie=1024,UsingNewDevice=2048,RecentSelfRefund=4096,NewPaymentMethodCannotBeVerified=8192,NoRecentPurchases=16384,AcceptedWalletGift=32768},
	EDurationControlProgress = {Full=0,Half=1,None=2,ExitSoon_3h=3,ExitSoon_5h=4,ExitSoon_Night=5},
	EDurationControlNotification = {None=0,["1Hour"]=1,["3Hours"]=2,HalfProgress=3,NoProgress=4,ExitSoon_3h=5,ExitSoon_5h=6,ExitSoon_Night=7},
	EDurationControlOnlineState = {Invalid=0,Offline=1,Online=2,OnlineHighPri=3},
	ESteamIPv6ConnectivityProtocol = {Invalid=0,HTTP=1,UDP=2},
	ESteamIPv6ConnectivityState = {Unknown=0,Good=1,Bad=2},
	EFriendRelationship = {None=0,Blocked=1,RequestRecipient=2,Friend=3,RequestInitiator=4,Ignored=5,IgnoredFriend=6,Suggested_DEPRECATED=7,Max=8},
	EPersonaState = {Offline=0,Online=1,Busy=2,Away=3,Snooze=4,LookingToTrade=5,LookingToPlay=6,Invisible=7,Max=8},
	EFriendFlags = {None=0,Blocked=1,FriendshipRequested=2,Immediate=4,ClanMember=8,OnGameServer=16,RequestingFriendship=128,RequestingInfo=256,Ignored=512,IgnoredFriend=1024,ChatMember=4096,All=65535},
	EOverlayToStoreFlag = {None=0,AddToCart=1,AddToCartAndShow=2},
	EActivateGameOverlayToWebPageMode = {Default=0,Modal=1},
	EPersonaChange = {Name=1,Status=2,ComeOnline=4,GoneOffline=8,GamePlayed=16,GameServer=32,Avatar=64,JoinedSource=128,LeftSource=256,RelationshipChanged=512,NameFirstSet=1024,Broadcast=2048,Nickname=4096,SteamLevel=8192,RichPresence=16384},
	ESteamAPICallFailure = {None=-1,SteamGone=0,NetworkFailure=1,InvalidHandle=2,MismatchedCallback=3},
	EGamepadTextInputMode = {Normal=0,Password=1},
	EGamepadTextInputLineMode = {SingleLine=0,MultipleLines=1},
	ETextFilteringContext = {Unknown=0,GameContent=1,Chat=2,Name=3},
	ECheckFileSignature = {InvalidSignature=0,ValidSignature=1,FileNotFound=2,NoSignaturesFoundForThisApp=3,NoSignaturesFoundForThisFile=4},
	EMatchMakingServerResponse = {eServerResponded=0,eServerFailedToRespond=1,eNoServersListedOnMasterServer=2},
	ELobbyType = {Private=0,FriendsOnly=1,Public=2,Invisible=3,PrivateUnique=4},
	ELobbyComparison = {EqualToOrLessThan=-2,LessThan=-1,Equal=0,GreaterThan=1,EqualToOrGreaterThan=2,NotEqual=3},
	ELobbyDistanceFilter = {Close=0,Default=1,Far=2,Worldwide=3},
	ESteamPartyBeaconLocationType = {Invalid=0,ChatGroup=1,Max=2},
	ERemoteStoragePublishedFileVisibility = {Public=0,FriendsOnly=1,Private=2,Unlisted=3},
	EWorkshopFileType = {First=0,Community=0,Microtransaction=1,Collection=2,Art=3,Video=4,Screenshot=5,Game=6,Software=7,Concept=8,WebGuide=9,IntegratedGuide=10,Merch=11,ControllerBinding=12,SteamworksAccessInvite=13,SteamVideo=14,GameManagedItem=15,Max=16},
	EWorkshopVote = {Unvoted=0,For=1,Against=2,Later=3},
	EWorkshopFileAction = {Played=0,Completed=1},
	ELeaderboardDataRequest = {Global=0,GlobalAroundUser=1,Friends=2,Users=3},
	ELeaderboardSortMethod = {None=0,Ascending=1,Descending=2},
	ELeaderboardDisplayType = {None=0,Numeric=1,TimeSeconds=2,TimeMilliSeconds=3},
	ELeaderboardUploadScoreMethod = {None=0,KeepBest=1,ForceUpdate=2},
	ERegisterActivationCodeResult = {OK=0,Fail=1,AlreadyRegistered=2,Timeout=3,AlreadyOwned=4},
	EP2PSessionError = {None=0,NoRightsToApp=2,Timeout=4,NotRunningApp_DELETED=1,DestinationNotLoggedIn_DELETED=3,Max=5},
	EP2PSend = {Unreliable=0,UnreliableNoDelay=1,Reliable=2,ReliableWithBuffering=3},
	ESNetSocketState = {Invalid=0,Connected=1,Initiated=10,LocalCandidatesFound=11,ReceivedRemoteCandidates=12,ChallengeHandshake=15,Disconnecting=21,LocalDisconnect=22,TimeoutDuringConnect=23,RemoteEndDisconnected=24,ConnectionBroken=25},
	ESNetSocketConnectionType = {NotConnected=0,UDP=1,UDPRelay=2},
	EVRScreenshotType = {None=0,Mono=1,Stereo=2,MonoCubemap=3,MonoPanorama=4,StereoPanorama=5},
	AudioPlayback_Status = {Undefined=0,Playing=1,Paused=2,Idle=3},
	EHTTPMethod = {Invalid=0,GET=1,HEAD=2,POST=3,PUT=4,DELETE=5,OPTIONS=6,PATCH=7},
	EHTTPStatusCode = {Invalid=0,["100Continue"]=100,["101SwitchingProtocols"]=101,["200OK"]=200,["201Created"]=201,["202Accepted"]=202,["203NonAuthoritative"]=203,["204NoContent"]=204,["205ResetContent"]=205,["206PartialContent"]=206,["300MultipleChoices"]=300,["301MovedPermanently"]=301,["302Found"]=302,["303SeeOther"]=303,["304NotModified"]=304,["305UseProxy"]=305,["307TemporaryRedirect"]=307,["400BadRequest"]=400,["401Unauthorized"]=401,["402PaymentRequired"]=402,["403Forbidden"]=403,["404NotFound"]=404,["405MethodNotAllowed"]=405,["406NotAcceptable"]=406,["407ProxyAuthRequired"]=407,["408RequestTimeout"]=408,["409Conflict"]=409,["410Gone"]=410,["411LengthRequired"]=411,["412PreconditionFailed"]=412,["413RequestEntityTooLarge"]=413,["414RequestURITooLong"]=414,["415UnsupportedMediaType"]=415,["416RequestedRangeNotSatisfiable"]=416,["417ExpectationFailed"]=417,["4xxUnknown"]=418,["429TooManyRequests"]=429,["444ConnectionClosed"]=444,["500InternalServerError"]=500,["501NotImplemented"]=501,["502BadGateway"]=502,["503ServiceUnavailable"]=503,["504GatewayTimeout"]=504,["505HTTPVersionNotSupported"]=505,["5xxUnknown"]=599},
	EInputSourceMode = {None=0,Dpad=1,Buttons=2,FourButtons=3,AbsoluteMouse=4,RelativeMouse=5,JoystickMove=6,JoystickMouse=7,JoystickCamera=8,ScrollWheel=9,rigger=10,ouchMenu=11,MouseJoystick=12,MouseRegion=13,RadialMenu=14,SingleButton=15,Switches=16},
	EParentalFeature = {Invalid=0,Store=1,Community=2,Profile=3,Friends=4,News=5,Trading=6,Settings=7,Console=8,Browser=9,ParentalSetup=10,Library=11,Test=12,SiteLicense=13,Max=14},
	ESteamDeviceFormFactor = {Unknown=0,Phone=1,Tablet=2,Computer=3,TV=4},
	ESteamNetworkingAvailability = {CannotTry=-102,Failed=-101,Previously=-100,Retrying=-10,NeverTried=1,Waiting=2,Attempting=3,Current=100,Unknown=0},
	ESteamNetworkingIdentityType = {Invalid=0,SteamID=16,XboxPairwiseID=17,SonyPSN=18,GoogleStadia=19,IPAddress=1,GenericString=2,GenericBytes=3,UnknownType=4},
	ESteamNetworkingConnectionState = {None=0,Connecting=1,FindingRoute=2,Connected=3,ClosedByPeer=4,ProblemDetectedLocally=5,FinWait=-1,Linger=-2,Dead=-3},
	ESteamNetTransportKind = {Unknown=0,LoopbackBuffers=1,LocalHost=2,UDP=3,UDPProbablyLocal=4,TURN=5,SDRP2P=6,SDRHostedServer=7},
	ESteamNetworkingConfigScope = {Global=1,SocketsInterface=2,ListenSocket=3,Connection=4},
	ESteamNetworkingConfigDataType = {Int32=1,Int64=2,Float=3,String=4,Ptr=5},
	ESteamNetworkingConfigValue = {Invalid=0,FakePacketLoss_Send=2,FakePacketLoss_Recv=3,FakePacketLag_Send=4,FakePacketLag_Recv=5,FakePacketReorder_Send=6,FakePacketReorder_Recv=7,FakePacketReorder_Time=8,FakePacketDup_Send=26,FakePacketDup_Recv=27,FakePacketDup_TimeMax=28,TimeoutInitial=24,TimeoutConnected=25,SendBufferSize=9,SendRateMin=10,SendRateMax=11,NagleTime=12,IP_AllowWithoutAuth=23,MTU_PacketSize=32,MTU_DataSize=33,Unencrypted=34,EnumerateDevVars=35,SymmetricConnect=37,LocalVirtualPort=38,Callback_ConnectionStatusChanged=201,Callback_AuthStatusChanged=202,Callback_RelayNetworkStatusChanged=203,Callback_MessagesSessionRequest=204,Callback_MessagesSessionFailed=205,Callback_CreateConnectionSignaling=206,P2P_STUN_ServerList=103,P2P_Transport_ICE_Enable=104,P2P_Transport_ICE_Penalty=105,P2P_Transport_SDR_Penalty=106,SDRClient_ConsecutitivePingTimeoutsFailInitial=19,SDRClient_ConsecutitivePingTimeoutsFail=20,SDRClient_MinPingsBeforePingAccurate=21,SDRClient_SingleSocket=22,SDRClient_ForceRelayCluster=29,SDRClient_DebugTicketAddress=30,SDRClient_ForceProxyAddr=31,SDRClient_FakeClusterPing=36,LogLevel_AckRTT=13,LogLevel_PacketDecode=14,LogLevel_Message=15,LogLevel_PacketGaps=16,LogLevel_P2PRendezvous=17,LogLevel_SDRRelayPings=18},
	ESteamNetworkingGetConfigValueResult = {BadValue=-1,BadScopeObj=-2,BufferTooSmall=-3,OK=1,OKInherited=2},
	ESteamNetworkingSocketsDebugOutputType = {None=0,Bug=1,Error=2,Important=3,Warning=4,Msg=5,Verbose=6,Debug=7,Everything=8},
	EHTMLMouseButton = {Left=0,Right=1,Middle=2},
	EHTMLKeyModifiers = {None=0,AltDown=1,CtrlDown=2,ShiftDown=4},
	PlayerAcceptState_t = {Unknown=0,PlayerAccepted=1,PlayerDeclined=2},
}

-- create fallback mapping value -> key
for name, enum in pairs(enums) do
	local metatable = {__index={}}
	for key, value in pairs(enum) do
		-- accept all lower / upper case variants
		metatable.__index[string_lower(key)] = value
		metatable.__index[string_upper(key)] = value

		-- accept reverse mapping
		metatable.__index[value] = key
	end
	setmetatable(enum, metatable)
	M[name] = enum
end

--
-- constants
--

local constants = {--[[--constants--]]}

-- define enums globally in module
for name, value in pairs(constants) do
	M[name] = value
end

--
-- SteamID class
--

if not is_defined("SteamID") then
	cdef([[
		typedef union {
			uint64_t steamid64;
			struct {
			  uint32_t accountid : 32;
			  unsigned int instance : 20;
			  unsigned int type : 4;
			  unsigned int universe : 8;
			};
			struct {
			  uint32_t low;
			  uint32_t high;
			};
		} __attribute__((packed)) SteamID;
	]])
end

assert(sizeof("SteamID") == 8)

local to_steamid
local SteamID = typeof("SteamID")
do
	local EAccountType = enums.EAccountType
	local EChatSteamIDInstanceFlags = enums.EChatSteamIDInstanceFlags

	local TYPE_CHARS = {
		[EAccountType.INVALID] = 'I',
		[EAccountType.INDIVIDUAL] = 'U',
		[EAccountType.MULTISEAT] = 'M',
		[EAccountType.GAMESERVER] = 'G',
		[EAccountType.ANONGAMESERVER] = 'A',
		[EAccountType.PENDING] = 'P',
		[EAccountType.CONTENTSERVER] = 'C',
		[EAccountType.CLAN] = 'g',
		[EAccountType.CHAT] = 'T',
		[EAccountType.ANONUSER] = 'a',
	}

	local INVITE_DICT = {
		['0'] = 'b',
		['1'] = 'c',
		['2'] = 'd',
		['3'] = 'f',
		['4'] = 'g',
		['5'] = 'h',
		['6'] = 'j',
		['7'] = 'k',
		['8'] = 'm',
		['9'] = 'n',
		['a'] = 'p',
		['b'] = 'q',
		['c'] = 'r',
		['d'] = 't',
		['e'] = 'v',
		['f'] = 'w',
	}

	local FRIEND_CODE_BASE32_STR = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"

	local FRIEND_CODE_BASE32, FRIEND_CODE_BASE32_REVERSE = {}, {}
	for i=1, 32 do
		local c = FRIEND_CODE_BASE32_STR:sub(i, i)
		FRIEND_CODE_BASE32[i-1] = c
		FRIEND_CODE_BASE32_REVERSE[c] = i-1
	end
	local FRIEND_CODE_PATTERN_CHAR = "[" .. FRIEND_CODE_BASE32_STR .. "]"

	local TYPE_CHARS_REVERSE = {}
	for key, char in pairs(TYPE_CHARS) do
		TYPE_CHARS_REVERSE[char] = key
	end

	local INSTANCE_DESKTOP = 1

	local FLAG_CLAN = EChatSteamIDInstanceFlags.FlagClan
	local FLAG_LOBBY = EChatSteamIDInstanceFlags.FlagLobby

	local TYPE_INVALID, TYPE_INDIVIDUAL, TYPE_GAMESERVER, TYPE_ANONGAMESERVER, TYLE_MULTISEAT, TYPE_CLAN, TYPE_CHAT, TYPE_MAX = EAccountType.INVALID, EAccountType.INDIVIDUAL, EAccountType.GAMESERVER, EAccountType.ANONGAMESERVER, EAccountType.MULTISEAT, EAccountType.CLAN, EAccountType.CHAT, EAccountType.MAX

	-- patterns for parsing steamids
	local STEAMID64_PATTERN = "^765(" .. string.rep("%d", 14) .. ")$"
	local STEAMID2_PATTERN = "^STEAM_([012345]):([01]):(%d+)$"
	local STEAMID3_SHORT_PATTERN = "^%[(%a):([012345]):(%d+)%]$"
	local STEAMID3_LONG_PATTERN = "^%[(%a):([012345]):(%d+):(%d+)%]$"
	local FRIEND_CODE_PATTERN = "^(" .. string.rep(FRIEND_CODE_PATTERN_CHAR, 5) .. ")%-(" .. string.rep(FRIEND_CODE_PATTERN_CHAR, 4) .. ")$"

	local function steamid_render_steam64(self)
		return string_sub(tostring(self.steamid64), 1, -4)
	end

	local function steamid_render_steam2(self, newer_format)
		if self.type ~= TYPE_INDIVIDUAL then
			return error("Cannot render non-individual ID as Steam2")
		end

		local universe = self.universe
		if (newer_format or newer_format == nil) and universe == 1 then
			universe = 0
		end

		return string_format("STEAM_%d:%d:%d", universe, band(self.accountid, 1), math_floor(self.accountid / 2))
	end

	local function steamid_render_steam3(self)
		local type_char

		if band(self.instance, FLAG_CLAN) == FLAG_CLAN then
			type_char = "c"
		elseif band(self.instance, FLAG_LOBBY) == FLAG_LOBBY then
			type_char = "L"
		else
			type_char = TYPE_CHARS[self.type] or "i"
		end

		local render_instance = self.type == TYPE_ANONGAMESERVER or self.type == TYLE_MULTISEAT or (self.type == TYPE_INDIVIDUAL and self.instance ~= INSTANCE_DESKTOP)

		return string_format("[%s:%d:%d%s]", type_char, self.universe, self.accountid, render_instance and (":" .. self.instance) or "")
	end

	local function steamid_render_invite(self)
		if self.type ~= TYPE_INVALID and self.type ~= TYPE_INDIVIDUAL then
			return error("Cannot only render individual / invalid ID as Steam Invite")
		end

		local hex = string_gsub(string_format("%x", self.accountid), ".", function(chr)
			return INVITE_DICT[chr] or chr
		end)

		local len = string_len(hex)
		if len > 3 then
			local pos = math_floor(len / 2)

			return string_format("%s-%s", string_sub(hex, 1, pos), string_sub(hex, pos+1, -1))
		end

		return hex
	end

	-- full credits to:
	-- https://github.com/xPaw/SteamID.php/blob/a3493148bbf01de5246ca5107c29cd4347f1bc45/SteamID.php#L339-L406
	-- https://github.com/emily33901/go-csfriendcode/blob/master/friendcode.go

	local function steamid_render_friend_code(self)
		if self.type ~= TYPE_INVALID and self.type ~= TYPE_INDIVIDUAL then
			return error("Cannot only render individual / invalid ID as Friend Code")
		end

		-- if true then return "AAAAA-AAAA" end

		-- shift by string "CSGO" (0x4353474)
		local buf_uint64 = uint64_t_arr(1, bor(self.accountid, 0x4353474F00000000ULL))

		-- convert to little endian string
		local hash = ffi_string(cast("const char*", buf_uint64), 8)

		-- Hash the exported number
		hash = md5_sum(hash)

		-- Take the first 4 bytes and convert it back to a number
		ffi_copy(cast("void*", buf_uint64), hash, 4)

		local hash_uint = buf_uint64[0]
		local result = 0ULL

		-- blame valve
		for i=0, 7 do
			local id_nibble = tonumber(band(rshift(self.steamid64, i*4), 0xF))
			local hash_nibble = tonumber(band(rshift(hash_uint, i), 1))

			local a = bor(lshift(result, 4), id_nibble)

			result = bor(lshift(rshift(result, 28), 32), a)
			result = bor(lshift(rshift(result, 31), 32), bor(lshift(a, 1), hash_nibble))
		end

		-- swap endianness
		result = bswap(result)

		-- yes
		local code = ""
		for i=0, 8 do
			if i == 5 then
				code = code .. "-"
			end

			code = code .. FRIEND_CODE_BASE32[tonumber(band(rshift(result, 20+i*5), 31))]
		end

		return code
	end

	local function steamid_is_valid(self)
		if self.type <= TYPE_INVALID or self.type >= TYPE_MAX then
			return false
		end

		if self.universe <= 0 or self.universe > 4 then
			return false
		end

		if self.type == TYPE_INDIVIDUAL and (self.accountid == 0 or self.instance > 4) then
			return false
		end

		if self.type == TYPE_CLAN and (self.accountid == 0 or self.instance ~= 0) then
			return false
		end

		if self.type == TYPE_GAMESERVER and self.accountid == 0 then
			return false
		end

		return true
	end

	local function steamid_pack(self, big_endian)
		local res = ffi_string(cast("const char*", uint64_t_arr(1, self.steamid64)), 8)

		if big_endian then
			res = string_reverse(res)
		end

		return res
	end

	local function steamid_mt_eq(self, other)
		if not istype(SteamID, self) then
			-- make 1234 == steamid -> steamid == 1234
			self, other = other, self
		end

		local t = type(other)

		if t == "nil" then
			return false
		elseif t == "cdata" and istype(SteamID, other) then
			return self.steamid64 == other.steamid64
		elseif (t == "number" or t == "cdata") and (self.accountid == other or self.steamid64 == other) then
			return true
		end

		return self.steamid64 == to_steamid(other).steamid64
	end

	pcall(ffi.metatype, SteamID, {
		__index = {
			is_valid = steamid_is_valid,
			render_steam2 = steamid_render_steam2,
			render_steam3 = steamid_render_steam3,
			render_steam64 = steamid_render_steam64,
			render_steam_invite = steamid_render_invite,
			render_friend_code = steamid_render_friend_code,
			pack = steamid_pack
		},
		__tostring = steamid_render_steam64,
		__eq = steamid_mt_eq
	})

	function to_steamid(steamid)
		if istype(SteamID, steamid) then
			return steamid
		elseif istype(uint64_t, steamid) and steamid > BASE_STEAMID64 then
			return SteamID(steamid)
		end

		local t = type(steamid)
		if t == "string" then
			local id64_part = string_match(steamid, STEAMID64_PATTERN)
			if id64_part ~= nil then
				return SteamID(76500000000000000ULL + tonumber(id64_part))
			end

			local id2_universe, id2_odd, id2_accountid = string_match(steamid, STEAMID2_PATTERN)
			if id2_universe ~= nil then
				local ret = SteamID()

				ret.universe = id2_universe == "0" and 1 or tonumber(id2_universe)
				ret.type = TYPE_INDIVIDUAL
				ret.instance = INSTANCE_DESKTOP
				ret.accountid = tonumber(id2_accountid) * 2 + id2_odd

				return ret
			end

			local id3_typechar, id3_universe, id3_accountid, id3_instance = string_match(steamid, STEAMID3_SHORT_PATTERN)
			if id3_typechar ~= nil then
				if id3_typechar == "U" then
					id3_instance = INSTANCE_DESKTOP
				else
					id3_instance = 0
				end
			else
				id3_typechar, id3_universe, id3_accountid, id3_instance = string_match(steamid, STEAMID3_LONG_PATTERN)
			end

			if id3_typechar ~= nil then
				local ret = SteamID()

				ret.universe = tonumber(id3_universe)
				ret.instance = tonumber(id3_instance)
				ret.accountid = tonumber(id3_accountid)

				if id3_typechar == "c" then
					ret.instance = bor(ret.instance, FLAG_CLAN)
					ret.type = TYPE_CHAT
				elseif id3_typechar == "L" then
					ret.instance = bor(ret.instance, FLAG_LOBBY)
					ret.type = TYPE_CHAT
				else
					ret.type = TYPE_CHARS_REVERSE[id3_typechar] or 0
				end

				return ret
			end

			local fc_part1, fc_part2 = string_match(steamid, FRIEND_CODE_PATTERN)
			if fc_part1 ~= nil then
				local full_code = "AAAA" .. fc_part1 .. fc_part2

				local result = 0ULL
				local i = 0
				for char in string_gmatch(full_code, ".") do
					local val = cast(uint64_t, FRIEND_CODE_BASE32_REVERSE[char])

					result = bor(result, lshift(val, i*5))

					i = i + 1
				end

				result = bswap(result)

				local ret = SteamID()

				for _=0, 7 do
					result = rshift(result, 1)

					local id_nibble = band(result, 0xF)

					result = rshift(result, 4)

					ret.accountid = bor(lshift(ret.accountid, 4), id_nibble)
				end

				ret.type = TYPE_INDIVIDUAL
				ret.universe = 1
				ret.instance = 1

				return ret
			end
		elseif t == "number" and steamid > 0 then
			return SteamID(BASE_STEAMID64 + steamid)
		end

		return nil
	end
end

--
-- struct definitions
--

safe_cdef("SteamIPAddress_t", [[
	typedef struct {
		uint8_t m_rgubIPv6[16];
		int m_eType;
	} SteamIPAddress_t;
]])

safe_cdef("FriendGameInfo_t", [[
	typedef struct {
		uint64_t m_gameID;
		uint32_t m_unGameIP;
		uint16_t m_usGamePort;
		uint16_t m_usQueryPort;
		SteamID m_steamIDLobby;
	} FriendGameInfo_t;
]])

safe_cdef("MatchMakingKeyValuePair_t", [[
	typedef struct {
		char m_szKey[256];
		char m_szValue[256];
	} MatchMakingKeyValuePair_t;
]])

safe_cdef("servernetadr_t", [[
	typedef struct {
		uint16_t m_usConnectionPort;
		uint16_t m_usQueryPort;
		uint32_t m_unIP;
	} servernetadr_t;
]])

safe_cdef("gameserveritem_t", [[
	typedef struct {
		servernetadr_t m_NetAdr;
		int m_nPing;
		bool m_bHadSuccessfulResponse;
		bool m_bDoNotRefresh;
		char m_szGameDir[32];
		char m_szMap[32];
		char m_szGameDescription[64];
		uint32_t m_nAppID;
		int m_nPlayers;
		int m_nMaxPlayers;
		int m_nBotPlayers;
		bool m_bPassword;
		bool m_bSecure;
		uint32_t m_ulTimeLastPlayed;
		int m_nServerVersion;
		char m_szServerName[64];
		char m_szGameTags[128];
		SteamID m_steamID;
	} gameserveritem_t;
]])

safe_cdef("SteamPartyBeaconLocation_t", [[
	typedef struct {
		int m_eType;
		uint64_t m_ulLocationID;
	} SteamPartyBeaconLocation_t;
]])

safe_cdef("SteamParamStringArray_t", [[
	typedef struct {
		const char ** m_ppStrings;
		int32_t m_nNumStrings;
	} SteamParamStringArray_t;
]])

safe_cdef("LeaderboardEntry_t", [[
	typedef struct {
		SteamID m_steamIDUser;
		int32_t m_nGlobalRank;
		int32_t m_nScore;
		int32_t m_cDetails;
		uint64_t m_hUGC;
	} LeaderboardEntry_t;
]])

safe_cdef("P2PSessionState_t", [[
	typedef struct {
		uint8_t m_bConnectionActive;
		uint8_t m_bConnecting;
		uint8_t m_eP2PSessionError;
		uint8_t m_bUsingRelay;
		int32_t m_nBytesQueuedForSend;
		int32_t m_nPacketsQueuedForSend;
		uint32_t m_nRemoteIP;
		uint16_t m_nRemotePort;
	} P2PSessionState_t;
]])

safe_cdef("InputAnalogActionData_t", [[
	typedef struct {
		int eMode;
		float x;
		float y;
		bool bActive;
	} InputAnalogActionData_t;
]])

safe_cdef("InputDigitalActionData_t", [[
	typedef struct {
		bool bState;
		bool bActive;
	} InputDigitalActionData_t;
]])

safe_cdef("InputMotionData_t", [[
	typedef struct {
		float rotQuatX;
		float rotQuatY;
		float rotQuatZ;
		float rotQuatW;
		float posAccelX;
		float posAccelY;
		float posAccelZ;
		float rotVelX;
		float rotVelY;
		float rotVelZ;
	} InputMotionData_t;
]])

safe_cdef("SteamUGCDetails_t", [[
	typedef struct {
		uint64_t m_nPublishedFileId;
		int m_eResult;
		int m_eFileType;
		unsigned int m_nCreatorAppID;
		unsigned int m_nConsumerAppID;
		char m_rgchTitle[129];
		char m_rgchDescription[8000];
		uint64_t m_ulSteamIDOwner;
		uint32_t m_rtimeCreated;
		uint32_t m_rtimeUpdated;
		uint32_t m_rtimeAddedToUserList;
		int m_eVisibility;
		bool m_bBanned;
		bool m_bAcceptedForUse;
		bool m_bTagsTruncated;
		char m_rgchTags[1025];
		uint64_t m_hFile;
		uint64_t m_hPreviewFile;
		char m_pchFileName[260];
		int32_t m_nFileSize;
		int32_t m_nPreviewFileSize;
		char m_rgchURL[256];
		uint32_t m_unVotesUp;
		uint32_t m_unVotesDown;
		float m_flScore;
		uint32_t m_unNumChildren;
	} SteamUGCDetails_t;
]])

safe_cdef("SteamItemDetails_t", [[
	typedef struct {
		uint64_t m_itemId;
		int m_iDefinition;
		uint16_t m_unQuantity;
		uint16_t m_unFlags;
	} SteamItemDetails_t;
]])

safe_cdef("SteamNetworkingIPAddr", [[
	typedef struct {
		uint8_t m_ipv6[16];
		uint16_t m_port;
	} SteamNetworkingIPAddr;
]])

safe_cdef("SteamNetworkingIdentity", [[
	typedef struct {
		int m_eType;
		int m_cbSize;
		char m_szUnknownRawString[128];
	} SteamNetworkingIdentity;
]])

safe_cdef("SteamNetConnectionInfo_t", [[
	typedef struct {
		SteamNetworkingIdentity m_identityRemote;
		int64_t m_nUserData;
		unsigned int m_hListenSocket;
		SteamNetworkingIPAddr m_addrRemote;
		uint16_t m__pad1;
		unsigned int m_idPOPRemote;
		unsigned int m_idPOPRelay;
		int m_eState;
		int m_eEndReason;
		char m_szEndDebug[128];
		char m_szConnectionDescription[128];
		int m_eTransportKind;
		uint32_t reserved[63];
	} SteamNetConnectionInfo_t;
]])

safe_cdef("SteamNetworkingQuickConnectionStatus", [[
	typedef struct {
		int m_eState;
		int m_nPing;
		float m_flConnectionQualityLocal;
		float m_flConnectionQualityRemote;
		float m_flOutPacketsPerSec;
		float m_flOutBytesPerSec;
		float m_flInPacketsPerSec;
		float m_flInBytesPerSec;
		int m_nSendRateBytesPerSecond;
		int m_cbPendingUnreliable;
		int m_cbPendingReliable;
		int m_cbSentUnackedReliable;
		long long m_usecQueueTime;
		uint32_t reserved[16];
	} SteamNetworkingQuickConnectionStatus;
]])

safe_cdef("SteamNetworkingMessage_t", [[
	typedef struct _SteamNetworkingMessage_t {
		void * m_pData;
		int m_cbSize;
		unsigned int m_conn;
		SteamNetworkingIdentity m_identityPeer;
		int64_t m_nConnUserData;
		long long m_usecTimeReceived;
		int64_t m_nMessageNumber;
		void (__thiscall * m_pfnFreeData)(struct _SteamNetworkingMessage_t *);
		void (__thiscall * m_pfnRelease)(struct _SteamNetworkingMessage_t *);
		int m_nChannel;
		int m_nFlags;
		int64_t m_nUserData;
	} SteamNetworkingMessage_t;
]])

safe_cdef("SteamNetworkPingLocation_t", [[
	typedef struct {
		uint8_t m_data[512];
	} SteamNetworkPingLocation_t;
]])

safe_cdef("SteamNetworkingConfigValue_t", [[
	typedef struct {
		int m_eValue;
		int m_eDataType;
		int64_t m_int64;
	} SteamNetworkingConfigValue_t;
]])

safe_cdef("SteamNetworkingPOPIDRender", [[
	typedef struct {
		char buf[8];
	} SteamNetworkingPOPIDRender;
]])

safe_cdef("SteamNetworkingIdentityRender", [[
	typedef struct {
		char buf[128];
	} SteamNetworkingIdentityRender;
]])

safe_cdef("SteamNetworkingIPAddrRender", [[
	typedef struct {
		char buf[48];
	} SteamNetworkingIPAddrRender;
]])

safe_cdef("SteamDatagramHostedAddress", [[
	typedef struct {
		int m_cbSize;
		char m_data[128];
	} SteamDatagramHostedAddress;
]])

safe_cdef("SteamDatagramGameCoordinatorServerLogin", [[
	typedef struct {
		SteamNetworkingIdentity m_identity;
		SteamDatagramHostedAddress m_routing;
		unsigned int m_nAppID;
		unsigned int m_rtime;
		int m_cbAppData;
		char m_appData[2048];
	} SteamDatagramGameCoordinatorServerLogin;
]])

safe_cdef("SteamNetAuthenticationStatus_t", [[
	typedef struct {
		int m_eAvail;
		char m_debugMsg[256];
	} SteamNetAuthenticationStatus_t;
]])

safe_cdef("SteamRelayNetworkStatus_t", [[
	typedef struct {
		int m_eAvail;
		int m_bPingMeasurementInProgress;
		int m_eAvailNetworkConfig;
		int m_eAvailAnyRelay;
		char m_debugMsg[256];
	} SteamRelayNetworkStatus_t;
]])

safe_cdef("SteamNetConnectionStatusChangedCallback_t", [[
	typedef struct {
		unsigned int m_hConn;
		SteamNetConnectionInfo_t m_info;
		int m_eOldState;
	} SteamNetConnectionStatusChangedCallback_t;
]])

safe_cdef("SteamNetworkingMessagesSessionRequest_t", [[
	typedef struct {
		SteamNetworkingIdentity m_identityRemote;
	} SteamNetworkingMessagesSessionRequest_t;
]])

safe_cdef("SteamNetworkingMessagesSessionFailed_t", [[
	typedef struct {
		SteamNetConnectionInfo_t m_info;
	} SteamNetworkingMessagesSessionFailed_t;
]])


--
-- some fixes
--

safe_cdef("SteamDatagramRelayAuthTicket", [[
	typedef struct {
		SteamNetworkingIdentity m_identityGameserver;
		SteamNetworkingIdentity m_identityAuthorizedClient;
		uint32_t m_unPublicIP;
		uint32_t m_rtimeTicketExpiry;
		SteamDatagramHostedAddress m_routing;
		uint32_t m_nAppID;
		int m_nRestrictToVirtualPort;
		int m_nExtraFields;

		struct {
			enum EType
			{
				k_EType_String,
				k_EType_Int,
				k_EType_Fixed64,
			};
			int m_eType;
			char m_szName[28];

			union {
				char m_szStringValue[128];
				int64_t m_nIntValue;
				uint64_t m_nFixed64Value;
			};
		} m_vecExtraFields[ 16 ];

	} SteamDatagramRelayAuthTicket;
]])

--
-- structs
--

local structs = {
	SteamIPAddress_t = typeof("SteamIPAddress_t"),
	SteamIPAddress_t_arr = typeof("SteamIPAddress_t [?]"),
	FriendGameInfo_t = typeof("FriendGameInfo_t"),
	FriendGameInfo_t_arr = typeof("FriendGameInfo_t [?]"),
	MatchMakingKeyValuePair_t = typeof("MatchMakingKeyValuePair_t"),
	MatchMakingKeyValuePair_t_arr = typeof("MatchMakingKeyValuePair_t [?]"),
	servernetadr_t = typeof("servernetadr_t"),
	servernetadr_t_arr = typeof("servernetadr_t [?]"),
	gameserveritem_t = typeof("gameserveritem_t"),
	gameserveritem_t_arr = typeof("gameserveritem_t [?]"),
	SteamPartyBeaconLocation_t = typeof("SteamPartyBeaconLocation_t"),
	SteamPartyBeaconLocation_t_arr = typeof("SteamPartyBeaconLocation_t [?]"),
	SteamParamStringArray_t = typeof("SteamParamStringArray_t"),
	SteamParamStringArray_t_arr = typeof("SteamParamStringArray_t [?]"),
	LeaderboardEntry_t = typeof("LeaderboardEntry_t"),
	LeaderboardEntry_t_arr = typeof("LeaderboardEntry_t [?]"),
	P2PSessionState_t = typeof("P2PSessionState_t"),
	P2PSessionState_t_arr = typeof("P2PSessionState_t [?]"),
	InputAnalogActionData_t = typeof("InputAnalogActionData_t"),
	InputAnalogActionData_t_arr = typeof("InputAnalogActionData_t [?]"),
	InputDigitalActionData_t = typeof("InputDigitalActionData_t"),
	InputDigitalActionData_t_arr = typeof("InputDigitalActionData_t [?]"),
	InputMotionData_t = typeof("InputMotionData_t"),
	InputMotionData_t_arr = typeof("InputMotionData_t [?]"),
	SteamUGCDetails_t = typeof("SteamUGCDetails_t"),
	SteamUGCDetails_t_arr = typeof("SteamUGCDetails_t [?]"),
	SteamItemDetails_t = typeof("SteamItemDetails_t"),
	SteamItemDetails_t_arr = typeof("SteamItemDetails_t [?]"),
	SteamNetworkingIPAddr = typeof("SteamNetworkingIPAddr"),
	SteamNetworkingIPAddr_arr = typeof("SteamNetworkingIPAddr [?]"),
	SteamNetworkingIdentity = typeof("SteamNetworkingIdentity"),
	SteamNetworkingIdentity_arr = typeof("SteamNetworkingIdentity [?]"),
	SteamNetConnectionInfo_t = typeof("SteamNetConnectionInfo_t"),
	SteamNetConnectionInfo_t_arr = typeof("SteamNetConnectionInfo_t [?]"),
	SteamNetworkingQuickConnectionStatus = typeof("SteamNetworkingQuickConnectionStatus"),
	SteamNetworkingQuickConnectionStatus_arr = typeof("SteamNetworkingQuickConnectionStatus [?]"),
	SteamNetworkingMessage_t = typeof("SteamNetworkingMessage_t"),
	SteamNetworkingMessage_t_arr = typeof("SteamNetworkingMessage_t [?]"),
	SteamNetworkPingLocation_t = typeof("SteamNetworkPingLocation_t"),
	SteamNetworkPingLocation_t_arr = typeof("SteamNetworkPingLocation_t [?]"),
	SteamNetworkingConfigValue_t = typeof("SteamNetworkingConfigValue_t"),
	SteamNetworkingConfigValue_t_arr = typeof("SteamNetworkingConfigValue_t [?]"),
	SteamNetworkingPOPIDRender = typeof("SteamNetworkingPOPIDRender"),
	SteamNetworkingPOPIDRender_arr = typeof("SteamNetworkingPOPIDRender [?]"),
	SteamNetworkingIdentityRender = typeof("SteamNetworkingIdentityRender"),
	SteamNetworkingIdentityRender_arr = typeof("SteamNetworkingIdentityRender [?]"),
	SteamNetworkingIPAddrRender = typeof("SteamNetworkingIPAddrRender"),
	SteamNetworkingIPAddrRender_arr = typeof("SteamNetworkingIPAddrRender [?]"),
	SteamDatagramHostedAddress = typeof("SteamDatagramHostedAddress"),
	SteamDatagramHostedAddress_arr = typeof("SteamDatagramHostedAddress [?]"),
	SteamDatagramGameCoordinatorServerLogin = typeof("SteamDatagramGameCoordinatorServerLogin"),
	SteamDatagramGameCoordinatorServerLogin_arr = typeof("SteamDatagramGameCoordinatorServerLogin [?]"),
	SteamNetAuthenticationStatus_t = typeof("SteamNetAuthenticationStatus_t"),
	SteamNetAuthenticationStatus_t_arr = typeof("SteamNetAuthenticationStatus_t [?]"),
	SteamRelayNetworkStatus_t = typeof("SteamRelayNetworkStatus_t"),
	SteamRelayNetworkStatus_t_arr = typeof("SteamRelayNetworkStatus_t [?]"),
	SteamNetConnectionStatusChangedCallback_t = typeof("SteamNetConnectionStatusChangedCallback_t"),
	SteamNetConnectionStatusChangedCallback_t_arr = typeof("SteamNetConnectionStatusChangedCallback_t [?]"),
	SteamNetworkingMessagesSessionRequest_t = typeof("SteamNetworkingMessagesSessionRequest_t"),
	SteamNetworkingMessagesSessionRequest_t_arr = typeof("SteamNetworkingMessagesSessionRequest_t [?]"),
	SteamNetworkingMessagesSessionFailed_t = typeof("SteamNetworkingMessagesSessionFailed_t"),
	SteamNetworkingMessagesSessionFailed_t_arr = typeof("SteamNetworkingMessagesSessionFailed_t [?]"),
}

for name, struct in pairs(structs) do
	M[name] = struct
end

--
-- steam client context
--

local client_context_interfaces = {
	"ISteamUser021",
	"ISteamFriends017",
	"ISteamUtils010",
	"ISteamMatchmaking009",
	"ISteamGameSearch001",
	"ISteamUserStats012",
	"ISteamApps008",
	"ISteamMatchmakingServers002",
	"ISteamNetworking006",
	"ISteamRemoteStorage014",
	"ISteamScreenshots003",
	"ISteamHTTP003",
	"ISteamController007",
	"ISteamUGC014",
	"ISteamAppList001",
	"ISteamMusic001",
	"ISteamMusicRemote001",
	"ISteamHTMLSurface005",
	"ISteamInventory003",
	"ISteamVideo002",
	"ISteamParentalSettings001",
	"ISteamInput001"
}

local client_context_raw = cast("uintptr_t**", find_sig(
	"client_panorama.dll",
	"\xB9\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x0F\x84",
	"uintptr_t",
	1, 1
))

local client_context = {}
for i, interface in ipairs(client_context_interfaces) do
	client_context[interface] = client_context_raw[i-1][0]
	client_context[interface:gsub("%d+$", "")] = client_context_raw[i-1][0]
end

--
-- get dll exports
--

local pGetModuleHandle_sig = client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x85\xC0\x74\x0B") or error("Couldn't find signature #1")
local pGetProcAddress_sig = client.find_signature("engine.dll", "\xFF\x15\xCC\xCC\xCC\xCC\xA3\xCC\xCC\xCC\xCC\xEB\x05") or error("Couldn't find signature #2")

local jmp_ecx = client.find_signature("engine.dll", "\xFF\xE1")

local pGetProcAddress = cast("uint32_t**", cast("uint32_t", pGetProcAddress_sig) + 2)[0][0]
local fnGetProcAddress = cast("uint32_t(__fastcall*)(unsigned int, unsigned int, uint32_t, const char*)", jmp_ecx)

local pGetModuleHandle = cast("uint32_t**", cast("uint32_t", pGetModuleHandle_sig) + 2)[0][0]
local fnGetModuleHandle = cast("uint32_t(__fastcall*)(unsigned int, unsigned int, const char*)", jmp_ecx)

local function proc_bind(module_name, function_name, typedef)
	local ctype = typeof(typedef)
	local module_handle = fnGetModuleHandle(pGetModuleHandle, 0, module_name)
	local proc_address = fnGetProcAddress(pGetProcAddress, 0, module_handle, function_name)
	local call_fn = cast(ctype, jmp_ecx)

	return function(...)
		return call_fn(proc_address, 0, ...)
	end
end

--
-- steamworks.await support
--

local AWAIT_DEFAULT_DELAY = 10
local await_mt = {}
await_mt.__call = function(_, delay, fallback)
	if type(delay) == "function" then
		delay, fallback = fallback, delay
	end

	return setmetatable({tonumber(delay) or AWAIT_DEFAULT_DELAY, fallback}, await_mt)
end
M.await = await_mt.__call()

local function is_valid_callback(callback)
	local t = type(callback)

	return t == "function" or (t == "table" and getmetatable(callback) == await_mt)
end

--
-- steam callbacks / callresults
--

local callback_info = {
	[101]={},
	[102]={fields={"m_eResult","m_bStillRetrying"},fields_alt={"result","still_retrying"},types={"int","bool"}},
	[103]={fields={"m_eResult"},fields_alt={"result"},types={"int"}},
	[113]={fields={"m_uAppID","m_unGameServerIP","m_usGameServerPort","m_bSecure","m_uReason"},fields_alt={"appid","game_server_ip","game_server_port","secure","reason"},types={"uint32_t","uint32_t","uint16_t","uint16_t","uint32_t"}},
	[115]={fields={"m_bSecure"},fields_alt={"secure"},types={"bool"}},
	[117]={fields={"m_eFailureType"},fields_alt={"failure_type"},types={"uint8_t"}},
	[125]={},
	[143]={fields={"m_SteamID","m_eAuthSessionResponse","m_OwnerSteamID"},fields_alt={"steamid","auth_session_response","owner_steamid"},types={"SteamID","int","SteamID"}},
	[152]={fields={"m_unAppID","m_ulOrderID","m_bAuthorized"},fields_alt={"appid","order_id","authorized"},types={"uint32_t","uint64_t","bool"}},
	[163]={fields={"m_hAuthTicket","m_eResult"},fields_alt={"auth_ticket","result"},types={"unsigned int","int"}},
	[164]={fields={"m_szURL"},fields_alt={"url"},types={"char [256]"}},
	[201]={fields={"m_SteamID","m_OwnerSteamID"},fields_alt={"steamid","owner_steamid"},types={"SteamID","SteamID"}},
	[202]={fields={"m_SteamID","m_eDenyReason","m_rgchOptionalText"},fields_alt={"steamid","deny_reason","optional_text"},types={"SteamID","int","char [128]"}},
	[203]={fields={"m_SteamID","m_eDenyReason"},fields_alt={"steamid","deny_reason"},types={"SteamID","int"}},
	[206]={fields={"m_SteamID","m_pchAchievement","m_bUnlocked"},fields_alt={"steamid","achievement","unlocked"},types={"SteamID","char [128]","bool"}},
	[207]={fields={"m_eResult","m_nRank","m_unTotalConnects","m_unTotalMinutesPlayed"},fields_alt={"result","rank","total_connects","total_minutes_played"},types={"int","int32_t","uint32_t","uint32_t"}},
	[208]={fields={"m_SteamIDUser","m_SteamIDGroup","m_bMember","m_bOfficer"},fields_alt={"steamid_user","steamid_group","member","officer"},types={"SteamID","SteamID","bool","bool"}},
	[304]={fields={"m_ulSteamID","m_nChangeFlags"},fields_alt={"steamid","change_flags"},types={"SteamID","int"}},
	[331]={fields={"m_bActive"},fields_alt={"active"},types={"bool"}},
	[332]={fields={"m_rgchServer","m_rgchPassword"},fields_alt={"server","password"},types={"char [64]","char [64]"}},
	[333]={fields={"m_steamIDLobby","m_steamIDFriend"},fields_alt={"steamid_lobby","steamid_friend"},types={"SteamID","SteamID"}},
	[334]={fields={"m_steamID","m_iImage","m_iWide","m_iTall"},fields_alt={"steamid","image","wide","tall"},types={"SteamID","int","int","int"}},
	[336]={fields={"m_steamIDFriend","m_nAppID"},fields_alt={"steamid_friend","appid"},types={"SteamID","unsigned int"}},
	[337]={fields={"m_steamIDFriend","m_rgchConnect"},fields_alt={"steamid_friend","connect"},types={"SteamID","char [256]"}},
	[338]={fields={"m_steamIDClanChat","m_steamIDUser","m_iMessageID"},fields_alt={"steamid_clan_chat","steamid_user","message_id"},types={"SteamID","SteamID","int"}},
	[339]={fields={"m_steamIDClanChat","m_steamIDUser"},fields_alt={"steamid_clan_chat","steamid_user"},types={"SteamID","SteamID"}},
	[340]={fields={"m_steamIDClanChat","m_steamIDUser","m_bKicked","m_bDropped"},fields_alt={"steamid_clan_chat","steamid_user","kicked","dropped"},types={"SteamID","SteamID","bool","bool"}},
	[343]={fields={"m_steamIDUser","m_iMessageID"},fields_alt={"steamid_user","message_id"},types={"SteamID","int"}},
	[348]={},
	[349]={fields={"rgchURI"},fields_alt={"uri"},types={"char [1024]"}},
	[502]={fields={"m_nIP","m_nQueryPort","m_nConnPort","m_nAppID","m_nFlags","m_bAdd","m_unAccountId"},fields_alt={"ip","query_port","conn_port","appid","flags","add","account_id"},types={"uint32_t","uint32_t","uint32_t","uint32_t","uint32_t","bool","unsigned int"}},
	[503]={fields={"m_ulSteamIDUser","m_ulSteamIDLobby","m_ulGameID"},fields_alt={"steamid_user","steamid_lobby","game_id"},types={"SteamID","SteamID","uint64_t"}},
	[505]={fields={"m_ulSteamIDLobby","m_ulSteamIDMember","m_bSuccess"},fields_alt={"steamid_lobby","steamid_member","success"},types={"SteamID","SteamID","bool"}},
	[506]={fields={"m_ulSteamIDLobby","m_ulSteamIDUserChanged","m_ulSteamIDMakingChange","m_rgfChatMemberStateChange"},fields_alt={"steamid_lobby","steamid_user_changed","steamid_making_change","chat_member_state_change"},types={"SteamID","SteamID","SteamID","uint32_t"}},
	[507]={fields={"m_ulSteamIDLobby","m_ulSteamIDUser","m_eChatEntryType","m_iChatID"},fields_alt={"steamid_lobby","steamid_user","chat_entry_type","chat_id"},types={"SteamID","SteamID","uint8_t","uint32_t"}},
	[509]={fields={"m_ulSteamIDLobby","m_ulSteamIDGameServer","m_unIP","m_usPort"},fields_alt={"steamid_lobby","steamid_game_server","ip","port"},types={"SteamID","SteamID","uint32_t","uint16_t"}},
	[512]={fields={"m_ulSteamIDLobby","m_ulSteamIDAdmin","m_bKickedDueToDisconnect"},fields_alt={"steamid_lobby","steamid_admin","kicked_due_to_disconnect"},types={"SteamID","SteamID","bool"}},
	[515]={fields={"m_bGameBootInviteExists","m_steamIDLobby"},fields_alt={"game_boot_invite_exists","steamid_lobby"},types={"bool","SteamID"}},
	[516]={fields={"m_eResult"},fields_alt={"result"},types={"int"}},
	[701]={},
	[702]={fields={"m_nMinutesBatteryLeft"},fields_alt={"minutes_battery_left"},types={"uint8_t"}},
	[703]={fields={"m_hAsyncCall","m_iCallback","m_cubParam"},fields_alt={"async_call","callback","param"},types={"uint64_t","int","uint32_t"}},
	[704]={},
	[714]={fields={"m_bSubmitted","m_unSubmittedText"},fields_alt={"submitted","submitted_text"},types={"bool","uint32_t"}},
	[1005]={fields={"m_nAppID"},fields_alt={"appid"},types={"unsigned int"}},
	[1008]={fields={"m_eResult","m_unPackageRegistered"},fields_alt={"result","package_registered"},types={"int","uint32_t"}},
	[1014]={},
	[1021]={fields={"m_eResult","m_nAppID","m_cchKeyLength","m_rgchKey"},fields_alt={"result","appid","key_length","key"},types={"int","uint32_t","uint32_t","char [240]"}},
	[1030]={fields={"m_unAppID","m_bIsOffline","m_unSecondsAllowed","m_unSecondsPlayed"},fields_alt={"appid","is_offline","seconds_allowed","seconds_played"},types={"unsigned int","bool","uint32_t","uint32_t"}},
	[1101]={fields={"m_nGameID","m_eResult","m_steamIDUser"},fields_alt={"game_id","result","steamid_user"},types={"uint64_t","int","SteamID"}},
	[1102]={fields={"m_nGameID","m_eResult"},fields_alt={"game_id","result"},types={"uint64_t","int"}},
	[1103]={fields={"m_nGameID","m_bGroupAchievement","m_rgchAchievementName","m_nCurProgress","m_nMaxProgress"},fields_alt={"game_id","group_achievement","achievement_name","cur_progress","max_progress"},types={"uint64_t","bool","char [128]","uint32_t","uint32_t"}},
	[1108]={fields={"m_steamIDUser"},fields_alt={"steamid_user"},types={"SteamID"}},
	[1109]={fields={"m_nGameID","m_rgchAchievementName","m_bAchieved","m_nIconHandle"},fields_alt={"game_id","achievement_name","achieved","icon_handle"},types={"uint64_t","char [128]","bool","int"}},
	[1112]={fields={"m_nGameID","m_eResult","m_ulRequiredDiskSpace"},fields_alt={"game_id","result","required_disk_space"},types={"uint64_t","int","uint64_t"}},
	[1201]={fields={"m_hSocket","m_hListenSocket","m_steamIDRemote","m_eSNetSocketState"},fields_alt={"socket","listen_socket","steamid_remote","snet_socket_state"},types={"unsigned int","unsigned int","SteamID","int"}},
	[1202]={fields={"m_steamIDRemote"},fields_alt={"steamid_remote"},types={"SteamID"}},
	[1203]={fields={"m_steamIDRemote","m_eP2PSessionError"},fields_alt={"steamid_remote","p2p_session_error"},types={"SteamID","uint8_t"}},
	[1221]={fields={"m_hConn","m_info","m_eOldState"},fields_alt={"conn","info","old_state"},types={"unsigned int","SteamNetConnectionInfo_t","int"}},
	[1222]={fields={"m_eAvail","m_debugMsg"},fields_alt={"avail","debug_msg"},types={"int","char [256]"}},
	[1251]={fields={"m_identityRemote"},fields_alt={"identity_remote"},types={"SteamNetworkingIdentity"}},
	[1252]={fields={"m_info"},fields_alt={"info"},types={"SteamNetConnectionInfo_t"}},
	[1281]={fields={"m_eAvail","m_bPingMeasurementInProgress","m_eAvailNetworkConfig","m_eAvailAnyRelay","m_debugMsg"},fields_alt={"avail","ping_measurement_in_progress","avail_network_config","avail_any_relay","debug_msg"},types={"int","int","int","int","char [256]"}},
	[1301]={fields={"m_nAppID","m_eResult","m_unNumDownloads"},fields_alt={"appid","result","num_downloads"},types={"unsigned int","int","int"}},
	[1302]={fields={"m_nAppID","m_eResult","m_unNumUploads"},fields_alt={"appid","result","num_uploads"},types={"unsigned int","int","int"}},
	[1303]={fields={"m_rgchCurrentFile","m_nAppID","m_uBytesTransferredThisChunk","m_dAppPercentComplete","m_bUploading"},fields_alt={"current_file","appid","bytes_transferred_this_chunk","app_percent_complete","uploading"},types={"char [260]","unsigned int","uint32_t","double","bool"}},
	[1305]={fields={"m_nAppID","m_eResult"},fields_alt={"appid","result"},types={"unsigned int","int"}},
	[1309]={fields={"m_eResult","m_nPublishedFileId","m_bUserNeedsToAcceptWorkshopLegalAgreement"},fields_alt={"result","published_file_id","user_needs_to_accept_workshop_legal_agreement"},types={"int","uint64_t","bool"}},
	[1321]={fields={"m_nPublishedFileId","m_nAppID"},fields_alt={"published_file_id","appid"},types={"uint64_t","unsigned int"}},
	[1322]={fields={"m_nPublishedFileId","m_nAppID"},fields_alt={"published_file_id","appid"},types={"uint64_t","unsigned int"}},
	[1323]={fields={"m_nPublishedFileId","m_nAppID"},fields_alt={"published_file_id","appid"},types={"uint64_t","unsigned int"}},
	[1325]={fields={"m_eResult","m_nPublishedFileId","m_eVote"},fields_alt={"result","published_file_id","vote"},types={"int","uint64_t","int"}},
	[1326]={fields={"m_eResult","m_nResultsReturned","m_nTotalResultCount","m_rgPublishedFileId"},fields_alt={"result","results_returned","total_result_count","published_file_id"},types={"int","int32_t","int32_t","uint64_t [50]"}},
	[1330]={fields={"m_nPublishedFileId","m_nAppID","m_ulUnused"},fields_alt={"published_file_id","appid","unused"},types={"uint64_t","unsigned int","uint64_t"}},
	[2101]={fields={"m_hRequest","m_ulContextValue","m_bRequestSuccessful","m_eStatusCode","m_unBodySize"},fields_alt={"request","context_value","request_successful","status_code","body_size"},types={"unsigned int","uint64_t","bool","int","uint32_t"}},
	[2102]={fields={"m_hRequest","m_ulContextValue"},fields_alt={"request","context_value"},types={"unsigned int","uint64_t"}},
	[2103]={fields={"m_hRequest","m_ulContextValue","m_cOffset","m_cBytesReceived"},fields_alt={"request","context_value","offset","bytes_received"},types={"unsigned int","uint64_t","uint32_t","uint32_t"}},
	[2301]={fields={"m_hLocal","m_eResult"},fields_alt={"local","result"},types={"unsigned int","int"}},
	[2302]={},
	[3405]={fields={"m_unAppID","m_nPublishedFileId"},fields_alt={"appid","published_file_id"},types={"unsigned int","uint64_t"}},
	[3406]={fields={"m_unAppID","m_nPublishedFileId","m_eResult"},fields_alt={"appid","published_file_id","result"},types={"unsigned int","uint64_t","int"}},
	[3901]={fields={"m_nAppID"},fields_alt={"appid"},types={"unsigned int"}},
	[3902]={fields={"m_nAppID"},fields_alt={"appid"},types={"unsigned int"}},
	[4001]={},
	[4002]={fields={"m_flNewVolume"},fields_alt={"new_volume"},types={"float"}},
	[4011]={fields={"m_flNewVolume"},fields_alt={"new_volume"},types={"float"}},
	[4012]={fields={"nID"},fields_alt={"id"},types={"int"}},
	[4013]={fields={"nID"},fields_alt={"id"},types={"int"}},
	[4101]={},
	[4102]={},
	[4103]={},
	[4104]={},
	[4105]={},
	[4106]={},
	[4107]={},
	[4108]={},
	[4109]={fields={"m_bShuffled"},fields_alt={"shuffled"},types={"bool"}},
	[4110]={fields={"m_bLooped"},fields_alt={"looped"},types={"bool"}},
	[4114]={fields={"m_nPlayingRepeatStatus"},fields_alt={"playing_repeat_status"},types={"int"}},
	[4502]={fields={"unBrowserHandle","pBGRA","unWide","unTall","unUpdateX","unUpdateY","unUpdateWide","unUpdateTall","unScrollX","unScrollY","flPageScale","unPageSerial"},fields_alt={"browser_handle","bgra","wide","tall","update_x","update_y","update_wide","update_tall","scroll_x","scroll_y","page_scale","page_serial"},types={"unsigned int","const char *","uint32_t","uint32_t","uint32_t","uint32_t","uint32_t","uint32_t","uint32_t","uint32_t","float","uint32_t"}},
	[4503]={fields={"unBrowserHandle","pchURL","pchTarget","pchPostData","bIsRedirect"},fields_alt={"browser_handle","url","target","post_data","is_redirect"},types={"unsigned int","const char *","const char *","const char *","bool"},string_fields={"pchURL","pchTarget","pchPostData"}},
	[4504]={fields={"unBrowserHandle"},fields_alt={"browser_handle"},types={"unsigned int"}},
	[4505]={fields={"unBrowserHandle","pchURL","pchPostData","bIsRedirect","pchPageTitle","bNewNavigation"},fields_alt={"browser_handle","url","post_data","is_redirect","page_title","new_navigation"},types={"unsigned int","const char *","const char *","bool","const char *","bool"},string_fields={"pchURL","pchPostData","pchPageTitle"}},
	[4506]={fields={"unBrowserHandle","pchURL","pchPageTitle"},fields_alt={"browser_handle","url","page_title"},types={"unsigned int","const char *","const char *"},string_fields={"pchURL","pchPageTitle"}},
	[4507]={fields={"unBrowserHandle","pchURL"},fields_alt={"browser_handle","url"},types={"unsigned int","const char *"},string_fields={"pchURL"}},
	[4508]={fields={"unBrowserHandle","pchTitle"},fields_alt={"browser_handle","title"},types={"unsigned int","const char *"},string_fields={"pchTitle"}},
	[4509]={fields={"unBrowserHandle","unResults","unCurrentMatch"},fields_alt={"browser_handle","results","current_match"},types={"unsigned int","uint32_t","uint32_t"}},
	[4510]={fields={"unBrowserHandle","bCanGoBack","bCanGoForward"},fields_alt={"browser_handle","can_go_back","can_go_forward"},types={"unsigned int","bool","bool"}},
	[4511]={fields={"unBrowserHandle","unScrollMax","unScrollCurrent","flPageScale","bVisible","unPageSize"},fields_alt={"browser_handle","scroll_max","scroll_current","page_scale","visible","page_size"},types={"unsigned int","uint32_t","uint32_t","float","bool","uint32_t"}},
	[4512]={fields={"unBrowserHandle","unScrollMax","unScrollCurrent","flPageScale","bVisible","unPageSize"},fields_alt={"browser_handle","scroll_max","scroll_current","page_scale","visible","page_size"},types={"unsigned int","uint32_t","uint32_t","float","bool","uint32_t"}},
	[4513]={fields={"unBrowserHandle","x","y","pchURL","bInput","bLiveLink"},fields_alt={"browser_handle","x","y","url","input","live_link"},types={"unsigned int","uint32_t","uint32_t","const char *","bool","bool"},string_fields={"pchURL"}},
	[4514]={fields={"unBrowserHandle","pchMessage"},fields_alt={"browser_handle","message"},types={"unsigned int","const char *"},string_fields={"pchMessage"}},
	[4515]={fields={"unBrowserHandle","pchMessage"},fields_alt={"browser_handle","message"},types={"unsigned int","const char *"},string_fields={"pchMessage"}},
	[4516]={fields={"unBrowserHandle","pchTitle","pchInitialFile"},fields_alt={"browser_handle","title","initial_file"},types={"unsigned int","const char *","const char *"},string_fields={"pchTitle","pchInitialFile"}},
	[4521]={fields={"unBrowserHandle","pchURL","unX","unY","unWide","unTall","unNewWindow_BrowserHandle_IGNORE"},fields_alt={"browser_handle","url","x","y","wide","tall","new_window_browser_handle"},types={"unsigned int","const char *","uint32_t","uint32_t","uint32_t","uint32_t","unsigned int"},string_fields={"pchURL"}},
	[4522]={fields={"unBrowserHandle","eMouseCursor"},fields_alt={"browser_handle","mouse_cursor"},types={"unsigned int","uint32_t"}},
	[4523]={fields={"unBrowserHandle","pchMsg"},fields_alt={"browser_handle","msg"},types={"unsigned int","const char *"},string_fields={"pchMsg"}},
	[4524]={fields={"unBrowserHandle","pchMsg"},fields_alt={"browser_handle","msg"},types={"unsigned int","const char *"},string_fields={"pchMsg"}},
	[4525]={fields={"unBrowserHandle","pchMsg"},fields_alt={"browser_handle","msg"},types={"unsigned int","const char *"},string_fields={"pchMsg"}},
	[4526]={fields={"unBrowserHandle"},fields_alt={"browser_handle"},types={"unsigned int"}},
	[4527]={fields={"unBrowserHandle","unOldBrowserHandle"},fields_alt={"browser_handle","old_browser_handle"},types={"unsigned int","unsigned int"}},
	[4611]={fields={"m_eResult","m_unVideoAppID","m_rgchURL"},fields_alt={"result","video_appid","url"},types={"int","unsigned int","char [256]"}},
	[4624]={fields={"m_eResult","m_unVideoAppID"},fields_alt={"result","video_appid"},types={"int","unsigned int"}},
	[4700]={fields={"m_handle","m_result"},fields_alt={"handle","result"},types={"int","int"}},
	[4701]={fields={"m_handle"},fields_alt={"handle"},types={"int"}},
	[4702]={},
	[5001]={},
	[5201]={fields={"m_ullSearchID","m_eResult","m_lobbyID","m_steamIDEndedSearch","m_nSecondsRemainingEstimate","m_cPlayersSearching"},fields_alt={"search_id","result","lobby_id","steamid_ended_search","seconds_remaining_estimate","players_searching"},types={"uint64_t","int","SteamID","SteamID","int32_t","int32_t"}},
	[5202]={fields={"m_ullSearchID","m_eResult","m_nCountPlayersInGame","m_nCountAcceptedGame","m_steamIDHost","m_bFinalCallback"},fields_alt={"search_id","result","count_players_in_game","count_accepted_game","steamid_host","final_callback"},types={"uint64_t","int","int32_t","int32_t","SteamID","bool"}},
	[5211]={fields={"m_eResult","m_ullSearchID"},fields_alt={"result","search_id"},types={"int","uint64_t"}},
	[5212]={fields={"m_eResult","m_ullSearchID","m_SteamIDPlayerFound","m_SteamIDLobby","m_ePlayerAcceptState","m_nPlayerIndex","m_nTotalPlayersFound","m_nTotalPlayersAcceptedGame","m_nSuggestedTeamIndex","m_ullUniqueGameID"},fields_alt={"result","search_id","steamid_player_found","steamid_lobby","player_accept_state","player_index","total_players_found","total_players_accepted_game","suggested_team_index","unique_game_id"},types={"int","uint64_t","SteamID","SteamID","int","int32_t","int32_t","int32_t","int32_t","uint64_t"}},
	[5213]={fields={"m_eResult","m_ullSearchID","m_ullUniqueGameID"},fields_alt={"result","search_id","unique_game_id"},types={"int","uint64_t","uint64_t"}},
	[5214]={fields={"m_eResult","ullUniqueGameID","steamIDPlayer"},fields_alt={"result","unique_game_id","steamid_player"},types={"int","uint64_t","SteamID"}},
	[5215]={fields={"m_eResult","ullUniqueGameID"},fields_alt={"result","unique_game_id"},types={"int","uint64_t"}},
	[5303]={fields={"m_ulBeaconID","m_steamIDJoiner"},fields_alt={"beacon_id","steamid_joiner"},types={"uint64_t","SteamID"}},
	[5305]={},
	[5306]={},
	[5701]={fields={"m_unSessionID"},fields_alt={"session_id"},types={"unsigned int"}},
	[5702]={fields={"m_unSessionID"},fields_alt={"session_id"},types={"unsigned int"}}
}
local callback_name_lookup = {steamserversconnected=101,steamserverconnectfailure=102,steamserversdisconnected=103,clientgameserverdeny=113,ipcfailure=117,licensesupdated=125,validateauthticketresponse=143,microtxnauthorizationresponse=152,getauthsessionticketresponse=163,gamewebcallback=164,personastatechange=304,gameoverlayactivated=331,gameserverchangerequested=332,gamelobbyjoinrequested=333,avatarimageloaded=334,friendrichpresenceupdate=336,gamerichpresencejoinrequested=337,gameconnectedclanchatmsg=338,gameconnectedchatjoin=339,gameconnectedchatleave=340,gameconnectedfriendchatmsg=343,unreadchatmessageschanged=348,overlaybrowserprotocolnavigation=349,ipcountry=701,lowbatterypower=702,steamapicallcompleted=703,steamshutdown=704,gamepadtextinputdismissed=714,favoriteslistchanged=502,lobbyinvite=503,lobbydataupdate=505,lobbychatupdate=506,lobbychatmsg=507,lobbygamecreated=509,lobbykicked=512,psngamebootinviteresult=515,favoriteslistaccountsupdated=516,searchforgameprogresscallback=5201,searchforgameresultcallback=5202,requestplayersforgameprogresscallback=5211,requestplayersforgameresultcallback=5212,requestplayersforgamefinalresultcallback=5213,submitplayerresultresultcallback=5214,endgameresultcallback=5215,reservationnotificationcallback=5303,availablebeaconlocationsupdated=5305,activebeaconsupdated=5306,remotestorageappsyncedclient=1301,remotestorageappsyncedserver=1302,remotestorageappsyncprogress=1303,remotestorageappsyncstatuscheck=1305,remotestoragepublishfileresult=1309,remotestoragepublishedfilesubscribed=1321,remotestoragepublishedfileunsubscribed=1322,remotestoragepublishedfiledeleted=1323,remotestorageuservotedetails=1325,remotestorageenumerateusersharedworkshopfilesresult=1326,remotestoragepublishedfileupdated=1330,userstatsreceived=1101,userstatsstored=1102,userachievementstored=1103,userstatsunloaded=1108,userachievementiconfetched=1109,ps3trophiesinstalled=1112,dlcinstalled=1005,registeractivationcoderesponse=1008,newurllaunchparameters=1014,appproofofpurchasekeyresponse=1021,timedtrialstatus=1030,p2psessionrequest=1202,p2psessionconnectfail=1203,socketstatuscallback=1201,screenshotready=2301,screenshotrequested=2302,playbackstatushaschanged=4001,volumehaschanged=4002,musicplayerremotewillactivate=4101,musicplayerremotewilldeactivate=4102,musicplayerremotetofront=4103,musicplayerwillquit=4104,musicplayerwantsplay=4105,musicplayerwantspause=4106,musicplayerwantsplayprevious=4107,musicplayerwantsplaynext=4108,musicplayerwantsshuffled=4109,musicplayerwantslooped=4110,musicplayerwantsvolume=4011,musicplayerselectsqueueentry=4012,musicplayerselectsplaylistentry=4013,musicplayerwantsplayingrepeatstatus=4114,httprequestcompleted=2101,httprequestheadersreceived=2102,httprequestdatareceived=2103,iteminstalled=3405,downloaditemresult=3406,steamappinstalled=3901,steamappuninstalled=3902,html_needspaint=4502,html_startrequest=4503,html_closebrowser=4504,html_urlchanged=4505,html_finishedrequest=4506,html_openlinkinnewtab=4507,html_changedtitle=4508,html_searchresults=4509,html_cangobackandforward=4510,html_horizontalscroll=4511,html_verticalscroll=4512,html_linkatposition=4513,html_jsalert=4514,html_jsconfirm=4515,html_fileopendialog=4516,html_newwindow=4521,html_setcursor=4522,html_statustext=4523,html_showtooltip=4524,html_updatetooltip=4525,html_hidetooltip=4526,html_browserrestarted=4527,steaminventoryresultready=4700,steaminventoryfullupdate=4701,steaminventorydefinitionupdate=4702,getvideourlresult=4611,getopfsettingsresult=4624,steamparentalsettingschanged=5001,steamremoteplaysessionconnected=5701,steamremoteplaysessiondisconnected=5702,steamnetworkingmessagessessionrequest=1251,steamnetworkingmessagessessionfailed=1252,steamnetconnectionstatuschangedcallback=1221,steamnetauthenticationstatus=1222,steamrelaynetworkstatus=1281,gsclientapprove=201,gsclientdeny=202,gsclientkick=203,gsclientachievementstatus=206,gspolicyresponse=115,gsgameplaystats=207,gsclientgroupstatus=208,gsstatsunloaded=1108}

if not pcall(sizeof, "SteamAPICall_t") then
	cdef([[
		typedef uint64_t SteamAPICall_t;

		struct SteamAPI_callback_base_vtbl {
			void(__thiscall *run1)(struct SteamAPI_callback_base *, void *, bool, uint64_t);
			void(__thiscall *run2)(struct SteamAPI_callback_base *, void *);
			int(__thiscall *get_size)(struct SteamAPI_callback_base *);
		};

		struct SteamAPI_callback_base {
			struct SteamAPI_callback_base_vtbl *vtbl;
			uint8_t flags;
			int id;
			uint64_t api_call_handle;
			struct SteamAPI_callback_base_vtbl vtbl_storage[1];
		};
	]])
end

local ESteamAPICallFailure = enums.ESteamAPICallFailure

local SteamAPI_RegisterCallResult, SteamAPI_UnregisterCallResult
local SteamAPI_RegisterCallback, SteamAPI_UnregisterCallback

-- initialize isteamutils and native_GetAPICallFailureReason
local steamutils = client_context.ISteamUtils
local native_GetAPICallFailureReason = vtable_entry(steamutils, 12, "int(__thiscall*)(void*, SteamAPICall_t)")
local native_IsAPICallCompleted = vtable_entry(steamutils, 11, "bool(__thiscall*)(void*, SteamAPICall_t, bool*)")

local function GetAPICallFailureReason(handle)
	return native_GetAPICallFailureReason(steamutils, handle)
end

local failed_out = bool_arr(1)
local function IsAPICallCompleted(handle)
	local complete = native_IsAPICallCompleted(steamutils, handle, failed_out)

	return complete, failed_out[0]
end

local callback_base        = typeof("struct SteamAPI_callback_base")
local sizeof_callback_base = sizeof(callback_base)
local callback_base_array  = typeof("struct SteamAPI_callback_base[1]")
local callback_base_ptr    = typeof("struct SteamAPI_callback_base*")
local api_call_handlers    = {}
local api_call_info        = {}
local pending_call_results = {}
local registered_callbacks_instances = {}

-- local function render_multiline(x, y, r, g, b, a, flags, max_width, ...)
-- 	local text = table.concat({...})

-- 	local width_max, height = 0, 0
-- 	for line in string.gmatch(text, "([^\n]+)") do
-- 		renderer.text(x, y+height, r, g, b, a, flags, max_width, line)

-- 		local w, h = renderer.measure_text(flags, line)
-- 		width_max = math.max(width_max, w)
-- 		height = height + h
-- 	end

-- 	return width_max, height
-- end

-- local inspect = require "inspect"
-- client.set_event_callback("paint_ui", function()
-- 	render_multiline(150, 150, 255, 255, 255, 255, "", 0, "api_call_handlers: ", inspect(api_call_handlers))
-- 	render_multiline(350, 150, 255, 255, 255, 255, "", 0, "api_call_info: ", inspect(api_call_info))
-- 	render_multiline(550, 150, 255, 255, 255, 255, "", 0, "pending_call_results: ", inspect(pending_call_results))
-- 	render_multiline(750, 150, 255, 255, 255, 255, "", 0, "registered_callbacks_instances: ", inspect(registered_callbacks_instances))
-- end)

local callback_base_error = error_log_prefix("[steamworks] callback failed: ")

local function callback_base_run_common(self, param, io_failure)
	if io_failure then
		io_failure = ESteamAPICallFailure[GetAPICallFailureReason(self.api_call_handle)] or true
	end

	-- prevent SteamAPI_UnregisterCallResult from being called for this callresult
	self.api_call_handle = 0

	local key = pointer_key(self)
	local handler = api_call_handlers[key]

	if handler ~= nil then
		local info = api_call_info[key]
		if info ~= nil then
			if param ~= nil then
				param = cast(info.struct, param)
			end
			local data = struct_to_tbl(param, info.keys, info.string_keys_lookup)

			if io_failure ~= false then
				data.io_failure = io_failure
			end

			xpcall(handler, error_log, data)
		else
			xpcall(handler, error_log, param, io_failure)
		end
	end

	-- clear out data if we're not dealing with a callback
	if pending_call_results[key] ~= nil then
		api_call_handlers[key] = nil
		api_call_info[key] = nil
		pending_call_results[key] = nil
	end
end

local function callback_base_run1(self, param, io_failure, api_call_handle)
	if api_call_handle == self.api_call_handle then
		xpcall(callback_base_run_common, callback_base_error, self, param, io_failure)
	end
end

local function callback_base_run2(self, param)
	xpcall(callback_base_run_common, callback_base_error, self, param, false)
end

local function callback_base_get_size()
	return sizeof_callback_base
end

local function call_result_cancel(self)
	if self.api_call_handle ~= 0 then
		SteamAPI_UnregisterCallResult(self, self.api_call_handle)
		self.api_call_handle = 0

		local key = pointer_key(self)
		api_call_handlers[key] = nil
		api_call_info[key] = nil
		pending_call_results[key] = nil
	end
end

pcall(ffi.metatype, callback_base, {
	__gc = call_result_cancel,
	__index = {
		cancel = call_result_cancel
	}
})

local callback_base_run1_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *, bool, uint64_t)", callback_base_run1)
local callback_base_run2_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *)", callback_base_run2)
local callback_base_get_size_ct = cast("int(__thiscall *)(struct SteamAPI_callback_base *)", callback_base_get_size)

SteamAPI_RegisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xFF\x75\x10", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")
SteamAPI_UnregisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\xFF\x75\x10\xFF\x75\x0C", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")

SteamAPI_RegisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xC7\x05", "void(__cdecl*)(struct SteamAPI_callback_base *, int)")
SteamAPI_UnregisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\xEC\x08\x80\x3D", "void(__cdecl*)(struct SteamAPI_callback_base *)")

local SteamAPI_RunCallbacks = find_sig("steam_api.dll", "\x32\xC9\x83\x3D\xCC\xCC\xCC\xCC\xCC", "void(__cdecl*)(void)")

local function register_call_result(api_call_handle, handler, id, info)
	assert(api_call_handle ~= 0)
	local instance_storage = callback_base_array()
	local instance = cast(callback_base_ptr, instance_storage)

	instance.vtbl_storage[0].run1 = callback_base_run1_ct
	instance.vtbl_storage[0].run2 = callback_base_run2_ct
	instance.vtbl_storage[0].get_size = callback_base_get_size_ct
	instance.vtbl = instance.vtbl_storage
	instance.api_call_handle = api_call_handle
	instance.id = id

	local res, timed_out = api_call_handle, false

	local await = (type(handler) == "table" and getmetatable(handler) == await_mt) and handler or nil
	if await then
		jit.off(true, true)

		-- this will be returned if our callback times out
		res = nil

		-- this will be executed if we time out
		local fallback = type(await[2]) == "function" and await[2] or nil

		handler = function(data)
			if timed_out and fallback ~= nil then
				xpcall(fallback, error_log, data)
			end

			res = data
		end
	end

	local key = pointer_key(instance)
	api_call_handlers[key] = handler
	api_call_info[key] = info
	pending_call_results[key] = instance_storage

	SteamAPI_RegisterCallResult(instance, api_call_handle)

	if await then
		local start = timestamp()
		local timeout = math_min(999, math_max(0, tonumber(await[1]) or AWAIT_DEFAULT_DELAY))
		local timestamp_end = start + timeout

		-- repeatedly call SteamAPI_RunCallbacks until we get our alert (or time out after 10ms)
		while true do
			if res ~= nil or timestamp() > timestamp_end then
				-- print(IsAPICallCompleted(api_call_handle))
				break
			end

			SteamAPI_RunCallbacks()
		end
		timed_out = true
	end

	return res
end

local registered_user_callbacks = {}

local function get_global_callback_handler(id, user_callbacks)
	local info = callback_info[id]
	local string_field_lookup = {}
	local fields = info.fields
	local fields_alt = info.fields_alt
	local fields_kv = {}

	for _, key in ipairs(info.string_fields or {}) do
		string_field_lookup[key] = true
	end

	local struct_text = "struct {"

	for i, key in ipairs(fields) do
		local type_match, arr_match = string_match(info.types[i], "^(.*)(%[.*%])$")

		if type_match ~= nil then
			struct_text = struct_text .. type_match .. " " .. key .. arr_match .. "; "
		else
			struct_text = struct_text .. info.types[i] .. " " .. key .. "; "
		end

		fields_kv[key] = fields_alt[i] or true
	end
	struct_text = struct_text .. "} *"

	local struct = typeof(struct_text)

	return function(param, io_failure)
		if param ~= nil then
			param = cast(struct, param)
		end

		local data = struct_to_tbl(param, fields_kv, string_field_lookup)

		if io_failure ~= false then
			data.io_failure = io_failure
		end

		for _, user_callback in ipairs(user_callbacks) do
			xpcall(user_callback, error_log, data)
		end
	end
end

-- function to set a global callback
local function set_callback(id, callback)
	if type(id) == "string" and callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))] ~= nil then
		id = callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))]
	end

	if callback_info[id] == nil then
		return error("Invalid Steam callback")
	end

	if registered_user_callbacks[id] == nil then
		assert(registered_callbacks_instances[id] == nil)

		-- need to register our global handler for this callback
		registered_user_callbacks[id] = {}

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)

		instance.vtbl_storage[0].run1 = callback_base_run1_ct
		instance.vtbl_storage[0].run2 = callback_base_run2_ct
		instance.vtbl_storage[0].get_size = callback_base_get_size_ct
		instance.vtbl = instance.vtbl_storage
		instance.api_call_handle = 0
		instance.id = id

		local key = pointer_key(instance)
		api_call_handlers[key] = get_global_callback_handler(id, registered_user_callbacks[id])
		registered_callbacks_instances[id] = instance_storage

		SteamAPI_RegisterCallback(instance, id)
	else
		-- dont register same callback twice
		for _, user_callback in ipairs(registered_user_callbacks[id]) do
			if user_callback == callback then
				return false
			end
		end
	end

	table_insert(registered_user_callbacks[id], callback)
	return true
end
M.set_callback = set_callback

local function unset_callback(id, callback)
	if type(id) == "string" and callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))] ~= nil then
		id = callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))]
	end

	if callback_info[id] == nil then
		return error("Invalid Steam callback")
	end

	if registered_user_callbacks[id] == nil then
		return false
	end

	for i, user_callback in ipairs(registered_user_callbacks[id]) do
		if user_callback == callback then
			table_remove(registered_user_callbacks[id], i)
			break
		end
	end

	-- clear our global callback again
	if #registered_user_callbacks[id] == 0 then
		local instance_storage = registered_callbacks_instances[id]
		local instance = cast(callback_base_ptr, instance_storage)
		SteamAPI_UnregisterCallback(instance)

		registered_user_callbacks[id] = nil
		registered_callbacks_instances[id] = nil

		local key = pointer_key(instance)

		api_call_handlers[key] = nil
	end

	return true
end
M.unset_callback = unset_callback

-- function to wait for a callback
function M.await_callback(id, timeout, callback)
	if type(id) == "string" and callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))] ~= nil then
		id = callback_name_lookup[string_lower(string_gsub(id, "_t$", ""))]
	end

	if callback_info[id] == nil then
		return error("Invalid Steam callback")
	end

	-- register callback if its passed
	local registered = false
	if callback ~= nil then
		registered = set_callback(id, callback)
	end

	-- wait for callback to be called

	-- if the callback was successfully registered (so not already registered) then unregister it
	if registered then
		unset_callback(id, callback)
	end
end

--
-- utility functions for "user created interfaces"
--

local function get_user_interface_callback_handler(user_callbacks)
	return function(instance, ...)
		local user_callback = user_callbacks[pointer_key(instance)]
		if user_callback ~= nil then
			xpcall(user_callback, error_log, instance, ...)
		end
	end
end

--
-- random other utilities
--

local function to_steamid_required(steamid, err_text)
	return to_steamid(steamid) or error(err_text, 3)
end

local function to_enum(int_or_string, enum)
	local t = type(int_or_string)

	if t == "number" or t == "string" then
		local e = enum[int_or_string]

		if e ~= nil then
			return t == "string" and e or int_or_string
		end
	end
end

local function to_enum_required(int_or_string, enum, err_text)
	return to_enum(int_or_string, enum) or error(err_text, 3)
end

local function ipv4_int_to_string(ip)
	local buf = uint32_t_arr(1, ip)
	local strbuf = cast(uint8_t_ptr, buf)

	return string_format("%d.%d.%d.%d", strbuf[3], strbuf[2], strbuf[1], strbuf[0])
end

local function ipv4_string_to_int(ip)
	local a, b, c, d = string_match(ip, "^(%d+)%.(%d+)%.(%d+)%.(%d+)$")

	if a ~= nil then
		local buf = uint8_t_arr(4, tonumber(d), tonumber(c), tonumber(b), tonumber(a))

		return cast(uint32_t_ptr, buf)[0]
	end
end

local function to_ip_int_required(ip, err_text)
	local t = type(ip)

	if t == "number" then
		return ip
	elseif t == "string" then
		return ipv4_string_to_int(ip) or error(err_text, 3)
	end

	error(err_text, 3)
end

M.SteamID = to_steamid
M.CSteamID = to_steamid
M.ipv4_parse = ipv4_string_to_int
M.ipv4_tostring = ipv4_int_to_string

--
-- out types for interfaces
--

local new_FriendGameInfo_arr = typeof("FriendGameInfo_t [1]")
local new_SteamID_arr = typeof("SteamID [1]")
local new_bool_arr = typeof("bool [1]")
local new_double_arr = typeof("double [1]")
local new_float_arr = typeof("float [1]")
local new_int32_arr = typeof("int32_t [1]")
local new_int64_arr = typeof("int64_t [1]")
local new_int_arr = typeof("int [1]")
local new_uint16_arr = typeof("uint16_t [1]")
local new_uint32_arr = typeof("uint32_t [1]")
local new_uint64_arr = typeof("uint64_t [1]")
local new_unsigned_int_arr = typeof("unsigned int [1]")

--
-- all interfaces
--

-- this shit takes a few hundred ms for some reason?
-- local native_ConnectToGlobalUser = vtable_bind("steamclient.dll", "SteamClient020", 2, "int(__thiscall*)(void*, int)")
-- local hSteamUser = native_ConnectToGlobalUser(hSteamPipe)

local imports_match = cast("char*", find_signature("client.dll", "\xFF\x15\xCC\xCC\xCC\xCC\x8B\xD8\xFF\x15") or error("Invalid SteamAPI_GetHSteamUser signature"))

local SteamAPI_GetHSteamUser = cast("int(__cdecl***)()", imports_match + 2)[0][0]
local SteamAPI_GetHSteamPipe = cast("int(__cdecl***)()", imports_match + 10)[0][0]

local hSteamPipe = SteamAPI_GetHSteamPipe()
local hSteamUser = SteamAPI_GetHSteamUser()

--
-- ISteamUser (SteamUser021, user created: false)
--

local ISteamUser = {version="SteamUser021",version_number=21}

index_funcs.ISteamUser = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 5, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamUser021")

	local GetHSteamUser_native = vtable_entry(this, 0, "int(__thiscall*)(void*)")
	function ISteamUser.GetHSteamUser()
		return GetHSteamUser_native(this)
	end
	ISteamUser.get_hsteamuser = ISteamUser.GetHSteamUser

	local BLoggedOn_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamUser.BLoggedOn()
		return BLoggedOn_native(this)
	end
	ISteamUser.logged_on = ISteamUser.BLoggedOn

	local GetSteamID_native = vtable_entry(this, 2, "void(__thiscall*)(void*, SteamID *)")
	function ISteamUser.GetSteamID()
		local CSteamID_out = new_SteamID_arr()
		GetSteamID_native(this, CSteamID_out)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamUser.get_steamid = ISteamUser.GetSteamID

	local InitiateGameConnection_native = vtable_entry(this, 3, "int(__thiscall*)(void*, void *, int, SteamID, uint32_t, uint16_t, bool)")
	function ISteamUser.InitiateGameConnection(pAuthBlob, cbMaxAuthBlob, steamIDGameServer, unIPServer, usPortServer, bSecure)
		steamIDGameServer = to_steamid_required(steamIDGameServer, "steamid_game_server is required")
		unIPServer = to_ip_int_required(unIPServer, "ip_server is required")
		return InitiateGameConnection_native(this, pAuthBlob, cbMaxAuthBlob, steamIDGameServer, unIPServer, usPortServer, bSecure)
	end
	ISteamUser.initiate_game_connection = ISteamUser.InitiateGameConnection

	local TerminateGameConnection_native = vtable_entry(this, 4, "void(__thiscall*)(void*, uint32_t, uint16_t)")
	function ISteamUser.TerminateGameConnection(unIPServer, usPortServer)
		unIPServer = to_ip_int_required(unIPServer, "ip_server is required")
		return TerminateGameConnection_native(this, unIPServer, usPortServer)
	end
	ISteamUser.terminate_game_connection = ISteamUser.TerminateGameConnection

	local TrackAppUsageEvent_native = vtable_entry(this, 5, "void(__thiscall*)(void*, uint64_t, int, const char *)")
	function ISteamUser.TrackAppUsageEvent(gameID, eAppUsageEvent, pchExtraInfo)
		return TrackAppUsageEvent_native(this, gameID, eAppUsageEvent, pchExtraInfo)
	end
	ISteamUser.track_app_usage_event = ISteamUser.TrackAppUsageEvent

	local GetUserDataFolder_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, char *, int)")
	function ISteamUser.GetUserDataFolder(pchBuffer, cubBuffer)
		return GetUserDataFolder_native(this, pchBuffer, cubBuffer)
	end
	ISteamUser.get_user_data_folder = ISteamUser.GetUserDataFolder

	local StartVoiceRecording_native = vtable_entry(this, 7, "void(__thiscall*)(void*)")
	function ISteamUser.StartVoiceRecording()
		return StartVoiceRecording_native(this)
	end
	ISteamUser.start_voice_recording = ISteamUser.StartVoiceRecording

	local StopVoiceRecording_native = vtable_entry(this, 8, "void(__thiscall*)(void*)")
	function ISteamUser.StopVoiceRecording()
		return StopVoiceRecording_native(this)
	end
	ISteamUser.stop_voice_recording = ISteamUser.StopVoiceRecording

	local GetAvailableVoice_native = vtable_entry(this, 9, "int(__thiscall*)(void*, uint32_t *, uint32_t *, uint32_t)")
	function ISteamUser.GetAvailableVoice(pcbUncompressed_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated)
		local pcbCompressed_out = new_uint32_arr()
		local res = GetAvailableVoice_native(this, pcbCompressed_out, pcbUncompressed_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated)

		return res, DEREF_GCSAFE(pcbCompressed_out)
	end
	ISteamUser.get_available_voice = ISteamUser.GetAvailableVoice

	local GetVoice_native = vtable_entry(this, 10, "int(__thiscall*)(void*, bool, void *, uint32_t, uint32_t *, bool, void *, uint32_t, uint32_t *, uint32_t)")
	function ISteamUser.GetVoice(bWantCompressed, pDestBuffer, cbDestBufferSize, bWantUncompressed_Deprecated, pUncompressedDestBuffer_Deprecated, cbUncompressedDestBufferSize_Deprecated, nUncompressBytesWritten_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated)
		local nBytesWritten_out = new_uint32_arr()
		local res = GetVoice_native(this, bWantCompressed, pDestBuffer, cbDestBufferSize, nBytesWritten_out, bWantUncompressed_Deprecated, pUncompressedDestBuffer_Deprecated, cbUncompressedDestBufferSize_Deprecated, nUncompressBytesWritten_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated)

		return res, DEREF_GCSAFE(nBytesWritten_out)
	end
	ISteamUser.get_voice = ISteamUser.GetVoice

	local DecompressVoice_native = vtable_entry(this, 11, "int(__thiscall*)(void*, const void *, uint32_t, void *, uint32_t, uint32_t *, uint32_t)")
	function ISteamUser.DecompressVoice(pCompressed, cbCompressed, pDestBuffer, cbDestBufferSize, nDesiredSampleRate)
		local nBytesWritten_out = new_uint32_arr()
		local res = DecompressVoice_native(this, pCompressed, cbCompressed, pDestBuffer, cbDestBufferSize, nBytesWritten_out, nDesiredSampleRate)

		return res, DEREF_GCSAFE(nBytesWritten_out)
	end
	ISteamUser.decompress_voice = ISteamUser.DecompressVoice

	local GetVoiceOptimalSampleRate_native = vtable_entry(this, 12, "uint32_t(__thiscall*)(void*)")
	function ISteamUser.GetVoiceOptimalSampleRate()
		return GetVoiceOptimalSampleRate_native(this)
	end
	ISteamUser.get_voice_optimal_sample_rate = ISteamUser.GetVoiceOptimalSampleRate

	local GetAuthSessionTicket_native = vtable_entry(this, 13, "unsigned int(__thiscall*)(void*, void *, int, uint32_t *)")
	function ISteamUser.GetAuthSessionTicket(pTicket, cbMaxTicket)
		local pcbTicket_out = new_uint32_arr()
		local res = GetAuthSessionTicket_native(this, pTicket, cbMaxTicket, pcbTicket_out)

		return res, DEREF_GCSAFE(pcbTicket_out)
	end
	ISteamUser.get_auth_session_ticket = ISteamUser.GetAuthSessionTicket

	local BeginAuthSession_native = vtable_entry(this, 14, "int(__thiscall*)(void*, const void *, int, SteamID)")
	function ISteamUser.BeginAuthSession(pAuthTicket, cbAuthTicket, steamID)
		steamID = to_steamid_required(steamID, "steamid is required")
		return BeginAuthSession_native(this, pAuthTicket, cbAuthTicket, steamID)
	end
	ISteamUser.begin_auth_session = ISteamUser.BeginAuthSession

	local EndAuthSession_native = vtable_entry(this, 15, "void(__thiscall*)(void*, SteamID)")
	function ISteamUser.EndAuthSession(steamID)
		steamID = to_steamid_required(steamID, "steamid is required")
		return EndAuthSession_native(this, steamID)
	end
	ISteamUser.end_auth_session = ISteamUser.EndAuthSession

	local CancelAuthTicket_native = vtable_entry(this, 16, "void(__thiscall*)(void*, unsigned int)")
	function ISteamUser.CancelAuthTicket(hAuthTicket)
		return CancelAuthTicket_native(this, hAuthTicket)
	end
	ISteamUser.cancel_auth_ticket = ISteamUser.CancelAuthTicket

	local UserHasLicenseForApp_native = vtable_entry(this, 17, "int(__thiscall*)(void*, SteamID, unsigned int)")
	function ISteamUser.UserHasLicenseForApp(steamID, appID)
		steamID = to_steamid_required(steamID, "steamid is required")
		return UserHasLicenseForApp_native(this, steamID, appID)
	end
	ISteamUser.user_has_license_for_app = ISteamUser.UserHasLicenseForApp

	local BIsBehindNAT_native = vtable_entry(this, 18, "bool(__thiscall*)(void*)")
	function ISteamUser.BIsBehindNAT()
		return BIsBehindNAT_native(this)
	end
	ISteamUser.is_behind_nat = ISteamUser.BIsBehindNAT

	local AdvertiseGame_native = vtable_entry(this, 19, "void(__thiscall*)(void*, SteamID, uint32_t, uint16_t)")
	function ISteamUser.AdvertiseGame(steamIDGameServer, unIPServer, usPortServer)
		steamIDGameServer = to_steamid_required(steamIDGameServer, "steamid_game_server is required")
		unIPServer = to_ip_int_required(unIPServer, "ip_server is required")
		return AdvertiseGame_native(this, steamIDGameServer, unIPServer, usPortServer)
	end
	ISteamUser.advertise_game = ISteamUser.AdvertiseGame

	local RequestEncryptedAppTicket_native = vtable_entry(this, 20, "uint64_t(__thiscall*)(void*, void *, int)")
	local RequestEncryptedAppTicket_info = {
		struct = typeof([[
			struct {
				int m_eResult;
			} *
		]]),
		keys = {m_eResult="result"}
	}
	function ISteamUser.RequestEncryptedAppTicket(pDataToInclude, cbDataToInclude, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestEncryptedAppTicket_native(this, pDataToInclude, cbDataToInclude)

		if callback ~= nil then
			res = register_call_result(res, callback, 154, RequestEncryptedAppTicket_info)
		end

		return res
	end
	ISteamUser.request_encrypted_app_ticket = ISteamUser.RequestEncryptedAppTicket

	local GetEncryptedAppTicket_native = vtable_entry(this, 21, "bool(__thiscall*)(void*, void *, int, uint32_t *)")
	function ISteamUser.GetEncryptedAppTicket(pTicket, cbMaxTicket)
		local pcbTicket_out = new_uint32_arr()
		local res = GetEncryptedAppTicket_native(this, pTicket, cbMaxTicket, pcbTicket_out)

		return res, DEREF_GCSAFE(pcbTicket_out)
	end
	ISteamUser.get_encrypted_app_ticket = ISteamUser.GetEncryptedAppTicket

	local GetGameBadgeLevel_native = vtable_entry(this, 22, "int(__thiscall*)(void*, int, bool)")
	function ISteamUser.GetGameBadgeLevel(nSeries, bFoil)
		return GetGameBadgeLevel_native(this, nSeries, bFoil)
	end
	ISteamUser.get_game_badge_level = ISteamUser.GetGameBadgeLevel

	local GetPlayerSteamLevel_native = vtable_entry(this, 23, "int(__thiscall*)(void*)")
	function ISteamUser.GetPlayerSteamLevel()
		return GetPlayerSteamLevel_native(this)
	end
	ISteamUser.get_player_steam_level = ISteamUser.GetPlayerSteamLevel

	local RequestStoreAuthURL_native = vtable_entry(this, 24, "uint64_t(__thiscall*)(void*, const char *)")
	local RequestStoreAuthURL_info = {
		struct = typeof([[
			struct {
				char m_szURL[512];
			} *
		]]),
		keys = {m_szURL="url"}
	}
	function ISteamUser.RequestStoreAuthURL(pchRedirectURL, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestStoreAuthURL_native(this, pchRedirectURL)

		if callback ~= nil then
			res = register_call_result(res, callback, 165, RequestStoreAuthURL_info)
		end

		return res
	end
	ISteamUser.request_store_auth_url = ISteamUser.RequestStoreAuthURL

	local BIsPhoneVerified_native = vtable_entry(this, 25, "bool(__thiscall*)(void*)")
	function ISteamUser.BIsPhoneVerified()
		return BIsPhoneVerified_native(this)
	end
	ISteamUser.is_phone_verified = ISteamUser.BIsPhoneVerified

	local BIsTwoFactorEnabled_native = vtable_entry(this, 26, "bool(__thiscall*)(void*)")
	function ISteamUser.BIsTwoFactorEnabled()
		return BIsTwoFactorEnabled_native(this)
	end
	ISteamUser.is_two_factor_enabled = ISteamUser.BIsTwoFactorEnabled

	local BIsPhoneIdentifying_native = vtable_entry(this, 27, "bool(__thiscall*)(void*)")
	function ISteamUser.BIsPhoneIdentifying()
		return BIsPhoneIdentifying_native(this)
	end
	ISteamUser.is_phone_identifying = ISteamUser.BIsPhoneIdentifying

	local BIsPhoneRequiringVerification_native = vtable_entry(this, 28, "bool(__thiscall*)(void*)")
	function ISteamUser.BIsPhoneRequiringVerification()
		return BIsPhoneRequiringVerification_native(this)
	end
	ISteamUser.is_phone_requiring_verification = ISteamUser.BIsPhoneRequiringVerification

	local GetMarketEligibility_native = vtable_entry(this, 29, "uint64_t(__thiscall*)(void*)")
	local GetMarketEligibility_info = {
		struct = typeof([[
			struct {
				bool m_bAllowed;
				int m_eNotAllowedReason;
				unsigned int m_rtAllowedAtTime;
				int m_cdaySteamGuardRequiredDays;
				int m_cdayNewDeviceCooldown;
			} *
		]]),
		keys = {m_bAllowed="allowed",m_eNotAllowedReason="not_allowed_reason",m_rtAllowedAtTime="allowed_at_time",m_cdaySteamGuardRequiredDays="steam_guard_required_days",m_cdayNewDeviceCooldown="new_device_cooldown"}
	}
	function ISteamUser.GetMarketEligibility(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = GetMarketEligibility_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 166, GetMarketEligibility_info)
		end

		return res
	end
	ISteamUser.get_market_eligibility = ISteamUser.GetMarketEligibility

	local GetDurationControl_native = vtable_entry(this, 30, "uint64_t(__thiscall*)(void*)")
	local GetDurationControl_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				unsigned int m_appid;
				bool m_bApplicable;
				int32_t m_csecsLast5h;
				int m_progress;
				int m_notification;
				int32_t m_csecsToday;
				int32_t m_csecsRemaining;
			} *
		]]),
		keys = {m_eResult="result",m_appid="appid",m_bApplicable="applicable",m_csecsLast5h="last5h",m_progress="progress",m_notification="notification",m_csecsToday="today",m_csecsRemaining="remaining"}
	}
	function ISteamUser.GetDurationControl(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = GetDurationControl_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 167, GetDurationControl_info)
		end

		return res
	end
	ISteamUser.get_duration_control = ISteamUser.GetDurationControl

	local BSetDurationControlOnlineState_native = vtable_entry(this, 31, "bool(__thiscall*)(void*, int)")
	function ISteamUser.BSetDurationControlOnlineState(eNewState)
		eNewState = to_enum_required(eNewState, enums.EDurationControlOnlineState, "new_state is required")
		return BSetDurationControlOnlineState_native(this, eNewState)
	end
	ISteamUser.set_duration_control_online_state = ISteamUser.BSetDurationControlOnlineState

	return ISteamUser
end

--
-- ISteamFriends (SteamFriends017, user created: false)
--

local ISteamFriends = {version="SteamFriends017",version_number=17}

index_funcs.ISteamFriends = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 8, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamFriends017")

	local GetPersonaName_native = vtable_entry(this, 0, "const char *(__thiscall*)(void*)")
	function ISteamFriends.GetPersonaName()
		local res = GetPersonaName_native(this)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_persona_name = ISteamFriends.GetPersonaName

	local SetPersonaName_native = vtable_entry(this, 1, "uint64_t(__thiscall*)(void*, const char *)")
	local SetPersonaName_info = {
		struct = typeof([[
			struct {
				bool m_bSuccess;
				bool m_bLocalSuccess;
				int m_result;
			} *
		]]),
		keys = {m_bSuccess="success",m_bLocalSuccess="local_success",m_result="result"}
	}
	function ISteamFriends.SetPersonaName(pchPersonaName, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = SetPersonaName_native(this, pchPersonaName)

		if callback ~= nil then
			res = register_call_result(res, callback, 347, SetPersonaName_info)
		end

		return res
	end
	ISteamFriends.set_persona_name = ISteamFriends.SetPersonaName

	local GetPersonaState_native = vtable_entry(this, 2, "int(__thiscall*)(void*)")
	function ISteamFriends.GetPersonaState()
		return GetPersonaState_native(this)
	end
	ISteamFriends.get_persona_state = ISteamFriends.GetPersonaState

	local GetFriendCount_native = vtable_entry(this, 3, "int(__thiscall*)(void*, int)")
	function ISteamFriends.GetFriendCount(iFriendFlags)
		iFriendFlags = to_enum_required(iFriendFlags, enums.EFriendFlags, "friend_flags is required")
		return GetFriendCount_native(this, iFriendFlags)
	end
	ISteamFriends.get_friend_count = ISteamFriends.GetFriendCount

	local GetFriendByIndex_native = vtable_entry(this, 4, "void(__thiscall*)(void*, SteamID *, int, int)")
	function ISteamFriends.GetFriendByIndex(iFriend, iFriendFlags)
		iFriendFlags = to_enum_required(iFriendFlags, enums.EFriendFlags, "friend_flags is required")
		local CSteamID_out = new_SteamID_arr()
		GetFriendByIndex_native(this, CSteamID_out, iFriend, iFriendFlags)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_friend_by_index = ISteamFriends.GetFriendByIndex

	local GetFriendRelationship_native = vtable_entry(this, 5, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendRelationship(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendRelationship_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_relationship = ISteamFriends.GetFriendRelationship

	local GetFriendPersonaState_native = vtable_entry(this, 6, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendPersonaState(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendPersonaState_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_persona_state = ISteamFriends.GetFriendPersonaState

	local GetFriendPersonaName_native = vtable_entry(this, 7, "const char *(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendPersonaName(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local res = GetFriendPersonaName_native(this, steamIDFriend)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_friend_persona_name = ISteamFriends.GetFriendPersonaName

	local GetFriendGamePlayed_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, SteamID, FriendGameInfo_t *)")
	function ISteamFriends.GetFriendGamePlayed(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local pFriendGameInfo_out = new_FriendGameInfo_arr()
		local res = GetFriendGamePlayed_native(this, steamIDFriend, pFriendGameInfo_out)

		return res, DEREF_GCSAFE(pFriendGameInfo_out)
	end
	ISteamFriends.get_friend_game_played = ISteamFriends.GetFriendGamePlayed

	local GetFriendPersonaNameHistory_native = vtable_entry(this, 9, "const char *(__thiscall*)(void*, SteamID, int)")
	function ISteamFriends.GetFriendPersonaNameHistory(steamIDFriend, iPersonaName)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local res = GetFriendPersonaNameHistory_native(this, steamIDFriend, iPersonaName)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_friend_persona_name_history = ISteamFriends.GetFriendPersonaNameHistory

	local GetFriendSteamLevel_native = vtable_entry(this, 10, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendSteamLevel(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendSteamLevel_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_steam_level = ISteamFriends.GetFriendSteamLevel

	local GetPlayerNickname_native = vtable_entry(this, 11, "const char *(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetPlayerNickname(steamIDPlayer)
		steamIDPlayer = to_steamid_required(steamIDPlayer, "steamid_player is required")
		local res = GetPlayerNickname_native(this, steamIDPlayer)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_player_nickname = ISteamFriends.GetPlayerNickname

	local GetFriendsGroupCount_native = vtable_entry(this, 12, "int(__thiscall*)(void*)")
	function ISteamFriends.GetFriendsGroupCount()
		return GetFriendsGroupCount_native(this)
	end
	ISteamFriends.get_friends_group_count = ISteamFriends.GetFriendsGroupCount

	local GetFriendsGroupIDByIndex_native = vtable_entry(this, 13, "short(__thiscall*)(void*, int)")
	function ISteamFriends.GetFriendsGroupIDByIndex(iFG)
		return GetFriendsGroupIDByIndex_native(this, iFG)
	end
	ISteamFriends.get_friends_group_id_by_index = ISteamFriends.GetFriendsGroupIDByIndex

	local GetFriendsGroupName_native = vtable_entry(this, 14, "const char *(__thiscall*)(void*, short)")
	function ISteamFriends.GetFriendsGroupName(friendsGroupID)
		local res = GetFriendsGroupName_native(this, friendsGroupID)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_friends_group_name = ISteamFriends.GetFriendsGroupName

	local GetFriendsGroupMembersCount_native = vtable_entry(this, 15, "int(__thiscall*)(void*, short)")
	function ISteamFriends.GetFriendsGroupMembersCount(friendsGroupID)
		return GetFriendsGroupMembersCount_native(this, friendsGroupID)
	end
	ISteamFriends.get_friends_group_members_count = ISteamFriends.GetFriendsGroupMembersCount

	local GetFriendsGroupMembersList_native = vtable_entry(this, 16, "void(__thiscall*)(void*, short, SteamID *, int)")
	function ISteamFriends.GetFriendsGroupMembersList(friendsGroupID, pOutSteamIDMembers, nMembersCount)
		return GetFriendsGroupMembersList_native(this, friendsGroupID, pOutSteamIDMembers, nMembersCount)
	end
	ISteamFriends.get_friends_group_members_list = ISteamFriends.GetFriendsGroupMembersList

	local HasFriend_native = vtable_entry(this, 17, "bool(__thiscall*)(void*, SteamID, int)")
	function ISteamFriends.HasFriend(steamIDFriend, iFriendFlags)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		iFriendFlags = to_enum_required(iFriendFlags, enums.EFriendFlags, "friend_flags is required")
		return HasFriend_native(this, steamIDFriend, iFriendFlags)
	end
	ISteamFriends.has_friend = ISteamFriends.HasFriend

	local GetClanCount_native = vtable_entry(this, 18, "int(__thiscall*)(void*)")
	function ISteamFriends.GetClanCount()
		return GetClanCount_native(this)
	end
	ISteamFriends.get_clan_count = ISteamFriends.GetClanCount

	local GetClanByIndex_native = vtable_entry(this, 19, "void(__thiscall*)(void*, SteamID *, int)")
	function ISteamFriends.GetClanByIndex(iClan)
		local CSteamID_out = new_SteamID_arr()
		GetClanByIndex_native(this, CSteamID_out, iClan)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_clan_by_index = ISteamFriends.GetClanByIndex

	local GetClanName_native = vtable_entry(this, 20, "const char *(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetClanName(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local res = GetClanName_native(this, steamIDClan)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_clan_name = ISteamFriends.GetClanName

	local GetClanTag_native = vtable_entry(this, 21, "const char *(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetClanTag(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local res = GetClanTag_native(this, steamIDClan)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_clan_tag = ISteamFriends.GetClanTag

	local GetClanActivityCounts_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, SteamID, int *, int *, int *)")
	function ISteamFriends.GetClanActivityCounts(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local pnOnline_out = new_int_arr()
		local pnInGame_out = new_int_arr()
		local pnChatting_out = new_int_arr()
		local res = GetClanActivityCounts_native(this, steamIDClan, pnOnline_out, pnInGame_out, pnChatting_out)

		return res, DEREF_GCSAFE(pnOnline_out), DEREF_GCSAFE(pnInGame_out), DEREF_GCSAFE(pnChatting_out)
	end
	ISteamFriends.get_clan_activity_counts = ISteamFriends.GetClanActivityCounts

	local DownloadClanActivityCounts_native = vtable_entry(this, 23, "uint64_t(__thiscall*)(void*, SteamID *, int)")
	local DownloadClanActivityCounts_info = {
		struct = typeof([[
			struct {
				bool m_bSuccess;
			} *
		]]),
		keys = {m_bSuccess="success"}
	}
	function ISteamFriends.DownloadClanActivityCounts(psteamIDClans, cClansToRequest, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = DownloadClanActivityCounts_native(this, psteamIDClans, cClansToRequest)

		if callback ~= nil then
			res = register_call_result(res, callback, 341, DownloadClanActivityCounts_info)
		end

		return res
	end
	ISteamFriends.download_clan_activity_counts = ISteamFriends.DownloadClanActivityCounts

	local GetFriendCountFromSource_native = vtable_entry(this, 24, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendCountFromSource(steamIDSource)
		steamIDSource = to_steamid_required(steamIDSource, "steamid_source is required")
		return GetFriendCountFromSource_native(this, steamIDSource)
	end
	ISteamFriends.get_friend_count_from_source = ISteamFriends.GetFriendCountFromSource

	local GetFriendFromSourceByIndex_native = vtable_entry(this, 25, "void(__thiscall*)(void*, SteamID *, SteamID, int)")
	function ISteamFriends.GetFriendFromSourceByIndex(steamIDSource, iFriend)
		steamIDSource = to_steamid_required(steamIDSource, "steamid_source is required")
		local CSteamID_out = new_SteamID_arr()
		GetFriendFromSourceByIndex_native(this, CSteamID_out, steamIDSource, iFriend)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_friend_from_source_by_index = ISteamFriends.GetFriendFromSourceByIndex

	local IsUserInSource_native = vtable_entry(this, 26, "bool(__thiscall*)(void*, SteamID, SteamID)")
	function ISteamFriends.IsUserInSource(steamIDUser, steamIDSource)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		steamIDSource = to_steamid_required(steamIDSource, "steamid_source is required")
		return IsUserInSource_native(this, steamIDUser, steamIDSource)
	end
	ISteamFriends.is_user_in_source = ISteamFriends.IsUserInSource

	local SetInGameVoiceSpeaking_native = vtable_entry(this, 27, "void(__thiscall*)(void*, SteamID, bool)")
	function ISteamFriends.SetInGameVoiceSpeaking(steamIDUser, bSpeaking)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return SetInGameVoiceSpeaking_native(this, steamIDUser, bSpeaking)
	end
	ISteamFriends.set_in_game_voice_speaking = ISteamFriends.SetInGameVoiceSpeaking

	local ActivateGameOverlay_native = vtable_entry(this, 28, "void(__thiscall*)(void*, const char *)")
	function ISteamFriends.ActivateGameOverlay(pchDialog)
		return ActivateGameOverlay_native(this, pchDialog)
	end
	ISteamFriends.activate_game_overlay = ISteamFriends.ActivateGameOverlay

	local ActivateGameOverlayToUser_native = vtable_entry(this, 29, "void(__thiscall*)(void*, const char *, SteamID)")
	function ISteamFriends.ActivateGameOverlayToUser(pchDialog, steamID)
		steamID = to_steamid_required(steamID, "steamid is required")
		return ActivateGameOverlayToUser_native(this, pchDialog, steamID)
	end
	ISteamFriends.activate_game_overlay_to_user = ISteamFriends.ActivateGameOverlayToUser

	local ActivateGameOverlayToWebPage_native = vtable_entry(this, 30, "void(__thiscall*)(void*, const char *, int)")
	function ISteamFriends.ActivateGameOverlayToWebPage(pchURL, eMode)
		eMode = to_enum_required(eMode, enums.EActivateGameOverlayToWebPageMode, "mode is required")
		return ActivateGameOverlayToWebPage_native(this, pchURL, eMode)
	end
	ISteamFriends.activate_game_overlay_to_web_page = ISteamFriends.ActivateGameOverlayToWebPage

	local ActivateGameOverlayToStore_native = vtable_entry(this, 31, "void(__thiscall*)(void*, unsigned int, int)")
	function ISteamFriends.ActivateGameOverlayToStore(nAppID, eFlag)
		eFlag = to_enum_required(eFlag, enums.EOverlayToStoreFlag, "flag is required")
		return ActivateGameOverlayToStore_native(this, nAppID, eFlag)
	end
	ISteamFriends.activate_game_overlay_to_store = ISteamFriends.ActivateGameOverlayToStore

	local SetPlayedWith_native = vtable_entry(this, 32, "void(__thiscall*)(void*, SteamID)")
	function ISteamFriends.SetPlayedWith(steamIDUserPlayedWith)
		steamIDUserPlayedWith = to_steamid_required(steamIDUserPlayedWith, "steamid_user_played_with is required")
		return SetPlayedWith_native(this, steamIDUserPlayedWith)
	end
	ISteamFriends.set_played_with = ISteamFriends.SetPlayedWith

	local ActivateGameOverlayInviteDialog_native = vtable_entry(this, 33, "void(__thiscall*)(void*, SteamID)")
	function ISteamFriends.ActivateGameOverlayInviteDialog(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return ActivateGameOverlayInviteDialog_native(this, steamIDLobby)
	end
	ISteamFriends.activate_game_overlay_invite_dialog = ISteamFriends.ActivateGameOverlayInviteDialog

	local GetSmallFriendAvatar_native = vtable_entry(this, 34, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetSmallFriendAvatar(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetSmallFriendAvatar_native(this, steamIDFriend)
	end
	ISteamFriends.get_small_friend_avatar = ISteamFriends.GetSmallFriendAvatar

	local GetMediumFriendAvatar_native = vtable_entry(this, 35, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetMediumFriendAvatar(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetMediumFriendAvatar_native(this, steamIDFriend)
	end
	ISteamFriends.get_medium_friend_avatar = ISteamFriends.GetMediumFriendAvatar

	local GetLargeFriendAvatar_native = vtable_entry(this, 36, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetLargeFriendAvatar(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetLargeFriendAvatar_native(this, steamIDFriend)
	end
	ISteamFriends.get_large_friend_avatar = ISteamFriends.GetLargeFriendAvatar

	local RequestUserInformation_native = vtable_entry(this, 37, "bool(__thiscall*)(void*, SteamID, bool)")
	function ISteamFriends.RequestUserInformation(steamIDUser, bRequireNameOnly)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return RequestUserInformation_native(this, steamIDUser, bRequireNameOnly)
	end
	ISteamFriends.request_user_information = ISteamFriends.RequestUserInformation

	local RequestClanOfficerList_native = vtable_entry(this, 38, "uint64_t(__thiscall*)(void*, SteamID)")
	local RequestClanOfficerList_info = {
		struct = typeof([[
			struct {
				SteamID m_steamIDClan;
				int m_cOfficers;
				bool m_bSuccess;
			} *
		]]),
		keys = {m_steamIDClan="steamid_clan",m_cOfficers="officers",m_bSuccess="success"}
	}
	function ISteamFriends.RequestClanOfficerList(steamIDClan, callback)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestClanOfficerList_native(this, steamIDClan)

		if callback ~= nil then
			res = register_call_result(res, callback, 335, RequestClanOfficerList_info)
		end

		return res
	end
	ISteamFriends.request_clan_officer_list = ISteamFriends.RequestClanOfficerList

	local GetClanOwner_native = vtable_entry(this, 39, "void(__thiscall*)(void*, SteamID *, SteamID)")
	function ISteamFriends.GetClanOwner(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local CSteamID_out = new_SteamID_arr()
		GetClanOwner_native(this, CSteamID_out, steamIDClan)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_clan_owner = ISteamFriends.GetClanOwner

	local GetClanOfficerCount_native = vtable_entry(this, 40, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetClanOfficerCount(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		return GetClanOfficerCount_native(this, steamIDClan)
	end
	ISteamFriends.get_clan_officer_count = ISteamFriends.GetClanOfficerCount

	local GetClanOfficerByIndex_native = vtable_entry(this, 41, "void(__thiscall*)(void*, SteamID *, SteamID, int)")
	function ISteamFriends.GetClanOfficerByIndex(steamIDClan, iOfficer)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local CSteamID_out = new_SteamID_arr()
		GetClanOfficerByIndex_native(this, CSteamID_out, steamIDClan, iOfficer)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_clan_officer_by_index = ISteamFriends.GetClanOfficerByIndex

	local GetUserRestrictions_native = vtable_entry(this, 42, "uint32_t(__thiscall*)(void*)")
	function ISteamFriends.GetUserRestrictions()
		return GetUserRestrictions_native(this)
	end
	ISteamFriends.get_user_restrictions = ISteamFriends.GetUserRestrictions

	local SetRichPresence_native = vtable_entry(this, 43, "bool(__thiscall*)(void*, const char *, const char *)")
	function ISteamFriends.SetRichPresence(pchKey, pchValue)
		return SetRichPresence_native(this, pchKey, pchValue)
	end
	ISteamFriends.set_rich_presence = ISteamFriends.SetRichPresence

	local ClearRichPresence_native = vtable_entry(this, 44, "void(__thiscall*)(void*)")
	function ISteamFriends.ClearRichPresence()
		return ClearRichPresence_native(this)
	end
	ISteamFriends.clear_rich_presence = ISteamFriends.ClearRichPresence

	local GetFriendRichPresence_native = vtable_entry(this, 45, "const char *(__thiscall*)(void*, SteamID, const char *)")
	function ISteamFriends.GetFriendRichPresence(steamIDFriend, pchKey)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local res = GetFriendRichPresence_native(this, steamIDFriend, pchKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_friend_rich_presence = ISteamFriends.GetFriendRichPresence

	local GetFriendRichPresenceKeyCount_native = vtable_entry(this, 46, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendRichPresenceKeyCount(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendRichPresenceKeyCount_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_rich_presence_key_count = ISteamFriends.GetFriendRichPresenceKeyCount

	local GetFriendRichPresenceKeyByIndex_native = vtable_entry(this, 47, "const char *(__thiscall*)(void*, SteamID, int)")
	function ISteamFriends.GetFriendRichPresenceKeyByIndex(steamIDFriend, iKey)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local res = GetFriendRichPresenceKeyByIndex_native(this, steamIDFriend, iKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamFriends.get_friend_rich_presence_key_by_index = ISteamFriends.GetFriendRichPresenceKeyByIndex

	local RequestFriendRichPresence_native = vtable_entry(this, 48, "void(__thiscall*)(void*, SteamID)")
	function ISteamFriends.RequestFriendRichPresence(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return RequestFriendRichPresence_native(this, steamIDFriend)
	end
	ISteamFriends.request_friend_rich_presence = ISteamFriends.RequestFriendRichPresence

	local InviteUserToGame_native = vtable_entry(this, 49, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamFriends.InviteUserToGame(steamIDFriend, pchConnectString)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return InviteUserToGame_native(this, steamIDFriend, pchConnectString)
	end
	ISteamFriends.invite_user_to_game = ISteamFriends.InviteUserToGame

	local GetCoplayFriendCount_native = vtable_entry(this, 50, "int(__thiscall*)(void*)")
	function ISteamFriends.GetCoplayFriendCount()
		return GetCoplayFriendCount_native(this)
	end
	ISteamFriends.get_coplay_friend_count = ISteamFriends.GetCoplayFriendCount

	local GetCoplayFriend_native = vtable_entry(this, 51, "void(__thiscall*)(void*, SteamID *, int)")
	function ISteamFriends.GetCoplayFriend(iCoplayFriend)
		local CSteamID_out = new_SteamID_arr()
		GetCoplayFriend_native(this, CSteamID_out, iCoplayFriend)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_coplay_friend = ISteamFriends.GetCoplayFriend

	local GetFriendCoplayTime_native = vtable_entry(this, 52, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendCoplayTime(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendCoplayTime_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_coplay_time = ISteamFriends.GetFriendCoplayTime

	local GetFriendCoplayGame_native = vtable_entry(this, 53, "unsigned int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetFriendCoplayGame(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return GetFriendCoplayGame_native(this, steamIDFriend)
	end
	ISteamFriends.get_friend_coplay_game = ISteamFriends.GetFriendCoplayGame

	local JoinClanChatRoom_native = vtable_entry(this, 54, "uint64_t(__thiscall*)(void*, SteamID)")
	local JoinClanChatRoom_info = {
		struct = typeof([[
			struct {
				SteamID m_steamIDClanChat;
				int m_eChatRoomEnterResponse;
			} *
		]]),
		keys = {m_steamIDClanChat="steamid_clan_chat",m_eChatRoomEnterResponse="chat_room_enter_response"}
	}
	function ISteamFriends.JoinClanChatRoom(steamIDClan, callback)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = JoinClanChatRoom_native(this, steamIDClan)

		if callback ~= nil then
			res = register_call_result(res, callback, 342, JoinClanChatRoom_info)
		end

		return res
	end
	ISteamFriends.join_clan_chat_room = ISteamFriends.JoinClanChatRoom

	local LeaveClanChatRoom_native = vtable_entry(this, 55, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.LeaveClanChatRoom(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		return LeaveClanChatRoom_native(this, steamIDClan)
	end
	ISteamFriends.leave_clan_chat_room = ISteamFriends.LeaveClanChatRoom

	local GetClanChatMemberCount_native = vtable_entry(this, 56, "int(__thiscall*)(void*, SteamID)")
	function ISteamFriends.GetClanChatMemberCount(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		return GetClanChatMemberCount_native(this, steamIDClan)
	end
	ISteamFriends.get_clan_chat_member_count = ISteamFriends.GetClanChatMemberCount

	local GetChatMemberByIndex_native = vtable_entry(this, 57, "void(__thiscall*)(void*, SteamID *, SteamID, int)")
	function ISteamFriends.GetChatMemberByIndex(steamIDClan, iUser)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		local CSteamID_out = new_SteamID_arr()
		GetChatMemberByIndex_native(this, CSteamID_out, steamIDClan, iUser)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamFriends.get_chat_member_by_index = ISteamFriends.GetChatMemberByIndex

	local SendClanChatMessage_native = vtable_entry(this, 58, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamFriends.SendClanChatMessage(steamIDClanChat, pchText)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		return SendClanChatMessage_native(this, steamIDClanChat, pchText)
	end
	ISteamFriends.send_clan_chat_message = ISteamFriends.SendClanChatMessage

	local GetClanChatMessage_native = vtable_entry(this, 59, "int(__thiscall*)(void*, SteamID, int, void *, int, int *, SteamID *)")
	function ISteamFriends.GetClanChatMessage(steamIDClanChat, iMessage, prgchText, cchTextMax)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		local peChatEntryType_out = new_int_arr()
		local psteamidChatter_out = new_SteamID_arr()
		local res = GetClanChatMessage_native(this, steamIDClanChat, iMessage, prgchText, cchTextMax, peChatEntryType_out, psteamidChatter_out)

		return res, DEREF_GCSAFE(peChatEntryType_out), DEREF_GCSAFE(psteamidChatter_out)
	end
	ISteamFriends.get_clan_chat_message = ISteamFriends.GetClanChatMessage

	local IsClanChatAdmin_native = vtable_entry(this, 60, "bool(__thiscall*)(void*, SteamID, SteamID)")
	function ISteamFriends.IsClanChatAdmin(steamIDClanChat, steamIDUser)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return IsClanChatAdmin_native(this, steamIDClanChat, steamIDUser)
	end
	ISteamFriends.is_clan_chat_admin = ISteamFriends.IsClanChatAdmin

	local IsClanChatWindowOpenInSteam_native = vtable_entry(this, 61, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.IsClanChatWindowOpenInSteam(steamIDClanChat)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		return IsClanChatWindowOpenInSteam_native(this, steamIDClanChat)
	end
	ISteamFriends.is_clan_chat_window_open_in_steam = ISteamFriends.IsClanChatWindowOpenInSteam

	local OpenClanChatWindowInSteam_native = vtable_entry(this, 62, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.OpenClanChatWindowInSteam(steamIDClanChat)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		return OpenClanChatWindowInSteam_native(this, steamIDClanChat)
	end
	ISteamFriends.open_clan_chat_window_in_steam = ISteamFriends.OpenClanChatWindowInSteam

	local CloseClanChatWindowInSteam_native = vtable_entry(this, 63, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.CloseClanChatWindowInSteam(steamIDClanChat)
		steamIDClanChat = to_steamid_required(steamIDClanChat, "steamid_clan_chat is required")
		return CloseClanChatWindowInSteam_native(this, steamIDClanChat)
	end
	ISteamFriends.close_clan_chat_window_in_steam = ISteamFriends.CloseClanChatWindowInSteam

	local SetListenForFriendsMessages_native = vtable_entry(this, 64, "bool(__thiscall*)(void*, bool)")
	function ISteamFriends.SetListenForFriendsMessages(bInterceptEnabled)
		return SetListenForFriendsMessages_native(this, bInterceptEnabled)
	end
	ISteamFriends.set_listen_for_friends_messages = ISteamFriends.SetListenForFriendsMessages

	local ReplyToFriendMessage_native = vtable_entry(this, 65, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamFriends.ReplyToFriendMessage(steamIDFriend, pchMsgToSend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return ReplyToFriendMessage_native(this, steamIDFriend, pchMsgToSend)
	end
	ISteamFriends.reply_to_friend_message = ISteamFriends.ReplyToFriendMessage

	local GetFriendMessage_native = vtable_entry(this, 66, "int(__thiscall*)(void*, SteamID, int, void *, int, int *)")
	function ISteamFriends.GetFriendMessage(steamIDFriend, iMessageID, pvData, cubData)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		local peChatEntryType_out = new_int_arr()
		local res = GetFriendMessage_native(this, steamIDFriend, iMessageID, pvData, cubData, peChatEntryType_out)

		return res, DEREF_GCSAFE(peChatEntryType_out)
	end
	ISteamFriends.get_friend_message = ISteamFriends.GetFriendMessage

	local GetFollowerCount_native = vtable_entry(this, 67, "uint64_t(__thiscall*)(void*, SteamID)")
	local GetFollowerCount_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_steamID;
				int m_nCount;
			} *
		]]),
		keys = {m_eResult="result",m_steamID="steamid",m_nCount="count"}
	}
	function ISteamFriends.GetFollowerCount(steamID, callback)
		steamID = to_steamid_required(steamID, "steamid is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = GetFollowerCount_native(this, steamID)

		if callback ~= nil then
			res = register_call_result(res, callback, 344, GetFollowerCount_info)
		end

		return res
	end
	ISteamFriends.get_follower_count = ISteamFriends.GetFollowerCount

	local IsFollowing_native = vtable_entry(this, 68, "uint64_t(__thiscall*)(void*, SteamID)")
	local IsFollowing_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_steamID;
				bool m_bIsFollowing;
			} *
		]]),
		keys = {m_eResult="result",m_steamID="steamid",m_bIsFollowing="is_following"}
	}
	function ISteamFriends.IsFollowing(steamID, callback)
		steamID = to_steamid_required(steamID, "steamid is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = IsFollowing_native(this, steamID)

		if callback ~= nil then
			res = register_call_result(res, callback, 345, IsFollowing_info)
		end

		return res
	end
	ISteamFriends.is_following = ISteamFriends.IsFollowing

	local EnumerateFollowingList_native = vtable_entry(this, 69, "uint64_t(__thiscall*)(void*, uint32_t)")
	local EnumerateFollowingList_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_rgSteamID[50];
				int32_t m_nResultsReturned;
				int32_t m_nTotalResultCount;
			} *
		]]),
		keys = {m_eResult="result",m_rgSteamID="steamid",m_nResultsReturned="results_returned",m_nTotalResultCount="total_result_count"}
	}
	function ISteamFriends.EnumerateFollowingList(unStartIndex, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = EnumerateFollowingList_native(this, unStartIndex)

		if callback ~= nil then
			res = register_call_result(res, callback, 346, EnumerateFollowingList_info)
		end

		return res
	end
	ISteamFriends.enumerate_following_list = ISteamFriends.EnumerateFollowingList

	local IsClanPublic_native = vtable_entry(this, 70, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.IsClanPublic(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		return IsClanPublic_native(this, steamIDClan)
	end
	ISteamFriends.is_clan_public = ISteamFriends.IsClanPublic

	local IsClanOfficialGameGroup_native = vtable_entry(this, 71, "bool(__thiscall*)(void*, SteamID)")
	function ISteamFriends.IsClanOfficialGameGroup(steamIDClan)
		steamIDClan = to_steamid_required(steamIDClan, "steamid_clan is required")
		return IsClanOfficialGameGroup_native(this, steamIDClan)
	end
	ISteamFriends.is_clan_official_game_group = ISteamFriends.IsClanOfficialGameGroup

	local GetNumChatsWithUnreadPriorityMessages_native = vtable_entry(this, 72, "int(__thiscall*)(void*)")
	function ISteamFriends.GetNumChatsWithUnreadPriorityMessages()
		return GetNumChatsWithUnreadPriorityMessages_native(this)
	end
	ISteamFriends.get_num_chats_with_unread_priority_messages = ISteamFriends.GetNumChatsWithUnreadPriorityMessages

	local ActivateGameOverlayRemotePlayTogetherInviteDialog_native = vtable_entry(this, 73, "void(__thiscall*)(void*, SteamID)")
	function ISteamFriends.ActivateGameOverlayRemotePlayTogetherInviteDialog(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return ActivateGameOverlayRemotePlayTogetherInviteDialog_native(this, steamIDLobby)
	end
	ISteamFriends.activate_game_overlay_remote_play_together_invite_dialog = ISteamFriends.ActivateGameOverlayRemotePlayTogetherInviteDialog

	local RegisterProtocolInOverlayBrowser_native = vtable_entry(this, 74, "bool(__thiscall*)(void*, const char *)")
	function ISteamFriends.RegisterProtocolInOverlayBrowser(pchProtocol)
		return RegisterProtocolInOverlayBrowser_native(this, pchProtocol)
	end
	ISteamFriends.register_protocol_in_overlay_browser = ISteamFriends.RegisterProtocolInOverlayBrowser

	local ActivateGameOverlayInviteDialogConnectString_native = vtable_entry(this, 75, "void(__thiscall*)(void*, const char *)")
	function ISteamFriends.ActivateGameOverlayInviteDialogConnectString(pchConnectString)
		return ActivateGameOverlayInviteDialogConnectString_native(this, pchConnectString)
	end
	ISteamFriends.activate_game_overlay_invite_dialog_connect_string = ISteamFriends.ActivateGameOverlayInviteDialogConnectString

	return ISteamFriends
end

--
-- ISteamUtils (SteamUtils010, user created: false)
--

local ISteamUtils = {version="SteamUtils010",version_number=10}

index_funcs.ISteamUtils = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 9, "void*(__thiscall*)(void*, int, const char *)")(hSteamPipe, "SteamUtils010")

	local GetSecondsSinceAppActive_native = vtable_entry(this, 0, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetSecondsSinceAppActive()
		return GetSecondsSinceAppActive_native(this)
	end
	ISteamUtils.get_seconds_since_app_active = ISteamUtils.GetSecondsSinceAppActive

	local GetSecondsSinceComputerActive_native = vtable_entry(this, 1, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetSecondsSinceComputerActive()
		return GetSecondsSinceComputerActive_native(this)
	end
	ISteamUtils.get_seconds_since_computer_active = ISteamUtils.GetSecondsSinceComputerActive

	local GetConnectedUniverse_native = vtable_entry(this, 2, "int(__thiscall*)(void*)")
	function ISteamUtils.GetConnectedUniverse()
		return GetConnectedUniverse_native(this)
	end
	ISteamUtils.get_connected_universe = ISteamUtils.GetConnectedUniverse

	local GetServerRealTime_native = vtable_entry(this, 3, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetServerRealTime()
		return GetServerRealTime_native(this)
	end
	ISteamUtils.get_server_real_time = ISteamUtils.GetServerRealTime

	local GetIPCountry_native = vtable_entry(this, 4, "const char *(__thiscall*)(void*)")
	function ISteamUtils.GetIPCountry()
		local res = GetIPCountry_native(this)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamUtils.get_ip_country = ISteamUtils.GetIPCountry

	local GetImageSize_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, int, uint32_t *, uint32_t *)")
	function ISteamUtils.GetImageSize(iImage)
		local pnWidth_out = new_uint32_arr()
		local pnHeight_out = new_uint32_arr()
		local res = GetImageSize_native(this, iImage, pnWidth_out, pnHeight_out)

		return res, DEREF_GCSAFE(pnWidth_out), DEREF_GCSAFE(pnHeight_out)
	end
	ISteamUtils.get_image_size = ISteamUtils.GetImageSize

	local GetImageRGBA_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, int, uint8_t *, int)")
	function ISteamUtils.GetImageRGBA(iImage, pubDest, nDestBufferSize)
		return GetImageRGBA_native(this, iImage, pubDest, nDestBufferSize)
	end
	ISteamUtils.get_image_rgba = ISteamUtils.GetImageRGBA

	local GetCurrentBatteryPower_native = vtable_entry(this, 8, "uint8_t(__thiscall*)(void*)")
	function ISteamUtils.GetCurrentBatteryPower()
		return GetCurrentBatteryPower_native(this)
	end
	ISteamUtils.get_current_battery_power = ISteamUtils.GetCurrentBatteryPower

	local GetAppID_native = vtable_entry(this, 9, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetAppID()
		return GetAppID_native(this)
	end
	ISteamUtils.get_appid = ISteamUtils.GetAppID

	local SetOverlayNotificationPosition_native = vtable_entry(this, 10, "void(__thiscall*)(void*, int)")
	function ISteamUtils.SetOverlayNotificationPosition(eNotificationPosition)
		eNotificationPosition = to_enum_required(eNotificationPosition, enums.ENotificationPosition, "notification_position is required")
		return SetOverlayNotificationPosition_native(this, eNotificationPosition)
	end
	ISteamUtils.set_overlay_notification_position = ISteamUtils.SetOverlayNotificationPosition

	local IsAPICallCompleted_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, uint64_t, bool *)")
	function ISteamUtils.IsAPICallCompleted(hSteamAPICall)
		local pbFailed_out = new_bool_arr()
		local res = IsAPICallCompleted_native(this, hSteamAPICall, pbFailed_out)

		return res, DEREF_GCSAFE(pbFailed_out)
	end
	ISteamUtils.is_api_call_completed = ISteamUtils.IsAPICallCompleted

	local GetAPICallFailureReason_native = vtable_entry(this, 12, "int(__thiscall*)(void*, uint64_t)")
	function ISteamUtils.GetAPICallFailureReason(hSteamAPICall)
		return GetAPICallFailureReason_native(this, hSteamAPICall)
	end
	ISteamUtils.get_api_call_failure_reason = ISteamUtils.GetAPICallFailureReason

	local GetAPICallResult_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, uint64_t, void *, int, int, bool *)")
	function ISteamUtils.GetAPICallResult(hSteamAPICall, pCallback, cubCallback, iCallbackExpected)
		local pbFailed_out = new_bool_arr()
		local res = GetAPICallResult_native(this, hSteamAPICall, pCallback, cubCallback, iCallbackExpected, pbFailed_out)

		return res, DEREF_GCSAFE(pbFailed_out)
	end
	ISteamUtils.get_api_call_result = ISteamUtils.GetAPICallResult

	local GetIPCCallCount_native = vtable_entry(this, 15, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetIPCCallCount()
		return GetIPCCallCount_native(this)
	end
	ISteamUtils.get_ipc_call_count = ISteamUtils.GetIPCCallCount

	local SetWarningMessageHook_native = vtable_entry(this, 16, "void(__thiscall*)(void*, void*(__cdecl*)(int, const char*))")
	function ISteamUtils.SetWarningMessageHook(pFunction)
		return SetWarningMessageHook_native(this, pFunction)
	end
	ISteamUtils.set_warning_message_hook = ISteamUtils.SetWarningMessageHook

	local IsOverlayEnabled_native = vtable_entry(this, 17, "bool(__thiscall*)(void*)")
	function ISteamUtils.IsOverlayEnabled()
		return IsOverlayEnabled_native(this)
	end
	ISteamUtils.is_overlay_enabled = ISteamUtils.IsOverlayEnabled

	local BOverlayNeedsPresent_native = vtable_entry(this, 18, "bool(__thiscall*)(void*)")
	function ISteamUtils.BOverlayNeedsPresent()
		return BOverlayNeedsPresent_native(this)
	end
	ISteamUtils.overlay_needs_present = ISteamUtils.BOverlayNeedsPresent

	local CheckFileSignature_native = vtable_entry(this, 19, "uint64_t(__thiscall*)(void*, const char *)")
	local CheckFileSignature_info = {
		struct = typeof([[
			struct {
				int m_eCheckFileSignature;
			} *
		]]),
		keys = {m_eCheckFileSignature="check_file_signature"}
	}
	function ISteamUtils.CheckFileSignature(szFileName, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = CheckFileSignature_native(this, szFileName)

		if callback ~= nil then
			res = register_call_result(res, callback, 705, CheckFileSignature_info)
		end

		return res
	end
	ISteamUtils.check_file_signature = ISteamUtils.CheckFileSignature

	local ShowGamepadTextInput_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, int, int, const char *, uint32_t, const char *)")
	function ISteamUtils.ShowGamepadTextInput(eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText)
		eInputMode = to_enum_required(eInputMode, enums.EGamepadTextInputMode, "input_mode is required")
		eLineInputMode = to_enum_required(eLineInputMode, enums.EGamepadTextInputLineMode, "line_input_mode is required")
		return ShowGamepadTextInput_native(this, eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText)
	end
	ISteamUtils.show_gamepad_text_input = ISteamUtils.ShowGamepadTextInput

	local GetEnteredGamepadTextLength_native = vtable_entry(this, 21, "uint32_t(__thiscall*)(void*)")
	function ISteamUtils.GetEnteredGamepadTextLength()
		return GetEnteredGamepadTextLength_native(this)
	end
	ISteamUtils.get_entered_gamepad_text_length = ISteamUtils.GetEnteredGamepadTextLength

	local GetEnteredGamepadTextInput_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, char *, uint32_t)")
	function ISteamUtils.GetEnteredGamepadTextInput(pchText, cchText)
		return GetEnteredGamepadTextInput_native(this, pchText, cchText)
	end
	ISteamUtils.get_entered_gamepad_text_input = ISteamUtils.GetEnteredGamepadTextInput

	local GetSteamUILanguage_native = vtable_entry(this, 23, "const char *(__thiscall*)(void*)")
	function ISteamUtils.GetSteamUILanguage()
		local res = GetSteamUILanguage_native(this)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamUtils.get_steam_ui_language = ISteamUtils.GetSteamUILanguage

	local IsSteamRunningInVR_native = vtable_entry(this, 24, "bool(__thiscall*)(void*)")
	function ISteamUtils.IsSteamRunningInVR()
		return IsSteamRunningInVR_native(this)
	end
	ISteamUtils.is_steam_running_in_vr = ISteamUtils.IsSteamRunningInVR

	local SetOverlayNotificationInset_native = vtable_entry(this, 25, "void(__thiscall*)(void*, int, int)")
	function ISteamUtils.SetOverlayNotificationInset(nHorizontalInset, nVerticalInset)
		return SetOverlayNotificationInset_native(this, nHorizontalInset, nVerticalInset)
	end
	ISteamUtils.set_overlay_notification_inset = ISteamUtils.SetOverlayNotificationInset

	local IsSteamInBigPictureMode_native = vtable_entry(this, 26, "bool(__thiscall*)(void*)")
	function ISteamUtils.IsSteamInBigPictureMode()
		return IsSteamInBigPictureMode_native(this)
	end
	ISteamUtils.is_steam_in_big_picture_mode = ISteamUtils.IsSteamInBigPictureMode

	local StartVRDashboard_native = vtable_entry(this, 27, "void(__thiscall*)(void*)")
	function ISteamUtils.StartVRDashboard()
		return StartVRDashboard_native(this)
	end
	ISteamUtils.start_vr_dashboard = ISteamUtils.StartVRDashboard

	local IsVRHeadsetStreamingEnabled_native = vtable_entry(this, 28, "bool(__thiscall*)(void*)")
	function ISteamUtils.IsVRHeadsetStreamingEnabled()
		return IsVRHeadsetStreamingEnabled_native(this)
	end
	ISteamUtils.is_vr_headset_streaming_enabled = ISteamUtils.IsVRHeadsetStreamingEnabled

	local SetVRHeadsetStreamingEnabled_native = vtable_entry(this, 29, "void(__thiscall*)(void*, bool)")
	function ISteamUtils.SetVRHeadsetStreamingEnabled(bEnabled)
		return SetVRHeadsetStreamingEnabled_native(this, bEnabled)
	end
	ISteamUtils.set_vr_headset_streaming_enabled = ISteamUtils.SetVRHeadsetStreamingEnabled

	local IsSteamChinaLauncher_native = vtable_entry(this, 30, "bool(__thiscall*)(void*)")
	function ISteamUtils.IsSteamChinaLauncher()
		return IsSteamChinaLauncher_native(this)
	end
	ISteamUtils.is_steam_china_launcher = ISteamUtils.IsSteamChinaLauncher

	local InitFilterText_native = vtable_entry(this, 31, "bool(__thiscall*)(void*, uint32_t)")
	function ISteamUtils.InitFilterText(unFilterOptions)
		return InitFilterText_native(this, unFilterOptions)
	end
	ISteamUtils.init_filter_text = ISteamUtils.InitFilterText

	local FilterText_native = vtable_entry(this, 32, "int(__thiscall*)(void*, int, SteamID, const char *, char *, uint32_t)")
	function ISteamUtils.FilterText(eContext, sourceSteamID, pchInputMessage, pchOutFilteredText, nByteSizeOutFilteredText)
		eContext = to_enum_required(eContext, enums.ETextFilteringContext, "context is required")
		sourceSteamID = to_steamid_required(sourceSteamID, "source_steamid is required")
		return FilterText_native(this, eContext, sourceSteamID, pchInputMessage, pchOutFilteredText, nByteSizeOutFilteredText)
	end
	ISteamUtils.filter_text = ISteamUtils.FilterText

	local GetIPv6ConnectivityState_native = vtable_entry(this, 33, "int(__thiscall*)(void*, int)")
	function ISteamUtils.GetIPv6ConnectivityState(eProtocol)
		eProtocol = to_enum_required(eProtocol, enums.ESteamIPv6ConnectivityProtocol, "protocol is required")
		return GetIPv6ConnectivityState_native(this, eProtocol)
	end
	ISteamUtils.get_ipv6_connectivity_state = ISteamUtils.GetIPv6ConnectivityState

	return ISteamUtils
end

--
-- ISteamMatchmaking (SteamMatchMaking009, user created: false)
--

local ISteamMatchmaking = {version="SteamMatchMaking009",version_number=9}

index_funcs.ISteamMatchmaking = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 10, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamMatchMaking009")

	local GetFavoriteGameCount_native = vtable_entry(this, 0, "int(__thiscall*)(void*)")
	function ISteamMatchmaking.GetFavoriteGameCount()
		return GetFavoriteGameCount_native(this)
	end
	ISteamMatchmaking.get_favorite_game_count = ISteamMatchmaking.GetFavoriteGameCount

	local GetFavoriteGame_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, int, unsigned int *, uint32_t *, uint16_t *, uint16_t *, uint32_t *, uint32_t *)")
	function ISteamMatchmaking.GetFavoriteGame(iGame)
		local pnAppID_out = new_unsigned_int_arr()
		local pnIP_out = new_uint32_arr()
		local pnConnPort_out = new_uint16_arr()
		local pnQueryPort_out = new_uint16_arr()
		local punFlags_out = new_uint32_arr()
		local pRTime32LastPlayedOnServer_out = new_uint32_arr()
		local res = GetFavoriteGame_native(this, iGame, pnAppID_out, pnIP_out, pnConnPort_out, pnQueryPort_out, punFlags_out, pRTime32LastPlayedOnServer_out)

		return res, DEREF_GCSAFE(pnAppID_out), DEREF_GCSAFE(pnIP_out), DEREF_GCSAFE(pnConnPort_out), DEREF_GCSAFE(pnQueryPort_out), DEREF_GCSAFE(punFlags_out), DEREF_GCSAFE(pRTime32LastPlayedOnServer_out)
	end
	ISteamMatchmaking.get_favorite_game = ISteamMatchmaking.GetFavoriteGame

	local AddFavoriteGame_native = vtable_entry(this, 2, "int(__thiscall*)(void*, unsigned int, uint32_t, uint16_t, uint16_t, uint32_t, uint32_t)")
	function ISteamMatchmaking.AddFavoriteGame(nAppID, nIP, nConnPort, nQueryPort, unFlags, rTime32LastPlayedOnServer)
		return AddFavoriteGame_native(this, nAppID, nIP, nConnPort, nQueryPort, unFlags, rTime32LastPlayedOnServer)
	end
	ISteamMatchmaking.add_favorite_game = ISteamMatchmaking.AddFavoriteGame

	local RemoveFavoriteGame_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, unsigned int, uint32_t, uint16_t, uint16_t, uint32_t)")
	function ISteamMatchmaking.RemoveFavoriteGame(nAppID, nIP, nConnPort, nQueryPort, unFlags)
		return RemoveFavoriteGame_native(this, nAppID, nIP, nConnPort, nQueryPort, unFlags)
	end
	ISteamMatchmaking.remove_favorite_game = ISteamMatchmaking.RemoveFavoriteGame

	local RequestLobbyList_native = vtable_entry(this, 4, "uint64_t(__thiscall*)(void*)")
	local RequestLobbyList_info = {
		struct = typeof([[
			struct {
				uint32_t m_nLobbiesMatching;
			} *
		]]),
		keys = {m_nLobbiesMatching="lobbies_matching"}
	}
	function ISteamMatchmaking.RequestLobbyList(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestLobbyList_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 510, RequestLobbyList_info)
		end

		return res
	end
	ISteamMatchmaking.request_lobby_list = ISteamMatchmaking.RequestLobbyList

	local AddRequestLobbyListStringFilter_native = vtable_entry(this, 5, "void(__thiscall*)(void*, const char *, const char *, int)")
	function ISteamMatchmaking.AddRequestLobbyListStringFilter(pchKeyToMatch, pchValueToMatch, eComparisonType)
		eComparisonType = to_enum_required(eComparisonType, enums.ELobbyComparison, "comparison_type is required")
		return AddRequestLobbyListStringFilter_native(this, pchKeyToMatch, pchValueToMatch, eComparisonType)
	end
	ISteamMatchmaking.add_request_lobby_list_string_filter = ISteamMatchmaking.AddRequestLobbyListStringFilter

	local AddRequestLobbyListNumericalFilter_native = vtable_entry(this, 6, "void(__thiscall*)(void*, const char *, int, int)")
	function ISteamMatchmaking.AddRequestLobbyListNumericalFilter(pchKeyToMatch, nValueToMatch, eComparisonType)
		eComparisonType = to_enum_required(eComparisonType, enums.ELobbyComparison, "comparison_type is required")
		return AddRequestLobbyListNumericalFilter_native(this, pchKeyToMatch, nValueToMatch, eComparisonType)
	end
	ISteamMatchmaking.add_request_lobby_list_numerical_filter = ISteamMatchmaking.AddRequestLobbyListNumericalFilter

	local AddRequestLobbyListNearValueFilter_native = vtable_entry(this, 7, "void(__thiscall*)(void*, const char *, int)")
	function ISteamMatchmaking.AddRequestLobbyListNearValueFilter(pchKeyToMatch, nValueToBeCloseTo)
		return AddRequestLobbyListNearValueFilter_native(this, pchKeyToMatch, nValueToBeCloseTo)
	end
	ISteamMatchmaking.add_request_lobby_list_near_value_filter = ISteamMatchmaking.AddRequestLobbyListNearValueFilter

	local AddRequestLobbyListFilterSlotsAvailable_native = vtable_entry(this, 8, "void(__thiscall*)(void*, int)")
	function ISteamMatchmaking.AddRequestLobbyListFilterSlotsAvailable(nSlotsAvailable)
		return AddRequestLobbyListFilterSlotsAvailable_native(this, nSlotsAvailable)
	end
	ISteamMatchmaking.add_request_lobby_list_filter_slots_available = ISteamMatchmaking.AddRequestLobbyListFilterSlotsAvailable

	local AddRequestLobbyListDistanceFilter_native = vtable_entry(this, 9, "void(__thiscall*)(void*, int)")
	function ISteamMatchmaking.AddRequestLobbyListDistanceFilter(eLobbyDistanceFilter)
		eLobbyDistanceFilter = to_enum_required(eLobbyDistanceFilter, enums.ELobbyDistanceFilter, "lobby_distance_filter is required")
		return AddRequestLobbyListDistanceFilter_native(this, eLobbyDistanceFilter)
	end
	ISteamMatchmaking.add_request_lobby_list_distance_filter = ISteamMatchmaking.AddRequestLobbyListDistanceFilter

	local AddRequestLobbyListResultCountFilter_native = vtable_entry(this, 10, "void(__thiscall*)(void*, int)")
	function ISteamMatchmaking.AddRequestLobbyListResultCountFilter(cMaxResults)
		return AddRequestLobbyListResultCountFilter_native(this, cMaxResults)
	end
	ISteamMatchmaking.add_request_lobby_list_result_count_filter = ISteamMatchmaking.AddRequestLobbyListResultCountFilter

	local AddRequestLobbyListCompatibleMembersFilter_native = vtable_entry(this, 11, "void(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.AddRequestLobbyListCompatibleMembersFilter(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return AddRequestLobbyListCompatibleMembersFilter_native(this, steamIDLobby)
	end
	ISteamMatchmaking.add_request_lobby_list_compatible_members_filter = ISteamMatchmaking.AddRequestLobbyListCompatibleMembersFilter

	local GetLobbyByIndex_native = vtable_entry(this, 12, "void(__thiscall*)(void*, SteamID *, int)")
	function ISteamMatchmaking.GetLobbyByIndex(iLobby)
		local CSteamID_out = new_SteamID_arr()
		GetLobbyByIndex_native(this, CSteamID_out, iLobby)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamMatchmaking.get_lobby_by_index = ISteamMatchmaking.GetLobbyByIndex

	local CreateLobby_native = vtable_entry(this, 13, "uint64_t(__thiscall*)(void*, int, int)")
	local CreateLobby_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_ulSteamIDLobby;
			} *
		]]),
		keys = {m_eResult="result",m_ulSteamIDLobby="steamid_lobby"}
	}
	function ISteamMatchmaking.CreateLobby(eLobbyType, cMaxMembers, callback)
		eLobbyType = to_enum_required(eLobbyType, enums.ELobbyType, "lobby_type is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = CreateLobby_native(this, eLobbyType, cMaxMembers)

		if callback ~= nil then
			res = register_call_result(res, callback, 513, CreateLobby_info)
		end

		return res
	end
	ISteamMatchmaking.create_lobby = ISteamMatchmaking.CreateLobby

	local JoinLobby_native = vtable_entry(this, 14, "uint64_t(__thiscall*)(void*, SteamID)")
	local JoinLobby_info = {
		struct = typeof([[
			struct {
				SteamID m_ulSteamIDLobby;
				uint32_t m_rgfChatPermissions;
				bool m_bLocked;
				uint32_t m_EChatRoomEnterResponse;
			} *
		]]),
		keys = {m_ulSteamIDLobby="steamid_lobby",m_rgfChatPermissions="chat_permissions",m_bLocked="locked",m_EChatRoomEnterResponse="e_chat_room_enter_response"}
	}
	function ISteamMatchmaking.JoinLobby(steamIDLobby, callback)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = JoinLobby_native(this, steamIDLobby)

		if callback ~= nil then
			res = register_call_result(res, callback, 504, JoinLobby_info)
		end

		return res
	end
	ISteamMatchmaking.join_lobby = ISteamMatchmaking.JoinLobby

	local LeaveLobby_native = vtable_entry(this, 15, "void(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.LeaveLobby(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return LeaveLobby_native(this, steamIDLobby)
	end
	ISteamMatchmaking.leave_lobby = ISteamMatchmaking.LeaveLobby

	local InviteUserToLobby_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, SteamID, SteamID)")
	function ISteamMatchmaking.InviteUserToLobby(steamIDLobby, steamIDInvitee)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		steamIDInvitee = to_steamid_required(steamIDInvitee, "steamid_invitee is required")
		return InviteUserToLobby_native(this, steamIDLobby, steamIDInvitee)
	end
	ISteamMatchmaking.invite_user_to_lobby = ISteamMatchmaking.InviteUserToLobby

	local GetNumLobbyMembers_native = vtable_entry(this, 17, "int(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.GetNumLobbyMembers(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return GetNumLobbyMembers_native(this, steamIDLobby)
	end
	ISteamMatchmaking.get_num_lobby_members = ISteamMatchmaking.GetNumLobbyMembers

	local GetLobbyMemberByIndex_native = vtable_entry(this, 18, "void(__thiscall*)(void*, SteamID *, SteamID, int)")
	function ISteamMatchmaking.GetLobbyMemberByIndex(steamIDLobby, iMember)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		local CSteamID_out = new_SteamID_arr()
		GetLobbyMemberByIndex_native(this, CSteamID_out, steamIDLobby, iMember)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamMatchmaking.get_lobby_member_by_index = ISteamMatchmaking.GetLobbyMemberByIndex

	local GetLobbyData_native = vtable_entry(this, 19, "const char *(__thiscall*)(void*, SteamID, const char *)")
	function ISteamMatchmaking.GetLobbyData(steamIDLobby, pchKey)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		local res = GetLobbyData_native(this, steamIDLobby, pchKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamMatchmaking.get_lobby_data = ISteamMatchmaking.GetLobbyData

	local SetLobbyData_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, SteamID, const char *, const char *)")
	function ISteamMatchmaking.SetLobbyData(steamIDLobby, pchKey, pchValue)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return SetLobbyData_native(this, steamIDLobby, pchKey, pchValue)
	end
	ISteamMatchmaking.set_lobby_data = ISteamMatchmaking.SetLobbyData

	local GetLobbyDataCount_native = vtable_entry(this, 21, "int(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.GetLobbyDataCount(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return GetLobbyDataCount_native(this, steamIDLobby)
	end
	ISteamMatchmaking.get_lobby_data_count = ISteamMatchmaking.GetLobbyDataCount

	local GetLobbyDataByIndex_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, SteamID, int, char *, int, char *, int)")
	function ISteamMatchmaking.GetLobbyDataByIndex(steamIDLobby, iLobbyData, pchKey, cchKeyBufferSize, pchValue, cchValueBufferSize)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return GetLobbyDataByIndex_native(this, steamIDLobby, iLobbyData, pchKey, cchKeyBufferSize, pchValue, cchValueBufferSize)
	end
	ISteamMatchmaking.get_lobby_data_by_index = ISteamMatchmaking.GetLobbyDataByIndex

	local DeleteLobbyData_native = vtable_entry(this, 23, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamMatchmaking.DeleteLobbyData(steamIDLobby, pchKey)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return DeleteLobbyData_native(this, steamIDLobby, pchKey)
	end
	ISteamMatchmaking.delete_lobby_data = ISteamMatchmaking.DeleteLobbyData

	local GetLobbyMemberData_native = vtable_entry(this, 24, "const char *(__thiscall*)(void*, SteamID, SteamID, const char *)")
	function ISteamMatchmaking.GetLobbyMemberData(steamIDLobby, steamIDUser, pchKey)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local res = GetLobbyMemberData_native(this, steamIDLobby, steamIDUser, pchKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamMatchmaking.get_lobby_member_data = ISteamMatchmaking.GetLobbyMemberData

	local SetLobbyMemberData_native = vtable_entry(this, 25, "void(__thiscall*)(void*, SteamID, const char *, const char *)")
	function ISteamMatchmaking.SetLobbyMemberData(steamIDLobby, pchKey, pchValue)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return SetLobbyMemberData_native(this, steamIDLobby, pchKey, pchValue)
	end
	ISteamMatchmaking.set_lobby_member_data = ISteamMatchmaking.SetLobbyMemberData

	local SendLobbyChatMsg_native = vtable_entry(this, 26, "bool(__thiscall*)(void*, SteamID, const void *, int)")
	function ISteamMatchmaking.SendLobbyChatMsg(steamIDLobby, pvMsgBody, cubMsgBody)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return SendLobbyChatMsg_native(this, steamIDLobby, pvMsgBody, cubMsgBody)
	end
	ISteamMatchmaking.send_lobby_chat_msg = ISteamMatchmaking.SendLobbyChatMsg

	local GetLobbyChatEntry_native = vtable_entry(this, 27, "int(__thiscall*)(void*, SteamID, int, SteamID *, void *, int, int *)")
	function ISteamMatchmaking.GetLobbyChatEntry(steamIDLobby, iChatID, pvData, cubData)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		local pSteamIDUser_out = new_SteamID_arr()
		local peChatEntryType_out = new_int_arr()
		local res = GetLobbyChatEntry_native(this, steamIDLobby, iChatID, pSteamIDUser_out, pvData, cubData, peChatEntryType_out)

		return res, DEREF_GCSAFE(pSteamIDUser_out), DEREF_GCSAFE(peChatEntryType_out)
	end
	ISteamMatchmaking.get_lobby_chat_entry = ISteamMatchmaking.GetLobbyChatEntry

	local RequestLobbyData_native = vtable_entry(this, 28, "bool(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.RequestLobbyData(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return RequestLobbyData_native(this, steamIDLobby)
	end
	ISteamMatchmaking.request_lobby_data = ISteamMatchmaking.RequestLobbyData

	local SetLobbyGameServer_native = vtable_entry(this, 29, "void(__thiscall*)(void*, SteamID, uint32_t, uint16_t, SteamID)")
	function ISteamMatchmaking.SetLobbyGameServer(steamIDLobby, unGameServerIP, unGameServerPort, steamIDGameServer)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		unGameServerIP = to_ip_int_required(unGameServerIP, "game_server_ip is required")
		steamIDGameServer = to_steamid_required(steamIDGameServer, "steamid_game_server is required")
		return SetLobbyGameServer_native(this, steamIDLobby, unGameServerIP, unGameServerPort, steamIDGameServer)
	end
	ISteamMatchmaking.set_lobby_game_server = ISteamMatchmaking.SetLobbyGameServer

	local GetLobbyGameServer_native = vtable_entry(this, 30, "bool(__thiscall*)(void*, SteamID, uint32_t *, uint16_t *, SteamID *)")
	function ISteamMatchmaking.GetLobbyGameServer(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		local punGameServerIP_out = new_uint32_arr()
		local punGameServerPort_out = new_uint16_arr()
		local psteamIDGameServer_out = new_SteamID_arr()
		local res = GetLobbyGameServer_native(this, steamIDLobby, punGameServerIP_out, punGameServerPort_out, psteamIDGameServer_out)

		return res, DEREF_GCSAFE(punGameServerIP_out), DEREF_GCSAFE(punGameServerPort_out), DEREF_GCSAFE(psteamIDGameServer_out)
	end
	ISteamMatchmaking.get_lobby_game_server = ISteamMatchmaking.GetLobbyGameServer

	local SetLobbyMemberLimit_native = vtable_entry(this, 31, "bool(__thiscall*)(void*, SteamID, int)")
	function ISteamMatchmaking.SetLobbyMemberLimit(steamIDLobby, cMaxMembers)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return SetLobbyMemberLimit_native(this, steamIDLobby, cMaxMembers)
	end
	ISteamMatchmaking.set_lobby_member_limit = ISteamMatchmaking.SetLobbyMemberLimit

	local GetLobbyMemberLimit_native = vtable_entry(this, 32, "int(__thiscall*)(void*, SteamID)")
	function ISteamMatchmaking.GetLobbyMemberLimit(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return GetLobbyMemberLimit_native(this, steamIDLobby)
	end
	ISteamMatchmaking.get_lobby_member_limit = ISteamMatchmaking.GetLobbyMemberLimit

	local SetLobbyType_native = vtable_entry(this, 33, "bool(__thiscall*)(void*, SteamID, int)")
	function ISteamMatchmaking.SetLobbyType(steamIDLobby, eLobbyType)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		eLobbyType = to_enum_required(eLobbyType, enums.ELobbyType, "lobby_type is required")
		return SetLobbyType_native(this, steamIDLobby, eLobbyType)
	end
	ISteamMatchmaking.set_lobby_type = ISteamMatchmaking.SetLobbyType

	local SetLobbyJoinable_native = vtable_entry(this, 34, "bool(__thiscall*)(void*, SteamID, bool)")
	function ISteamMatchmaking.SetLobbyJoinable(steamIDLobby, bLobbyJoinable)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		return SetLobbyJoinable_native(this, steamIDLobby, bLobbyJoinable)
	end
	ISteamMatchmaking.set_lobby_joinable = ISteamMatchmaking.SetLobbyJoinable

	local GetLobbyOwner_native = vtable_entry(this, 35, "void(__thiscall*)(void*, SteamID *, SteamID)")
	function ISteamMatchmaking.GetLobbyOwner(steamIDLobby)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		local CSteamID_out = new_SteamID_arr()
		GetLobbyOwner_native(this, CSteamID_out, steamIDLobby)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamMatchmaking.get_lobby_owner = ISteamMatchmaking.GetLobbyOwner

	local SetLobbyOwner_native = vtable_entry(this, 36, "bool(__thiscall*)(void*, SteamID, SteamID)")
	function ISteamMatchmaking.SetLobbyOwner(steamIDLobby, steamIDNewOwner)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		steamIDNewOwner = to_steamid_required(steamIDNewOwner, "steamid_new_owner is required")
		return SetLobbyOwner_native(this, steamIDLobby, steamIDNewOwner)
	end
	ISteamMatchmaking.set_lobby_owner = ISteamMatchmaking.SetLobbyOwner

	local SetLinkedLobby_native = vtable_entry(this, 37, "bool(__thiscall*)(void*, SteamID, SteamID)")
	function ISteamMatchmaking.SetLinkedLobby(steamIDLobby, steamIDLobbyDependent)
		steamIDLobby = to_steamid_required(steamIDLobby, "steamid_lobby is required")
		steamIDLobbyDependent = to_steamid_required(steamIDLobbyDependent, "steamid_lobby_dependent is required")
		return SetLinkedLobby_native(this, steamIDLobby, steamIDLobbyDependent)
	end
	ISteamMatchmaking.set_linked_lobby = ISteamMatchmaking.SetLinkedLobby

	return ISteamMatchmaking
end

--
-- ISteamMatchmakingServerListResponse (no version, user created: true)
--

local ISteamMatchmakingServerListResponse = {}
M.ISteamMatchmakingServerListResponse = ISteamMatchmakingServerListResponse

do
	safe_cdef("ISteamMatchmakingServerListResponse", [[
		typedef struct _ISteamMatchmakingServerListResponse {
			void* vtbl;
			struct {
				void(__thiscall* ServerResponded)(void*, void *, int);
				void(__thiscall* ServerFailedToRespond)(void*, void *, int);
				void(__thiscall* RefreshComplete)(void*, void *, int);
			} vtbl_storage[1];
		} ISteamMatchmakingServerListResponse;
	]])

	local callback_base_array  = typeof("struct _ISteamMatchmakingServerListResponse[1]")
	local callback_base_ptr    = typeof("struct _ISteamMatchmakingServerListResponse*")

	local registered_user_callbacks
	local vtbl_callbacks
	local instances = {}

	function ISteamMatchmakingServerListResponse.new(user_callbacks)
		if type(user_callbacks) ~= "table" then
			return error("Invalid user_callbacks, expected table", 2)
		end

		if vtbl_callbacks == nil then
			registered_user_callbacks = {ServerResponded={},ServerFailedToRespond={},RefreshComplete={}}
			vtbl_callbacks = {
				ServerResponded = cast(typeof("void(__thiscall*)(void*, void *, int)"), get_user_interface_callback_handler(registered_user_callbacks["ServerResponded"])),
				ServerFailedToRespond = cast(typeof("void(__thiscall*)(void*, void *, int)"), get_user_interface_callback_handler(registered_user_callbacks["ServerFailedToRespond"])),
				RefreshComplete = cast(typeof("void(__thiscall*)(void*, void *, int)"), get_user_interface_callback_handler(registered_user_callbacks["RefreshComplete"]))
			}
		end

		for key, value in pairs(user_callbacks) do
			if vtbl_callbacks[key] == nil then
				return error("Unknown callback: " .. tostring(key), 2)
			elseif type(value) ~= "function" then
				return error(string_format("Invalid callback type for %s: %s", tostring(key), type(value)), 2)
			end
		end

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)
		local instance_key = pointer_key(instance)

		for key, value in pairs(vtbl_callbacks) do
			if user_callbacks[key] ~= nil then
				registered_user_callbacks[key][instance_key] = user_callbacks[key]
			end
		end

		for key, value in pairs(vtbl_callbacks) do
			instance.vtbl_storage[0][key] = value
		end

		instance.vtbl = instance.vtbl_storage
		instances[instance_key] = instance_storage

		return instance
	end
end

--
-- ISteamMatchmakingPingResponse (no version, user created: true)
--

local ISteamMatchmakingPingResponse = {}
M.ISteamMatchmakingPingResponse = ISteamMatchmakingPingResponse

do
	safe_cdef("ISteamMatchmakingPingResponse", [[
		typedef struct _ISteamMatchmakingPingResponse {
			void* vtbl;
			struct {
				void(__thiscall* ServerResponded)(void*, gameserveritem_t &);
				void(__thiscall* ServerFailedToRespond)(void*);
			} vtbl_storage[1];
		} ISteamMatchmakingPingResponse;
	]])

	local callback_base_array  = typeof("struct _ISteamMatchmakingPingResponse[1]")
	local callback_base_ptr    = typeof("struct _ISteamMatchmakingPingResponse*")

	local registered_user_callbacks
	local vtbl_callbacks
	local instances = {}

	function ISteamMatchmakingPingResponse.new(user_callbacks)
		if type(user_callbacks) ~= "table" then
			return error("Invalid user_callbacks, expected table", 2)
		end

		if vtbl_callbacks == nil then
			registered_user_callbacks = {ServerResponded={},ServerFailedToRespond={}}
			vtbl_callbacks = {
				ServerResponded = cast(typeof("void(__thiscall*)(void*, gameserveritem_t &)"), get_user_interface_callback_handler(registered_user_callbacks["ServerResponded"])),
				ServerFailedToRespond = cast(typeof("void(__thiscall*)(void*)"), get_user_interface_callback_handler(registered_user_callbacks["ServerFailedToRespond"]))
			}
		end

		for key, value in pairs(user_callbacks) do
			if vtbl_callbacks[key] == nil then
				return error("Unknown callback: " .. tostring(key), 2)
			elseif type(value) ~= "function" then
				return error(string_format("Invalid callback type for %s: %s", tostring(key), type(value)), 2)
			end
		end

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)
		local instance_key = pointer_key(instance)

		for key, value in pairs(vtbl_callbacks) do
			if user_callbacks[key] ~= nil then
				registered_user_callbacks[key][instance_key] = user_callbacks[key]
			end
		end

		for key, value in pairs(vtbl_callbacks) do
			instance.vtbl_storage[0][key] = value
		end

		instance.vtbl = instance.vtbl_storage
		instances[instance_key] = instance_storage

		return instance
	end
end

--
-- ISteamMatchmakingPlayersResponse (no version, user created: true)
--

local ISteamMatchmakingPlayersResponse = {}
M.ISteamMatchmakingPlayersResponse = ISteamMatchmakingPlayersResponse

do
	safe_cdef("ISteamMatchmakingPlayersResponse", [[
		typedef struct _ISteamMatchmakingPlayersResponse {
			void* vtbl;
			struct {
				void(__thiscall* AddPlayerToList)(void*, const char *, int, float);
				void(__thiscall* PlayersFailedToRespond)(void*);
				void(__thiscall* PlayersRefreshComplete)(void*);
			} vtbl_storage[1];
		} ISteamMatchmakingPlayersResponse;
	]])

	local callback_base_array  = typeof("struct _ISteamMatchmakingPlayersResponse[1]")
	local callback_base_ptr    = typeof("struct _ISteamMatchmakingPlayersResponse*")

	local registered_user_callbacks
	local vtbl_callbacks
	local instances = {}

	function ISteamMatchmakingPlayersResponse.new(user_callbacks)
		if type(user_callbacks) ~= "table" then
			return error("Invalid user_callbacks, expected table", 2)
		end

		if vtbl_callbacks == nil then
			registered_user_callbacks = {AddPlayerToList={},PlayersFailedToRespond={},PlayersRefreshComplete={}}
			vtbl_callbacks = {
				AddPlayerToList = cast(typeof("void(__thiscall*)(void*, const char *, int, float)"), get_user_interface_callback_handler(registered_user_callbacks["AddPlayerToList"])),
				PlayersFailedToRespond = cast(typeof("void(__thiscall*)(void*)"), get_user_interface_callback_handler(registered_user_callbacks["PlayersFailedToRespond"])),
				PlayersRefreshComplete = cast(typeof("void(__thiscall*)(void*)"), get_user_interface_callback_handler(registered_user_callbacks["PlayersRefreshComplete"]))
			}
		end

		for key, value in pairs(user_callbacks) do
			if vtbl_callbacks[key] == nil then
				return error("Unknown callback: " .. tostring(key), 2)
			elseif type(value) ~= "function" then
				return error(string_format("Invalid callback type for %s: %s", tostring(key), type(value)), 2)
			end
		end

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)
		local instance_key = pointer_key(instance)

		for key, value in pairs(vtbl_callbacks) do
			if user_callbacks[key] ~= nil then
				registered_user_callbacks[key][instance_key] = user_callbacks[key]
			end
		end

		for key, value in pairs(vtbl_callbacks) do
			instance.vtbl_storage[0][key] = value
		end

		instance.vtbl = instance.vtbl_storage
		instances[instance_key] = instance_storage

		return instance
	end
end

--
-- ISteamMatchmakingRulesResponse (no version, user created: true)
--

local ISteamMatchmakingRulesResponse = {}
M.ISteamMatchmakingRulesResponse = ISteamMatchmakingRulesResponse

do
	safe_cdef("ISteamMatchmakingRulesResponse", [[
		typedef struct _ISteamMatchmakingRulesResponse {
			void* vtbl;
			struct {
				void(__thiscall* RulesResponded)(void*, const char *, const char *);
				void(__thiscall* RulesFailedToRespond)(void*);
				void(__thiscall* RulesRefreshComplete)(void*);
			} vtbl_storage[1];
		} ISteamMatchmakingRulesResponse;
	]])

	local callback_base_array  = typeof("struct _ISteamMatchmakingRulesResponse[1]")
	local callback_base_ptr    = typeof("struct _ISteamMatchmakingRulesResponse*")

	local registered_user_callbacks
	local vtbl_callbacks
	local instances = {}

	function ISteamMatchmakingRulesResponse.new(user_callbacks)
		if type(user_callbacks) ~= "table" then
			return error("Invalid user_callbacks, expected table", 2)
		end

		if vtbl_callbacks == nil then
			registered_user_callbacks = {RulesResponded={},RulesFailedToRespond={},RulesRefreshComplete={}}
			vtbl_callbacks = {
				RulesResponded = cast(typeof("void(__thiscall*)(void*, const char *, const char *)"), get_user_interface_callback_handler(registered_user_callbacks["RulesResponded"])),
				RulesFailedToRespond = cast(typeof("void(__thiscall*)(void*)"), get_user_interface_callback_handler(registered_user_callbacks["RulesFailedToRespond"])),
				RulesRefreshComplete = cast(typeof("void(__thiscall*)(void*)"), get_user_interface_callback_handler(registered_user_callbacks["RulesRefreshComplete"]))
			}
		end

		for key, value in pairs(user_callbacks) do
			if vtbl_callbacks[key] == nil then
				return error("Unknown callback: " .. tostring(key), 2)
			elseif type(value) ~= "function" then
				return error(string_format("Invalid callback type for %s: %s", tostring(key), type(value)), 2)
			end
		end

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)
		local instance_key = pointer_key(instance)

		for key, value in pairs(vtbl_callbacks) do
			if user_callbacks[key] ~= nil then
				registered_user_callbacks[key][instance_key] = user_callbacks[key]
			end
		end

		for key, value in pairs(vtbl_callbacks) do
			instance.vtbl_storage[0][key] = value
		end

		instance.vtbl = instance.vtbl_storage
		instances[instance_key] = instance_storage

		return instance
	end
end

--
-- ISteamMatchmakingServers (SteamMatchMakingServers002, user created: false)
--

local ISteamMatchmakingServers = {version="SteamMatchMakingServers002",version_number=2}

index_funcs.ISteamMatchmakingServers = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 11, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamMatchMakingServers002")

	local RequestInternetServerList_native = vtable_entry(this, 0, "void *(__thiscall*)(void*, unsigned int, MatchMakingKeyValuePair_t **, uint32_t, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestInternetServerList(iApp, ppchFilters, nFilters, pRequestServersResponse)
		return RequestInternetServerList_native(this, iApp, ppchFilters, nFilters, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_internet_server_list = ISteamMatchmakingServers.RequestInternetServerList

	local RequestLANServerList_native = vtable_entry(this, 1, "void *(__thiscall*)(void*, unsigned int, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestLANServerList(iApp, pRequestServersResponse)
		return RequestLANServerList_native(this, iApp, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_lan_server_list = ISteamMatchmakingServers.RequestLANServerList

	local RequestFriendsServerList_native = vtable_entry(this, 2, "void *(__thiscall*)(void*, unsigned int, MatchMakingKeyValuePair_t **, uint32_t, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestFriendsServerList(iApp, ppchFilters, nFilters, pRequestServersResponse)
		return RequestFriendsServerList_native(this, iApp, ppchFilters, nFilters, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_friends_server_list = ISteamMatchmakingServers.RequestFriendsServerList

	local RequestFavoritesServerList_native = vtable_entry(this, 3, "void *(__thiscall*)(void*, unsigned int, MatchMakingKeyValuePair_t **, uint32_t, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestFavoritesServerList(iApp, ppchFilters, nFilters, pRequestServersResponse)
		return RequestFavoritesServerList_native(this, iApp, ppchFilters, nFilters, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_favorites_server_list = ISteamMatchmakingServers.RequestFavoritesServerList

	local RequestHistoryServerList_native = vtable_entry(this, 4, "void *(__thiscall*)(void*, unsigned int, MatchMakingKeyValuePair_t **, uint32_t, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestHistoryServerList(iApp, ppchFilters, nFilters, pRequestServersResponse)
		return RequestHistoryServerList_native(this, iApp, ppchFilters, nFilters, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_history_server_list = ISteamMatchmakingServers.RequestHistoryServerList

	local RequestSpectatorServerList_native = vtable_entry(this, 5, "void *(__thiscall*)(void*, unsigned int, MatchMakingKeyValuePair_t **, uint32_t, ISteamMatchmakingServerListResponse *)")
	function ISteamMatchmakingServers.RequestSpectatorServerList(iApp, ppchFilters, nFilters, pRequestServersResponse)
		return RequestSpectatorServerList_native(this, iApp, ppchFilters, nFilters, pRequestServersResponse)
	end
	ISteamMatchmakingServers.request_spectator_server_list = ISteamMatchmakingServers.RequestSpectatorServerList

	local ReleaseRequest_native = vtable_entry(this, 6, "void(__thiscall*)(void*, void *)")
	function ISteamMatchmakingServers.ReleaseRequest(hServerListRequest)
		return ReleaseRequest_native(this, hServerListRequest)
	end
	ISteamMatchmakingServers.release_request = ISteamMatchmakingServers.ReleaseRequest

	local GetServerDetails_native = vtable_entry(this, 7, "gameserveritem_t *(__thiscall*)(void*, void *, int)")
	function ISteamMatchmakingServers.GetServerDetails(hRequest, iServer)
		return GetServerDetails_native(this, hRequest, iServer)
	end
	ISteamMatchmakingServers.get_server_details = ISteamMatchmakingServers.GetServerDetails

	local CancelQuery_native = vtable_entry(this, 8, "void(__thiscall*)(void*, void *)")
	function ISteamMatchmakingServers.CancelQuery(hRequest)
		return CancelQuery_native(this, hRequest)
	end
	ISteamMatchmakingServers.cancel_query = ISteamMatchmakingServers.CancelQuery

	local RefreshQuery_native = vtable_entry(this, 9, "void(__thiscall*)(void*, void *)")
	function ISteamMatchmakingServers.RefreshQuery(hRequest)
		return RefreshQuery_native(this, hRequest)
	end
	ISteamMatchmakingServers.refresh_query = ISteamMatchmakingServers.RefreshQuery

	local IsRefreshing_native = vtable_entry(this, 10, "bool(__thiscall*)(void*, void *)")
	function ISteamMatchmakingServers.IsRefreshing(hRequest)
		return IsRefreshing_native(this, hRequest)
	end
	ISteamMatchmakingServers.is_refreshing = ISteamMatchmakingServers.IsRefreshing

	local GetServerCount_native = vtable_entry(this, 11, "int(__thiscall*)(void*, void *)")
	function ISteamMatchmakingServers.GetServerCount(hRequest)
		return GetServerCount_native(this, hRequest)
	end
	ISteamMatchmakingServers.get_server_count = ISteamMatchmakingServers.GetServerCount

	local RefreshServer_native = vtable_entry(this, 12, "void(__thiscall*)(void*, void *, int)")
	function ISteamMatchmakingServers.RefreshServer(hRequest, iServer)
		return RefreshServer_native(this, hRequest, iServer)
	end
	ISteamMatchmakingServers.refresh_server = ISteamMatchmakingServers.RefreshServer

	local PingServer_native = vtable_entry(this, 13, "int(__thiscall*)(void*, uint32_t, uint16_t, ISteamMatchmakingPingResponse *)")
	function ISteamMatchmakingServers.PingServer(unIP, usPort, pRequestServersResponse)
		unIP = to_ip_int_required(unIP, "ip is required")
		return PingServer_native(this, unIP, usPort, pRequestServersResponse)
	end
	ISteamMatchmakingServers.ping_server = ISteamMatchmakingServers.PingServer

	local PlayerDetails_native = vtable_entry(this, 14, "int(__thiscall*)(void*, uint32_t, uint16_t, ISteamMatchmakingPlayersResponse *)")
	function ISteamMatchmakingServers.PlayerDetails(unIP, usPort, pRequestServersResponse)
		unIP = to_ip_int_required(unIP, "ip is required")
		return PlayerDetails_native(this, unIP, usPort, pRequestServersResponse)
	end
	ISteamMatchmakingServers.player_details = ISteamMatchmakingServers.PlayerDetails

	local ServerRules_native = vtable_entry(this, 15, "int(__thiscall*)(void*, uint32_t, uint16_t, ISteamMatchmakingRulesResponse *)")
	function ISteamMatchmakingServers.ServerRules(unIP, usPort, pRequestServersResponse)
		unIP = to_ip_int_required(unIP, "ip is required")
		return ServerRules_native(this, unIP, usPort, pRequestServersResponse)
	end
	ISteamMatchmakingServers.server_rules = ISteamMatchmakingServers.ServerRules

	local CancelServerQuery_native = vtable_entry(this, 16, "void(__thiscall*)(void*, int)")
	function ISteamMatchmakingServers.CancelServerQuery(hServerQuery)
		return CancelServerQuery_native(this, hServerQuery)
	end
	ISteamMatchmakingServers.cancel_server_query = ISteamMatchmakingServers.CancelServerQuery

	return ISteamMatchmakingServers
end

--
-- ISteamUserStats (STEAMUSERSTATS_INTERFACE_VERSION012, user created: false)
--

local ISteamUserStats = {version="STEAMUSERSTATS_INTERFACE_VERSION012",version_number=12}

index_funcs.ISteamUserStats = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 13, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMUSERSTATS_INTERFACE_VERSION012")

	local RequestCurrentStats_native = vtable_entry(this, 0, "bool(__thiscall*)(void*)")
	function ISteamUserStats.RequestCurrentStats()
		return RequestCurrentStats_native(this)
	end
	ISteamUserStats.request_current_stats = ISteamUserStats.RequestCurrentStats

	local GetStatInt32_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, const char *, int32_t *)")
	function ISteamUserStats.GetStatInt32(pchName)
		local pData_out = new_int32_arr()
		local res = GetStatInt32_native(this, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_stat_int32 = ISteamUserStats.GetStatInt32

	local GetStatFloat_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, const char *, float *)")
	function ISteamUserStats.GetStatFloat(pchName)
		local pData_out = new_float_arr()
		local res = GetStatFloat_native(this, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_stat_float = ISteamUserStats.GetStatFloat

	local SetStatInt32_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, const char *, int32_t)")
	function ISteamUserStats.SetStatInt32(pchName, nData)
		return SetStatInt32_native(this, pchName, nData)
	end
	ISteamUserStats.set_stat_int32 = ISteamUserStats.SetStatInt32

	local SetStatFloat_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, const char *, float)")
	function ISteamUserStats.SetStatFloat(pchName, fData)
		return SetStatFloat_native(this, pchName, fData)
	end
	ISteamUserStats.set_stat_float = ISteamUserStats.SetStatFloat

	local UpdateAvgRateStat_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, const char *, float, double)")
	function ISteamUserStats.UpdateAvgRateStat(pchName, flCountThisSession, dSessionLength)
		return UpdateAvgRateStat_native(this, pchName, flCountThisSession, dSessionLength)
	end
	ISteamUserStats.update_avg_rate_stat = ISteamUserStats.UpdateAvgRateStat

	local GetAchievement_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, const char *, bool *)")
	function ISteamUserStats.GetAchievement(pchName)
		local pbAchieved_out = new_bool_arr()
		local res = GetAchievement_native(this, pchName, pbAchieved_out)

		return res, DEREF_GCSAFE(pbAchieved_out)
	end
	ISteamUserStats.get_achievement = ISteamUserStats.GetAchievement

	local SetAchievement_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, const char *)")
	function ISteamUserStats.SetAchievement(pchName)
		return SetAchievement_native(this, pchName)
	end
	ISteamUserStats.set_achievement = ISteamUserStats.SetAchievement

	local ClearAchievement_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, const char *)")
	function ISteamUserStats.ClearAchievement(pchName)
		return ClearAchievement_native(this, pchName)
	end
	ISteamUserStats.clear_achievement = ISteamUserStats.ClearAchievement

	local GetAchievementAndUnlockTime_native = vtable_entry(this, 9, "bool(__thiscall*)(void*, const char *, bool *, uint32_t *)")
	function ISteamUserStats.GetAchievementAndUnlockTime(pchName)
		local pbAchieved_out = new_bool_arr()
		local punUnlockTime_out = new_uint32_arr()
		local res = GetAchievementAndUnlockTime_native(this, pchName, pbAchieved_out, punUnlockTime_out)

		return res, DEREF_GCSAFE(pbAchieved_out), DEREF_GCSAFE(punUnlockTime_out)
	end
	ISteamUserStats.get_achievement_and_unlock_time = ISteamUserStats.GetAchievementAndUnlockTime

	local StoreStats_native = vtable_entry(this, 10, "bool(__thiscall*)(void*)")
	function ISteamUserStats.StoreStats()
		return StoreStats_native(this)
	end
	ISteamUserStats.store_stats = ISteamUserStats.StoreStats

	local GetAchievementIcon_native = vtable_entry(this, 11, "int(__thiscall*)(void*, const char *)")
	function ISteamUserStats.GetAchievementIcon(pchName)
		return GetAchievementIcon_native(this, pchName)
	end
	ISteamUserStats.get_achievement_icon = ISteamUserStats.GetAchievementIcon

	local GetAchievementDisplayAttribute_native = vtable_entry(this, 12, "const char *(__thiscall*)(void*, const char *, const char *)")
	function ISteamUserStats.GetAchievementDisplayAttribute(pchName, pchKey)
		local res = GetAchievementDisplayAttribute_native(this, pchName, pchKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamUserStats.get_achievement_display_attribute = ISteamUserStats.GetAchievementDisplayAttribute

	local IndicateAchievementProgress_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, const char *, uint32_t, uint32_t)")
	function ISteamUserStats.IndicateAchievementProgress(pchName, nCurProgress, nMaxProgress)
		return IndicateAchievementProgress_native(this, pchName, nCurProgress, nMaxProgress)
	end
	ISteamUserStats.indicate_achievement_progress = ISteamUserStats.IndicateAchievementProgress

	local GetNumAchievements_native = vtable_entry(this, 14, "uint32_t(__thiscall*)(void*)")
	function ISteamUserStats.GetNumAchievements()
		return GetNumAchievements_native(this)
	end
	ISteamUserStats.get_num_achievements = ISteamUserStats.GetNumAchievements

	local GetAchievementName_native = vtable_entry(this, 15, "const char *(__thiscall*)(void*, uint32_t)")
	function ISteamUserStats.GetAchievementName(iAchievement)
		local res = GetAchievementName_native(this, iAchievement)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamUserStats.get_achievement_name = ISteamUserStats.GetAchievementName

	local RequestUserStats_native = vtable_entry(this, 16, "uint64_t(__thiscall*)(void*, SteamID)")
	local RequestUserStats_info = {
		struct = typeof([[
			struct {
				uint64_t m_nGameID;
				int m_eResult;
				SteamID m_steamIDUser;
			} *
		]]),
		keys = {m_nGameID="game_id",m_eResult="result",m_steamIDUser="steamid_user"}
	}
	function ISteamUserStats.RequestUserStats(steamIDUser, callback)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestUserStats_native(this, steamIDUser)

		if callback ~= nil then
			res = register_call_result(res, callback, 1101, RequestUserStats_info)
		end

		return res
	end
	ISteamUserStats.request_user_stats = ISteamUserStats.RequestUserStats

	local GetUserStatInt32_native = vtable_entry(this, 17, "bool(__thiscall*)(void*, SteamID, const char *, int32_t *)")
	function ISteamUserStats.GetUserStatInt32(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pData_out = new_int32_arr()
		local res = GetUserStatInt32_native(this, steamIDUser, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_user_stat_int32 = ISteamUserStats.GetUserStatInt32

	local GetUserStatFloat_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, SteamID, const char *, float *)")
	function ISteamUserStats.GetUserStatFloat(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pData_out = new_float_arr()
		local res = GetUserStatFloat_native(this, steamIDUser, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_user_stat_float = ISteamUserStats.GetUserStatFloat

	local GetUserAchievement_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, SteamID, const char *, bool *)")
	function ISteamUserStats.GetUserAchievement(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pbAchieved_out = new_bool_arr()
		local res = GetUserAchievement_native(this, steamIDUser, pchName, pbAchieved_out)

		return res, DEREF_GCSAFE(pbAchieved_out)
	end
	ISteamUserStats.get_user_achievement = ISteamUserStats.GetUserAchievement

	local GetUserAchievementAndUnlockTime_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, SteamID, const char *, bool *, uint32_t *)")
	function ISteamUserStats.GetUserAchievementAndUnlockTime(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pbAchieved_out = new_bool_arr()
		local punUnlockTime_out = new_uint32_arr()
		local res = GetUserAchievementAndUnlockTime_native(this, steamIDUser, pchName, pbAchieved_out, punUnlockTime_out)

		return res, DEREF_GCSAFE(pbAchieved_out), DEREF_GCSAFE(punUnlockTime_out)
	end
	ISteamUserStats.get_user_achievement_and_unlock_time = ISteamUserStats.GetUserAchievementAndUnlockTime

	local ResetAllStats_native = vtable_entry(this, 21, "bool(__thiscall*)(void*, bool)")
	function ISteamUserStats.ResetAllStats(bAchievementsToo)
		return ResetAllStats_native(this, bAchievementsToo)
	end
	ISteamUserStats.reset_all_stats = ISteamUserStats.ResetAllStats

	local FindOrCreateLeaderboard_native = vtable_entry(this, 22, "uint64_t(__thiscall*)(void*, const char *, int, int)")
	local FindOrCreateLeaderboard_info = {
		struct = typeof([[
			struct {
				uint64_t m_hSteamLeaderboard;
				bool m_bLeaderboardFound;
			} *
		]]),
		keys = {m_hSteamLeaderboard="steam_leaderboard",m_bLeaderboardFound="leaderboard_found"}
	}
	function ISteamUserStats.FindOrCreateLeaderboard(pchLeaderboardName, eLeaderboardSortMethod, eLeaderboardDisplayType, callback)
		eLeaderboardSortMethod = to_enum_required(eLeaderboardSortMethod, enums.ELeaderboardSortMethod, "leaderboard_sort_method is required")
		eLeaderboardDisplayType = to_enum_required(eLeaderboardDisplayType, enums.ELeaderboardDisplayType, "leaderboard_display_type is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = FindOrCreateLeaderboard_native(this, pchLeaderboardName, eLeaderboardSortMethod, eLeaderboardDisplayType)

		if callback ~= nil then
			res = register_call_result(res, callback, 1104, FindOrCreateLeaderboard_info)
		end

		return res
	end
	ISteamUserStats.find_or_create_leaderboard = ISteamUserStats.FindOrCreateLeaderboard

	local FindLeaderboard_native = vtable_entry(this, 23, "uint64_t(__thiscall*)(void*, const char *)")
	local FindLeaderboard_info = {
		struct = typeof([[
			struct {
				uint64_t m_hSteamLeaderboard;
				bool m_bLeaderboardFound;
			} *
		]]),
		keys = {m_hSteamLeaderboard="steam_leaderboard",m_bLeaderboardFound="leaderboard_found"}
	}
	function ISteamUserStats.FindLeaderboard(pchLeaderboardName, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = FindLeaderboard_native(this, pchLeaderboardName)

		if callback ~= nil then
			res = register_call_result(res, callback, 1104, FindLeaderboard_info)
		end

		return res
	end
	ISteamUserStats.find_leaderboard = ISteamUserStats.FindLeaderboard

	local GetLeaderboardName_native = vtable_entry(this, 24, "const char *(__thiscall*)(void*, uint64_t)")
	function ISteamUserStats.GetLeaderboardName(hSteamLeaderboard)
		local res = GetLeaderboardName_native(this, hSteamLeaderboard)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamUserStats.get_leaderboard_name = ISteamUserStats.GetLeaderboardName

	local GetLeaderboardEntryCount_native = vtable_entry(this, 25, "int(__thiscall*)(void*, uint64_t)")
	function ISteamUserStats.GetLeaderboardEntryCount(hSteamLeaderboard)
		return GetLeaderboardEntryCount_native(this, hSteamLeaderboard)
	end
	ISteamUserStats.get_leaderboard_entry_count = ISteamUserStats.GetLeaderboardEntryCount

	local GetLeaderboardSortMethod_native = vtable_entry(this, 26, "int(__thiscall*)(void*, uint64_t)")
	function ISteamUserStats.GetLeaderboardSortMethod(hSteamLeaderboard)
		return GetLeaderboardSortMethod_native(this, hSteamLeaderboard)
	end
	ISteamUserStats.get_leaderboard_sort_method = ISteamUserStats.GetLeaderboardSortMethod

	local GetLeaderboardDisplayType_native = vtable_entry(this, 27, "int(__thiscall*)(void*, uint64_t)")
	function ISteamUserStats.GetLeaderboardDisplayType(hSteamLeaderboard)
		return GetLeaderboardDisplayType_native(this, hSteamLeaderboard)
	end
	ISteamUserStats.get_leaderboard_display_type = ISteamUserStats.GetLeaderboardDisplayType

	local DownloadLeaderboardEntries_native = vtable_entry(this, 28, "uint64_t(__thiscall*)(void*, uint64_t, int, int, int)")
	local DownloadLeaderboardEntries_info = {
		struct = typeof([[
			struct {
				uint64_t m_hSteamLeaderboard;
				uint64_t m_hSteamLeaderboardEntries;
				int m_cEntryCount;
			} *
		]]),
		keys = {m_hSteamLeaderboard="steam_leaderboard",m_hSteamLeaderboardEntries="steam_leaderboard_entries",m_cEntryCount="entry_count"}
	}
	function ISteamUserStats.DownloadLeaderboardEntries(hSteamLeaderboard, eLeaderboardDataRequest, nRangeStart, nRangeEnd, callback)
		eLeaderboardDataRequest = to_enum_required(eLeaderboardDataRequest, enums.ELeaderboardDataRequest, "leaderboard_data_request is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = DownloadLeaderboardEntries_native(this, hSteamLeaderboard, eLeaderboardDataRequest, nRangeStart, nRangeEnd)

		if callback ~= nil then
			res = register_call_result(res, callback, 1105, DownloadLeaderboardEntries_info)
		end

		return res
	end
	ISteamUserStats.download_leaderboard_entries = ISteamUserStats.DownloadLeaderboardEntries

	local DownloadLeaderboardEntriesForUsers_native = vtable_entry(this, 29, "uint64_t(__thiscall*)(void*, uint64_t, SteamID *, int)")
	local DownloadLeaderboardEntriesForUsers_info = {
		struct = typeof([[
			struct {
				uint64_t m_hSteamLeaderboard;
				uint64_t m_hSteamLeaderboardEntries;
				int m_cEntryCount;
			} *
		]]),
		keys = {m_hSteamLeaderboard="steam_leaderboard",m_hSteamLeaderboardEntries="steam_leaderboard_entries",m_cEntryCount="entry_count"}
	}
	function ISteamUserStats.DownloadLeaderboardEntriesForUsers(hSteamLeaderboard, prgUsers, cUsers, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = DownloadLeaderboardEntriesForUsers_native(this, hSteamLeaderboard, prgUsers, cUsers)

		if callback ~= nil then
			res = register_call_result(res, callback, 1105, DownloadLeaderboardEntriesForUsers_info)
		end

		return res
	end
	ISteamUserStats.download_leaderboard_entries_for_users = ISteamUserStats.DownloadLeaderboardEntriesForUsers

	local GetDownloadedLeaderboardEntry_native = vtable_entry(this, 30, "bool(__thiscall*)(void*, uint64_t, int, LeaderboardEntry_t *, int32_t *, int)")
	function ISteamUserStats.GetDownloadedLeaderboardEntry(hSteamLeaderboardEntries, index, pDetails, cDetailsMax)
		local pLeaderboardEntry_out = structs.LeaderboardEntry_t_arr(1)
		local res = GetDownloadedLeaderboardEntry_native(this, hSteamLeaderboardEntries, index, pLeaderboardEntry_out, pDetails, cDetailsMax)

		return res, DEREF_GCSAFE(pLeaderboardEntry_out)
	end
	ISteamUserStats.get_downloaded_leaderboard_entry = ISteamUserStats.GetDownloadedLeaderboardEntry

	local UploadLeaderboardScore_native = vtable_entry(this, 31, "uint64_t(__thiscall*)(void*, uint64_t, int, int32_t, const int32_t *, int)")
	local UploadLeaderboardScore_info = {
		struct = typeof([[
			struct {
				bool m_bSuccess;
				uint64_t m_hSteamLeaderboard;
				int32_t m_nScore;
				bool m_bScoreChanged;
				int m_nGlobalRankNew;
				int m_nGlobalRankPrevious;
			} *
		]]),
		keys = {m_bSuccess="success",m_hSteamLeaderboard="steam_leaderboard",m_nScore="score",m_bScoreChanged="score_changed",m_nGlobalRankNew="global_rank_new",m_nGlobalRankPrevious="global_rank_previous"}
	}
	function ISteamUserStats.UploadLeaderboardScore(hSteamLeaderboard, eLeaderboardUploadScoreMethod, nScore, pScoreDetails, cScoreDetailsCount, callback)
		eLeaderboardUploadScoreMethod = to_enum_required(eLeaderboardUploadScoreMethod, enums.ELeaderboardUploadScoreMethod, "leaderboard_upload_score_method is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = UploadLeaderboardScore_native(this, hSteamLeaderboard, eLeaderboardUploadScoreMethod, nScore, pScoreDetails, cScoreDetailsCount)

		if callback ~= nil then
			res = register_call_result(res, callback, 1106, UploadLeaderboardScore_info)
		end

		return res
	end
	ISteamUserStats.upload_leaderboard_score = ISteamUserStats.UploadLeaderboardScore

	local AttachLeaderboardUGC_native = vtable_entry(this, 32, "uint64_t(__thiscall*)(void*, uint64_t, uint64_t)")
	local AttachLeaderboardUGC_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				uint64_t m_hSteamLeaderboard;
			} *
		]]),
		keys = {m_eResult="result",m_hSteamLeaderboard="steam_leaderboard"}
	}
	function ISteamUserStats.AttachLeaderboardUGC(hSteamLeaderboard, hUGC, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = AttachLeaderboardUGC_native(this, hSteamLeaderboard, hUGC)

		if callback ~= nil then
			res = register_call_result(res, callback, 1111, AttachLeaderboardUGC_info)
		end

		return res
	end
	ISteamUserStats.attach_leaderboard_ugc = ISteamUserStats.AttachLeaderboardUGC

	local GetNumberOfCurrentPlayers_native = vtable_entry(this, 33, "uint64_t(__thiscall*)(void*)")
	local GetNumberOfCurrentPlayers_info = {
		struct = typeof([[
			struct {
				bool m_bSuccess;
				int32_t m_cPlayers;
			} *
		]]),
		keys = {m_bSuccess="success",m_cPlayers="players"}
	}
	function ISteamUserStats.GetNumberOfCurrentPlayers(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = GetNumberOfCurrentPlayers_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 1107, GetNumberOfCurrentPlayers_info)
		end

		return res
	end
	ISteamUserStats.get_number_of_current_players = ISteamUserStats.GetNumberOfCurrentPlayers

	local RequestGlobalAchievementPercentages_native = vtable_entry(this, 34, "uint64_t(__thiscall*)(void*)")
	local RequestGlobalAchievementPercentages_info = {
		struct = typeof([[
			struct {
				uint64_t m_nGameID;
				int m_eResult;
			} *
		]]),
		keys = {m_nGameID="game_id",m_eResult="result"}
	}
	function ISteamUserStats.RequestGlobalAchievementPercentages(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestGlobalAchievementPercentages_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 1110, RequestGlobalAchievementPercentages_info)
		end

		return res
	end
	ISteamUserStats.request_global_achievement_percentages = ISteamUserStats.RequestGlobalAchievementPercentages

	local GetMostAchievedAchievementInfo_native = vtable_entry(this, 35, "int(__thiscall*)(void*, char *, uint32_t, float *, bool *)")
	function ISteamUserStats.GetMostAchievedAchievementInfo(pchName, unNameBufLen)
		local pflPercent_out = new_float_arr()
		local pbAchieved_out = new_bool_arr()
		local res = GetMostAchievedAchievementInfo_native(this, pchName, unNameBufLen, pflPercent_out, pbAchieved_out)

		return res, DEREF_GCSAFE(pflPercent_out), DEREF_GCSAFE(pbAchieved_out)
	end
	ISteamUserStats.get_most_achieved_achievement_info = ISteamUserStats.GetMostAchievedAchievementInfo

	local GetNextMostAchievedAchievementInfo_native = vtable_entry(this, 36, "int(__thiscall*)(void*, int, char *, uint32_t, float *, bool *)")
	function ISteamUserStats.GetNextMostAchievedAchievementInfo(iIteratorPrevious, pchName, unNameBufLen)
		local pflPercent_out = new_float_arr()
		local pbAchieved_out = new_bool_arr()
		local res = GetNextMostAchievedAchievementInfo_native(this, iIteratorPrevious, pchName, unNameBufLen, pflPercent_out, pbAchieved_out)

		return res, DEREF_GCSAFE(pflPercent_out), DEREF_GCSAFE(pbAchieved_out)
	end
	ISteamUserStats.get_next_most_achieved_achievement_info = ISteamUserStats.GetNextMostAchievedAchievementInfo

	local GetAchievementAchievedPercent_native = vtable_entry(this, 37, "bool(__thiscall*)(void*, const char *, float *)")
	function ISteamUserStats.GetAchievementAchievedPercent(pchName)
		local pflPercent_out = new_float_arr()
		local res = GetAchievementAchievedPercent_native(this, pchName, pflPercent_out)

		return res, DEREF_GCSAFE(pflPercent_out)
	end
	ISteamUserStats.get_achievement_achieved_percent = ISteamUserStats.GetAchievementAchievedPercent

	local RequestGlobalStats_native = vtable_entry(this, 38, "uint64_t(__thiscall*)(void*, int)")
	local RequestGlobalStats_info = {
		struct = typeof([[
			struct {
				uint64_t m_nGameID;
				int m_eResult;
			} *
		]]),
		keys = {m_nGameID="game_id",m_eResult="result"}
	}
	function ISteamUserStats.RequestGlobalStats(nHistoryDays, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestGlobalStats_native(this, nHistoryDays)

		if callback ~= nil then
			res = register_call_result(res, callback, 1112, RequestGlobalStats_info)
		end

		return res
	end
	ISteamUserStats.request_global_stats = ISteamUserStats.RequestGlobalStats

	local GetGlobalStatInt64_native = vtable_entry(this, 39, "bool(__thiscall*)(void*, const char *, int64_t *)")
	function ISteamUserStats.GetGlobalStatInt64(pchStatName)
		local pData_out = new_int64_arr()
		local res = GetGlobalStatInt64_native(this, pchStatName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_global_stat_int64 = ISteamUserStats.GetGlobalStatInt64

	local GetGlobalStatDouble_native = vtable_entry(this, 40, "bool(__thiscall*)(void*, const char *, double *)")
	function ISteamUserStats.GetGlobalStatDouble(pchStatName)
		local pData_out = new_double_arr()
		local res = GetGlobalStatDouble_native(this, pchStatName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamUserStats.get_global_stat_double = ISteamUserStats.GetGlobalStatDouble

	local GetGlobalStatHistoryInt64_native = vtable_entry(this, 41, "int32_t(__thiscall*)(void*, const char *, int64_t *, uint32_t)")
	function ISteamUserStats.GetGlobalStatHistoryInt64(pchStatName, pData, cubData)
		return GetGlobalStatHistoryInt64_native(this, pchStatName, pData, cubData)
	end
	ISteamUserStats.get_global_stat_history_int64 = ISteamUserStats.GetGlobalStatHistoryInt64

	local GetGlobalStatHistoryDouble_native = vtable_entry(this, 42, "int32_t(__thiscall*)(void*, const char *, double *, uint32_t)")
	function ISteamUserStats.GetGlobalStatHistoryDouble(pchStatName, pData, cubData)
		return GetGlobalStatHistoryDouble_native(this, pchStatName, pData, cubData)
	end
	ISteamUserStats.get_global_stat_history_double = ISteamUserStats.GetGlobalStatHistoryDouble

	local GetAchievementProgressLimitsInt32_native = vtable_entry(this, 43, "bool(__thiscall*)(void*, const char *, int32_t *, int32_t *)")
	function ISteamUserStats.GetAchievementProgressLimitsInt32(pchName)
		local pnMinProgress_out = new_int32_arr()
		local pnMaxProgress_out = new_int32_arr()
		local res = GetAchievementProgressLimitsInt32_native(this, pchName, pnMinProgress_out, pnMaxProgress_out)

		return res, DEREF_GCSAFE(pnMinProgress_out), DEREF_GCSAFE(pnMaxProgress_out)
	end
	ISteamUserStats.get_achievement_progress_limits_int32 = ISteamUserStats.GetAchievementProgressLimitsInt32

	local GetAchievementProgressLimitsFloat_native = vtable_entry(this, 44, "bool(__thiscall*)(void*, const char *, float *, float *)")
	function ISteamUserStats.GetAchievementProgressLimitsFloat(pchName)
		local pfMinProgress_out = new_float_arr()
		local pfMaxProgress_out = new_float_arr()
		local res = GetAchievementProgressLimitsFloat_native(this, pchName, pfMinProgress_out, pfMaxProgress_out)

		return res, DEREF_GCSAFE(pfMinProgress_out), DEREF_GCSAFE(pfMaxProgress_out)
	end
	ISteamUserStats.get_achievement_progress_limits_float = ISteamUserStats.GetAchievementProgressLimitsFloat

	return ISteamUserStats
end

--
-- ISteamApps (STEAMAPPS_INTERFACE_VERSION008, user created: false)
--

local ISteamApps = {version="STEAMAPPS_INTERFACE_VERSION008",version_number=8}

index_funcs.ISteamApps = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 15, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMAPPS_INTERFACE_VERSION008")

	local BIsSubscribed_native = vtable_entry(this, 0, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsSubscribed()
		return BIsSubscribed_native(this)
	end
	ISteamApps.is_subscribed = ISteamApps.BIsSubscribed

	local BIsLowViolence_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsLowViolence()
		return BIsLowViolence_native(this)
	end
	ISteamApps.is_low_violence = ISteamApps.BIsLowViolence

	local BIsCybercafe_native = vtable_entry(this, 2, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsCybercafe()
		return BIsCybercafe_native(this)
	end
	ISteamApps.is_cybercafe = ISteamApps.BIsCybercafe

	local BIsVACBanned_native = vtable_entry(this, 3, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsVACBanned()
		return BIsVACBanned_native(this)
	end
	ISteamApps.is_vac_banned = ISteamApps.BIsVACBanned

	local GetCurrentGameLanguage_native = vtable_entry(this, 4, "const char *(__thiscall*)(void*)")
	function ISteamApps.GetCurrentGameLanguage()
		local res = GetCurrentGameLanguage_native(this)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamApps.get_current_game_language = ISteamApps.GetCurrentGameLanguage

	local GetAvailableGameLanguages_native = vtable_entry(this, 5, "const char *(__thiscall*)(void*)")
	function ISteamApps.GetAvailableGameLanguages()
		local res = GetAvailableGameLanguages_native(this)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamApps.get_available_game_languages = ISteamApps.GetAvailableGameLanguages

	local BIsSubscribedApp_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamApps.BIsSubscribedApp(appID)
		return BIsSubscribedApp_native(this, appID)
	end
	ISteamApps.is_subscribed_app = ISteamApps.BIsSubscribedApp

	local BIsDlcInstalled_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamApps.BIsDlcInstalled(appID)
		return BIsDlcInstalled_native(this, appID)
	end
	ISteamApps.is_dlc_installed = ISteamApps.BIsDlcInstalled

	local GetEarliestPurchaseUnixTime_native = vtable_entry(this, 8, "uint32_t(__thiscall*)(void*, unsigned int)")
	function ISteamApps.GetEarliestPurchaseUnixTime(nAppID)
		return GetEarliestPurchaseUnixTime_native(this, nAppID)
	end
	ISteamApps.get_earliest_purchase_unix_time = ISteamApps.GetEarliestPurchaseUnixTime

	local BIsSubscribedFromFreeWeekend_native = vtable_entry(this, 9, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsSubscribedFromFreeWeekend()
		return BIsSubscribedFromFreeWeekend_native(this)
	end
	ISteamApps.is_subscribed_from_free_weekend = ISteamApps.BIsSubscribedFromFreeWeekend

	local GetDLCCount_native = vtable_entry(this, 10, "int(__thiscall*)(void*)")
	function ISteamApps.GetDLCCount()
		return GetDLCCount_native(this)
	end
	ISteamApps.get_dlc_count = ISteamApps.GetDLCCount

	local BGetDLCDataByIndex_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, int, unsigned int *, bool *, char *, int)")
	function ISteamApps.BGetDLCDataByIndex(iDLC, pchName, cchNameBufferSize)
		local pAppID_out = new_unsigned_int_arr()
		local pbAvailable_out = new_bool_arr()
		local res = BGetDLCDataByIndex_native(this, iDLC, pAppID_out, pbAvailable_out, pchName, cchNameBufferSize)

		return res, DEREF_GCSAFE(pAppID_out), DEREF_GCSAFE(pbAvailable_out)
	end
	ISteamApps.get_dlc_data_by_index = ISteamApps.BGetDLCDataByIndex

	local InstallDLC_native = vtable_entry(this, 12, "void(__thiscall*)(void*, unsigned int)")
	function ISteamApps.InstallDLC(nAppID)
		return InstallDLC_native(this, nAppID)
	end
	ISteamApps.install_dlc = ISteamApps.InstallDLC

	local UninstallDLC_native = vtable_entry(this, 13, "void(__thiscall*)(void*, unsigned int)")
	function ISteamApps.UninstallDLC(nAppID)
		return UninstallDLC_native(this, nAppID)
	end
	ISteamApps.uninstall_dlc = ISteamApps.UninstallDLC

	local RequestAppProofOfPurchaseKey_native = vtable_entry(this, 14, "void(__thiscall*)(void*, unsigned int)")
	function ISteamApps.RequestAppProofOfPurchaseKey(nAppID)
		return RequestAppProofOfPurchaseKey_native(this, nAppID)
	end
	ISteamApps.request_app_proof_of_purchase_key = ISteamApps.RequestAppProofOfPurchaseKey

	local GetCurrentBetaName_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, char *, int)")
	function ISteamApps.GetCurrentBetaName(pchName, cchNameBufferSize)
		return GetCurrentBetaName_native(this, pchName, cchNameBufferSize)
	end
	ISteamApps.get_current_beta_name = ISteamApps.GetCurrentBetaName

	local MarkContentCorrupt_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, bool)")
	function ISteamApps.MarkContentCorrupt(bMissingFilesOnly)
		return MarkContentCorrupt_native(this, bMissingFilesOnly)
	end
	ISteamApps.mark_content_corrupt = ISteamApps.MarkContentCorrupt

	local GetInstalledDepots_native = vtable_entry(this, 17, "uint32_t(__thiscall*)(void*, unsigned int, unsigned int *, uint32_t)")
	function ISteamApps.GetInstalledDepots(appID, pvecDepots, cMaxDepots)
		return GetInstalledDepots_native(this, appID, pvecDepots, cMaxDepots)
	end
	ISteamApps.get_installed_depots = ISteamApps.GetInstalledDepots

	local GetAppInstallDir_native = vtable_entry(this, 18, "uint32_t(__thiscall*)(void*, unsigned int, char *, uint32_t)")
	function ISteamApps.GetAppInstallDir(appID, pchFolder, cchFolderBufferSize)
		return GetAppInstallDir_native(this, appID, pchFolder, cchFolderBufferSize)
	end
	ISteamApps.get_app_install_dir = ISteamApps.GetAppInstallDir

	local BIsAppInstalled_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamApps.BIsAppInstalled(appID)
		return BIsAppInstalled_native(this, appID)
	end
	ISteamApps.is_app_installed = ISteamApps.BIsAppInstalled

	local GetAppOwner_native = vtable_entry(this, 20, "void(__thiscall*)(void*, SteamID *)")
	function ISteamApps.GetAppOwner()
		local CSteamID_out = new_SteamID_arr()
		GetAppOwner_native(this, CSteamID_out)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamApps.get_app_owner = ISteamApps.GetAppOwner

	local GetLaunchQueryParam_native = vtable_entry(this, 21, "const char *(__thiscall*)(void*, const char *)")
	function ISteamApps.GetLaunchQueryParam(pchKey)
		local res = GetLaunchQueryParam_native(this, pchKey)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamApps.get_launch_query_param = ISteamApps.GetLaunchQueryParam

	local GetDlcDownloadProgress_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, unsigned int, uint64_t *, uint64_t *)")
	function ISteamApps.GetDlcDownloadProgress(nAppID)
		local punBytesDownloaded_out = new_uint64_arr()
		local punBytesTotal_out = new_uint64_arr()
		local res = GetDlcDownloadProgress_native(this, nAppID, punBytesDownloaded_out, punBytesTotal_out)

		return res, DEREF_GCSAFE(punBytesDownloaded_out), DEREF_GCSAFE(punBytesTotal_out)
	end
	ISteamApps.get_dlc_download_progress = ISteamApps.GetDlcDownloadProgress

	local GetAppBuildId_native = vtable_entry(this, 23, "int(__thiscall*)(void*)")
	function ISteamApps.GetAppBuildId()
		return GetAppBuildId_native(this)
	end
	ISteamApps.get_app_build_id = ISteamApps.GetAppBuildId

	local RequestAllProofOfPurchaseKeys_native = vtable_entry(this, 24, "void(__thiscall*)(void*)")
	function ISteamApps.RequestAllProofOfPurchaseKeys()
		return RequestAllProofOfPurchaseKeys_native(this)
	end
	ISteamApps.request_all_proof_of_purchase_keys = ISteamApps.RequestAllProofOfPurchaseKeys

	local GetFileDetails_native = vtable_entry(this, 25, "uint64_t(__thiscall*)(void*, const char *)")
	local GetFileDetails_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				uint64_t m_ulFileSize;
				uint8_t m_FileSHA[20];
				uint32_t m_unFlags;
			} *
		]]),
		keys = {m_eResult="result",m_ulFileSize="file_size",m_FileSHA="file_sha",m_unFlags="flags"}
	}
	function ISteamApps.GetFileDetails(pszFileName, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = GetFileDetails_native(this, pszFileName)

		if callback ~= nil then
			res = register_call_result(res, callback, 1023, GetFileDetails_info)
		end

		return res
	end
	ISteamApps.get_file_details = ISteamApps.GetFileDetails

	local GetLaunchCommandLine_native = vtable_entry(this, 26, "int(__thiscall*)(void*, char *, int)")
	function ISteamApps.GetLaunchCommandLine(pszCommandLine, cubCommandLine)
		return GetLaunchCommandLine_native(this, pszCommandLine, cubCommandLine)
	end
	ISteamApps.get_launch_command_line = ISteamApps.GetLaunchCommandLine

	local BIsSubscribedFromFamilySharing_native = vtable_entry(this, 27, "bool(__thiscall*)(void*)")
	function ISteamApps.BIsSubscribedFromFamilySharing()
		return BIsSubscribedFromFamilySharing_native(this)
	end
	ISteamApps.is_subscribed_from_family_sharing = ISteamApps.BIsSubscribedFromFamilySharing

	local BIsTimedTrial_native = vtable_entry(this, 28, "bool(__thiscall*)(void*, uint32_t *, uint32_t *)")
	function ISteamApps.BIsTimedTrial()
		local punSecondsAllowed_out = new_uint32_arr()
		local punSecondsPlayed_out = new_uint32_arr()
		local res = BIsTimedTrial_native(this, punSecondsAllowed_out, punSecondsPlayed_out)

		return res, DEREF_GCSAFE(punSecondsAllowed_out), DEREF_GCSAFE(punSecondsPlayed_out)
	end
	ISteamApps.is_timed_trial = ISteamApps.BIsTimedTrial

	return ISteamApps
end

--
-- ISteamNetworking (SteamNetworking006, user created: false)
--

local ISteamNetworking = {version="SteamNetworking006",version_number=6}

index_funcs.ISteamNetworking = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 16, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamNetworking006")

	local SendP2PPacket_native = vtable_entry(this, 0, "bool(__thiscall*)(void*, SteamID, const void *, uint32_t, int, int)")
	function ISteamNetworking.SendP2PPacket(steamIDRemote, pubData, cubData, eP2PSendType, nChannel)
		steamIDRemote = to_steamid_required(steamIDRemote, "steamid_remote is required")
		eP2PSendType = to_enum_required(eP2PSendType, enums.EP2PSend, "p2p_send_type is required")
		return SendP2PPacket_native(this, steamIDRemote, pubData, cubData, eP2PSendType, nChannel)
	end
	ISteamNetworking.send_p2p_packet = ISteamNetworking.SendP2PPacket

	local IsP2PPacketAvailable_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, uint32_t *, int)")
	function ISteamNetworking.IsP2PPacketAvailable(nChannel)
		local pcubMsgSize_out = new_uint32_arr()
		local res = IsP2PPacketAvailable_native(this, pcubMsgSize_out, nChannel)

		return res, DEREF_GCSAFE(pcubMsgSize_out)
	end
	ISteamNetworking.is_p2p_packet_available = ISteamNetworking.IsP2PPacketAvailable

	local ReadP2PPacket_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, void *, uint32_t, uint32_t *, SteamID *, int)")
	function ISteamNetworking.ReadP2PPacket(pubDest, cubDest, psteamIDRemote, nChannel)
		local pcubMsgSize_out = new_uint32_arr()
		local res = ReadP2PPacket_native(this, pubDest, cubDest, pcubMsgSize_out, psteamIDRemote, nChannel)

		return res, DEREF_GCSAFE(pcubMsgSize_out)
	end
	ISteamNetworking.read_p2p_packet = ISteamNetworking.ReadP2PPacket

	local AcceptP2PSessionWithUser_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, SteamID)")
	function ISteamNetworking.AcceptP2PSessionWithUser(steamIDRemote)
		steamIDRemote = to_steamid_required(steamIDRemote, "steamid_remote is required")
		return AcceptP2PSessionWithUser_native(this, steamIDRemote)
	end
	ISteamNetworking.accept_p2p_session_with_user = ISteamNetworking.AcceptP2PSessionWithUser

	local CloseP2PSessionWithUser_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, SteamID)")
	function ISteamNetworking.CloseP2PSessionWithUser(steamIDRemote)
		steamIDRemote = to_steamid_required(steamIDRemote, "steamid_remote is required")
		return CloseP2PSessionWithUser_native(this, steamIDRemote)
	end
	ISteamNetworking.close_p2p_session_with_user = ISteamNetworking.CloseP2PSessionWithUser

	local CloseP2PChannelWithUser_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, SteamID, int)")
	function ISteamNetworking.CloseP2PChannelWithUser(steamIDRemote, nChannel)
		steamIDRemote = to_steamid_required(steamIDRemote, "steamid_remote is required")
		return CloseP2PChannelWithUser_native(this, steamIDRemote, nChannel)
	end
	ISteamNetworking.close_p2p_channel_with_user = ISteamNetworking.CloseP2PChannelWithUser

	local GetP2PSessionState_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, SteamID, P2PSessionState_t *)")
	function ISteamNetworking.GetP2PSessionState(steamIDRemote)
		steamIDRemote = to_steamid_required(steamIDRemote, "steamid_remote is required")
		local pConnectionState_out = structs.P2PSessionState_t_arr(1)
		local res = GetP2PSessionState_native(this, steamIDRemote, pConnectionState_out)

		return res, DEREF_GCSAFE(pConnectionState_out)
	end
	ISteamNetworking.get_p2p_session_state = ISteamNetworking.GetP2PSessionState

	local AllowP2PPacketRelay_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, bool)")
	function ISteamNetworking.AllowP2PPacketRelay(bAllow)
		return AllowP2PPacketRelay_native(this, bAllow)
	end
	ISteamNetworking.allow_p2p_packet_relay = ISteamNetworking.AllowP2PPacketRelay

	local CreateListenSocket_native = vtable_entry(this, 8, "unsigned int(__thiscall*)(void*, int, SteamIPAddress_t, uint16_t, bool)")
	function ISteamNetworking.CreateListenSocket(nVirtualP2PPort, nIP, nPort, bAllowUseOfPacketRelay)
		return CreateListenSocket_native(this, nVirtualP2PPort, nIP, nPort, bAllowUseOfPacketRelay)
	end
	ISteamNetworking.create_listen_socket = ISteamNetworking.CreateListenSocket

	local CreateP2PConnectionSocket_native = vtable_entry(this, 9, "unsigned int(__thiscall*)(void*, SteamID, int, int, bool)")
	function ISteamNetworking.CreateP2PConnectionSocket(steamIDTarget, nVirtualPort, nTimeoutSec, bAllowUseOfPacketRelay)
		steamIDTarget = to_steamid_required(steamIDTarget, "steamid_target is required")
		return CreateP2PConnectionSocket_native(this, steamIDTarget, nVirtualPort, nTimeoutSec, bAllowUseOfPacketRelay)
	end
	ISteamNetworking.create_p2p_connection_socket = ISteamNetworking.CreateP2PConnectionSocket

	local CreateConnectionSocket_native = vtable_entry(this, 10, "unsigned int(__thiscall*)(void*, SteamIPAddress_t, uint16_t, int)")
	function ISteamNetworking.CreateConnectionSocket(nIP, nPort, nTimeoutSec)
		return CreateConnectionSocket_native(this, nIP, nPort, nTimeoutSec)
	end
	ISteamNetworking.create_connection_socket = ISteamNetworking.CreateConnectionSocket

	local DestroySocket_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, unsigned int, bool)")
	function ISteamNetworking.DestroySocket(hSocket, bNotifyRemoteEnd)
		return DestroySocket_native(this, hSocket, bNotifyRemoteEnd)
	end
	ISteamNetworking.destroy_socket = ISteamNetworking.DestroySocket

	local DestroyListenSocket_native = vtable_entry(this, 12, "bool(__thiscall*)(void*, unsigned int, bool)")
	function ISteamNetworking.DestroyListenSocket(hSocket, bNotifyRemoteEnd)
		return DestroyListenSocket_native(this, hSocket, bNotifyRemoteEnd)
	end
	ISteamNetworking.destroy_listen_socket = ISteamNetworking.DestroyListenSocket

	local SendDataOnSocket_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, unsigned int, void *, uint32_t, bool)")
	function ISteamNetworking.SendDataOnSocket(hSocket, pubData, cubData, bReliable)
		return SendDataOnSocket_native(this, hSocket, pubData, cubData, bReliable)
	end
	ISteamNetworking.send_data_on_socket = ISteamNetworking.SendDataOnSocket

	local IsDataAvailableOnSocket_native = vtable_entry(this, 14, "bool(__thiscall*)(void*, unsigned int, uint32_t *)")
	function ISteamNetworking.IsDataAvailableOnSocket(hSocket)
		local pcubMsgSize_out = new_uint32_arr()
		local res = IsDataAvailableOnSocket_native(this, hSocket, pcubMsgSize_out)

		return res, DEREF_GCSAFE(pcubMsgSize_out)
	end
	ISteamNetworking.is_data_available_on_socket = ISteamNetworking.IsDataAvailableOnSocket

	local RetrieveDataFromSocket_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, unsigned int, void *, uint32_t, uint32_t *)")
	function ISteamNetworking.RetrieveDataFromSocket(hSocket, pubDest, cubDest)
		local pcubMsgSize_out = new_uint32_arr()
		local res = RetrieveDataFromSocket_native(this, hSocket, pubDest, cubDest, pcubMsgSize_out)

		return res, DEREF_GCSAFE(pcubMsgSize_out)
	end
	ISteamNetworking.retrieve_data_from_socket = ISteamNetworking.RetrieveDataFromSocket

	local IsDataAvailable_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, unsigned int, uint32_t *, unsigned int *)")
	function ISteamNetworking.IsDataAvailable(hListenSocket)
		local pcubMsgSize_out = new_uint32_arr()
		local phSocket_out = new_unsigned_int_arr()
		local res = IsDataAvailable_native(this, hListenSocket, pcubMsgSize_out, phSocket_out)

		return res, DEREF_GCSAFE(pcubMsgSize_out), DEREF_GCSAFE(phSocket_out)
	end
	ISteamNetworking.is_data_available = ISteamNetworking.IsDataAvailable

	local RetrieveData_native = vtable_entry(this, 17, "bool(__thiscall*)(void*, unsigned int, void *, uint32_t, uint32_t *, unsigned int *)")
	function ISteamNetworking.RetrieveData(hListenSocket, pubDest, cubDest)
		local pcubMsgSize_out = new_uint32_arr()
		local phSocket_out = new_unsigned_int_arr()
		local res = RetrieveData_native(this, hListenSocket, pubDest, cubDest, pcubMsgSize_out, phSocket_out)

		return res, DEREF_GCSAFE(pcubMsgSize_out), DEREF_GCSAFE(phSocket_out)
	end
	ISteamNetworking.retrieve_data = ISteamNetworking.RetrieveData

	local GetSocketInfo_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, unsigned int, SteamID *, int *, SteamIPAddress_t *, uint16_t *)")
	function ISteamNetworking.GetSocketInfo(hSocket, pSteamIDRemote)
		local peSocketStatus_out = new_int_arr()
		local punIPRemote_out = structs.SteamIPAddress_t_arr(1)
		local punPortRemote_out = new_uint16_arr()
		local res = GetSocketInfo_native(this, hSocket, pSteamIDRemote, peSocketStatus_out, punIPRemote_out, punPortRemote_out)

		return res, DEREF_GCSAFE(peSocketStatus_out), DEREF_GCSAFE(punIPRemote_out), DEREF_GCSAFE(punPortRemote_out)
	end
	ISteamNetworking.get_socket_info = ISteamNetworking.GetSocketInfo

	local GetListenSocketInfo_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, unsigned int, SteamIPAddress_t *, uint16_t *)")
	function ISteamNetworking.GetListenSocketInfo(hListenSocket)
		local pnIP_out = structs.SteamIPAddress_t_arr(1)
		local pnPort_out = new_uint16_arr()
		local res = GetListenSocketInfo_native(this, hListenSocket, pnIP_out, pnPort_out)

		return res, DEREF_GCSAFE(pnIP_out), DEREF_GCSAFE(pnPort_out)
	end
	ISteamNetworking.get_listen_socket_info = ISteamNetworking.GetListenSocketInfo

	local GetSocketConnectionType_native = vtable_entry(this, 20, "int(__thiscall*)(void*, unsigned int)")
	function ISteamNetworking.GetSocketConnectionType(hSocket)
		return GetSocketConnectionType_native(this, hSocket)
	end
	ISteamNetworking.get_socket_connection_type = ISteamNetworking.GetSocketConnectionType

	local GetMaxPacketSize_native = vtable_entry(this, 21, "int(__thiscall*)(void*, unsigned int)")
	function ISteamNetworking.GetMaxPacketSize(hSocket)
		return GetMaxPacketSize_native(this, hSocket)
	end
	ISteamNetworking.get_max_packet_size = ISteamNetworking.GetMaxPacketSize

	return ISteamNetworking
end

--
-- ISteamScreenshots (STEAMSCREENSHOTS_INTERFACE_VERSION003, user created: false)
--

local ISteamScreenshots = {version="STEAMSCREENSHOTS_INTERFACE_VERSION003",version_number=3}

index_funcs.ISteamScreenshots = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 18, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMSCREENSHOTS_INTERFACE_VERSION003")

	local WriteScreenshot_native = vtable_entry(this, 0, "unsigned int(__thiscall*)(void*, void *, uint32_t, int, int)")
	function ISteamScreenshots.WriteScreenshot(pubRGB, cubRGB, nWidth, nHeight)
		return WriteScreenshot_native(this, pubRGB, cubRGB, nWidth, nHeight)
	end
	ISteamScreenshots.write_screenshot = ISteamScreenshots.WriteScreenshot

	local AddScreenshotToLibrary_native = vtable_entry(this, 1, "unsigned int(__thiscall*)(void*, const char *, const char *, int, int)")
	function ISteamScreenshots.AddScreenshotToLibrary(pchFilename, pchThumbnailFilename, nWidth, nHeight)
		return AddScreenshotToLibrary_native(this, pchFilename, pchThumbnailFilename, nWidth, nHeight)
	end
	ISteamScreenshots.add_screenshot_to_library = ISteamScreenshots.AddScreenshotToLibrary

	local TriggerScreenshot_native = vtable_entry(this, 2, "void(__thiscall*)(void*)")
	function ISteamScreenshots.TriggerScreenshot()
		return TriggerScreenshot_native(this)
	end
	ISteamScreenshots.trigger_screenshot = ISteamScreenshots.TriggerScreenshot

	local HookScreenshots_native = vtable_entry(this, 3, "void(__thiscall*)(void*, bool)")
	function ISteamScreenshots.HookScreenshots(bHook)
		return HookScreenshots_native(this, bHook)
	end
	ISteamScreenshots.hook_screenshots = ISteamScreenshots.HookScreenshots

	local SetLocation_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, unsigned int, const char *)")
	function ISteamScreenshots.SetLocation(hScreenshot, pchLocation)
		return SetLocation_native(this, hScreenshot, pchLocation)
	end
	ISteamScreenshots.set_location = ISteamScreenshots.SetLocation

	local TagUser_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, unsigned int, SteamID)")
	function ISteamScreenshots.TagUser(hScreenshot, steamID)
		steamID = to_steamid_required(steamID, "steamid is required")
		return TagUser_native(this, hScreenshot, steamID)
	end
	ISteamScreenshots.tag_user = ISteamScreenshots.TagUser

	local TagPublishedFile_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, unsigned int, uint64_t)")
	function ISteamScreenshots.TagPublishedFile(hScreenshot, unPublishedFileID)
		return TagPublishedFile_native(this, hScreenshot, unPublishedFileID)
	end
	ISteamScreenshots.tag_published_file = ISteamScreenshots.TagPublishedFile

	local IsScreenshotsHooked_native = vtable_entry(this, 7, "bool(__thiscall*)(void*)")
	function ISteamScreenshots.IsScreenshotsHooked()
		return IsScreenshotsHooked_native(this)
	end
	ISteamScreenshots.is_screenshots_hooked = ISteamScreenshots.IsScreenshotsHooked

	local AddVRScreenshotToLibrary_native = vtable_entry(this, 8, "unsigned int(__thiscall*)(void*, int, const char *, const char *)")
	function ISteamScreenshots.AddVRScreenshotToLibrary(eType, pchFilename, pchVRFilename)
		eType = to_enum_required(eType, enums.EVRScreenshotType, "type is required")
		return AddVRScreenshotToLibrary_native(this, eType, pchFilename, pchVRFilename)
	end
	ISteamScreenshots.add_vr_screenshot_to_library = ISteamScreenshots.AddVRScreenshotToLibrary

	return ISteamScreenshots
end

--
-- ISteamMusic (STEAMMUSIC_INTERFACE_VERSION001, user created: false)
--

local ISteamMusic = {version="STEAMMUSIC_INTERFACE_VERSION001",version_number=1}

index_funcs.ISteamMusic = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 29, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMMUSIC_INTERFACE_VERSION001")

	local BIsEnabled_native = vtable_entry(this, 0, "bool(__thiscall*)(void*)")
	function ISteamMusic.BIsEnabled()
		return BIsEnabled_native(this)
	end
	ISteamMusic.is_enabled = ISteamMusic.BIsEnabled

	local BIsPlaying_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamMusic.BIsPlaying()
		return BIsPlaying_native(this)
	end
	ISteamMusic.is_playing = ISteamMusic.BIsPlaying

	local GetPlaybackStatus_native = vtable_entry(this, 2, "int(__thiscall*)(void*)")
	function ISteamMusic.GetPlaybackStatus()
		return GetPlaybackStatus_native(this)
	end
	ISteamMusic.get_playback_status = ISteamMusic.GetPlaybackStatus

	local Play_native = vtable_entry(this, 3, "void(__thiscall*)(void*)")
	function ISteamMusic.Play()
		return Play_native(this)
	end
	ISteamMusic.play = ISteamMusic.Play

	local Pause_native = vtable_entry(this, 4, "void(__thiscall*)(void*)")
	function ISteamMusic.Pause()
		return Pause_native(this)
	end
	ISteamMusic.pause = ISteamMusic.Pause

	local PlayPrevious_native = vtable_entry(this, 5, "void(__thiscall*)(void*)")
	function ISteamMusic.PlayPrevious()
		return PlayPrevious_native(this)
	end
	ISteamMusic.play_previous = ISteamMusic.PlayPrevious

	local PlayNext_native = vtable_entry(this, 6, "void(__thiscall*)(void*)")
	function ISteamMusic.PlayNext()
		return PlayNext_native(this)
	end
	ISteamMusic.play_next = ISteamMusic.PlayNext

	local SetVolume_native = vtable_entry(this, 7, "void(__thiscall*)(void*, float)")
	function ISteamMusic.SetVolume(flVolume)
		return SetVolume_native(this, flVolume)
	end
	ISteamMusic.set_volume = ISteamMusic.SetVolume

	local GetVolume_native = vtable_entry(this, 8, "float(__thiscall*)(void*)")
	function ISteamMusic.GetVolume()
		return GetVolume_native(this)
	end
	ISteamMusic.get_volume = ISteamMusic.GetVolume

	return ISteamMusic
end

--
-- ISteamMusicRemote (STEAMMUSICREMOTE_INTERFACE_VERSION001, user created: false)
--

local ISteamMusicRemote = {version="STEAMMUSICREMOTE_INTERFACE_VERSION001",version_number=1}

index_funcs.ISteamMusicRemote = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 30, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMMUSICREMOTE_INTERFACE_VERSION001")

	local RegisterSteamMusicRemote_native = vtable_entry(this, 0, "bool(__thiscall*)(void*, const char *)")
	function ISteamMusicRemote.RegisterSteamMusicRemote(pchName)
		return RegisterSteamMusicRemote_native(this, pchName)
	end
	ISteamMusicRemote.register_steam_music_remote = ISteamMusicRemote.RegisterSteamMusicRemote

	local DeregisterSteamMusicRemote_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.DeregisterSteamMusicRemote()
		return DeregisterSteamMusicRemote_native(this)
	end
	ISteamMusicRemote.deregister_steam_music_remote = ISteamMusicRemote.DeregisterSteamMusicRemote

	local BIsCurrentMusicRemote_native = vtable_entry(this, 2, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.BIsCurrentMusicRemote()
		return BIsCurrentMusicRemote_native(this)
	end
	ISteamMusicRemote.is_current_music_remote = ISteamMusicRemote.BIsCurrentMusicRemote

	local BActivationSuccess_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.BActivationSuccess(bValue)
		return BActivationSuccess_native(this, bValue)
	end
	ISteamMusicRemote.activation_success = ISteamMusicRemote.BActivationSuccess

	local SetDisplayName_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, const char *)")
	function ISteamMusicRemote.SetDisplayName(pchDisplayName)
		return SetDisplayName_native(this, pchDisplayName)
	end
	ISteamMusicRemote.set_display_name = ISteamMusicRemote.SetDisplayName

	local SetPNGIcon_64x64_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, void *, uint32_t)")
	function ISteamMusicRemote.SetPNGIcon_64x64(pvBuffer, cbBufferLength)
		return SetPNGIcon_64x64_native(this, pvBuffer, cbBufferLength)
	end
	ISteamMusicRemote.set_png_icon_64x64 = ISteamMusicRemote.SetPNGIcon_64x64

	local EnablePlayPrevious_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnablePlayPrevious(bValue)
		return EnablePlayPrevious_native(this, bValue)
	end
	ISteamMusicRemote.enable_play_previous = ISteamMusicRemote.EnablePlayPrevious

	local EnablePlayNext_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnablePlayNext(bValue)
		return EnablePlayNext_native(this, bValue)
	end
	ISteamMusicRemote.enable_play_next = ISteamMusicRemote.EnablePlayNext

	local EnableShuffled_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnableShuffled(bValue)
		return EnableShuffled_native(this, bValue)
	end
	ISteamMusicRemote.enable_shuffled = ISteamMusicRemote.EnableShuffled

	local EnableLooped_native = vtable_entry(this, 9, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnableLooped(bValue)
		return EnableLooped_native(this, bValue)
	end
	ISteamMusicRemote.enable_looped = ISteamMusicRemote.EnableLooped

	local EnableQueue_native = vtable_entry(this, 10, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnableQueue(bValue)
		return EnableQueue_native(this, bValue)
	end
	ISteamMusicRemote.enable_queue = ISteamMusicRemote.EnableQueue

	local EnablePlaylists_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.EnablePlaylists(bValue)
		return EnablePlaylists_native(this, bValue)
	end
	ISteamMusicRemote.enable_playlists = ISteamMusicRemote.EnablePlaylists

	local UpdatePlaybackStatus_native = vtable_entry(this, 12, "bool(__thiscall*)(void*, int)")
	function ISteamMusicRemote.UpdatePlaybackStatus(nStatus)
		nStatus = to_enum_required(nStatus, enums.AudioPlayback_Status, "status is required")
		return UpdatePlaybackStatus_native(this, nStatus)
	end
	ISteamMusicRemote.update_playback_status = ISteamMusicRemote.UpdatePlaybackStatus

	local UpdateShuffled_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.UpdateShuffled(bValue)
		return UpdateShuffled_native(this, bValue)
	end
	ISteamMusicRemote.update_shuffled = ISteamMusicRemote.UpdateShuffled

	local UpdateLooped_native = vtable_entry(this, 14, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.UpdateLooped(bValue)
		return UpdateLooped_native(this, bValue)
	end
	ISteamMusicRemote.update_looped = ISteamMusicRemote.UpdateLooped

	local UpdateVolume_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, float)")
	function ISteamMusicRemote.UpdateVolume(flValue)
		return UpdateVolume_native(this, flValue)
	end
	ISteamMusicRemote.update_volume = ISteamMusicRemote.UpdateVolume

	local CurrentEntryWillChange_native = vtable_entry(this, 16, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.CurrentEntryWillChange()
		return CurrentEntryWillChange_native(this)
	end
	ISteamMusicRemote.current_entry_will_change = ISteamMusicRemote.CurrentEntryWillChange

	local CurrentEntryIsAvailable_native = vtable_entry(this, 17, "bool(__thiscall*)(void*, bool)")
	function ISteamMusicRemote.CurrentEntryIsAvailable(bAvailable)
		return CurrentEntryIsAvailable_native(this, bAvailable)
	end
	ISteamMusicRemote.current_entry_is_available = ISteamMusicRemote.CurrentEntryIsAvailable

	local UpdateCurrentEntryText_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, const char *)")
	function ISteamMusicRemote.UpdateCurrentEntryText(pchText)
		return UpdateCurrentEntryText_native(this, pchText)
	end
	ISteamMusicRemote.update_current_entry_text = ISteamMusicRemote.UpdateCurrentEntryText

	local UpdateCurrentEntryElapsedSeconds_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, int)")
	function ISteamMusicRemote.UpdateCurrentEntryElapsedSeconds(nValue)
		return UpdateCurrentEntryElapsedSeconds_native(this, nValue)
	end
	ISteamMusicRemote.update_current_entry_elapsed_seconds = ISteamMusicRemote.UpdateCurrentEntryElapsedSeconds

	local UpdateCurrentEntryCoverArt_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, void *, uint32_t)")
	function ISteamMusicRemote.UpdateCurrentEntryCoverArt(pvBuffer, cbBufferLength)
		return UpdateCurrentEntryCoverArt_native(this, pvBuffer, cbBufferLength)
	end
	ISteamMusicRemote.update_current_entry_cover_art = ISteamMusicRemote.UpdateCurrentEntryCoverArt

	local CurrentEntryDidChange_native = vtable_entry(this, 21, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.CurrentEntryDidChange()
		return CurrentEntryDidChange_native(this)
	end
	ISteamMusicRemote.current_entry_did_change = ISteamMusicRemote.CurrentEntryDidChange

	local QueueWillChange_native = vtable_entry(this, 22, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.QueueWillChange()
		return QueueWillChange_native(this)
	end
	ISteamMusicRemote.queue_will_change = ISteamMusicRemote.QueueWillChange

	local ResetQueueEntries_native = vtable_entry(this, 23, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.ResetQueueEntries()
		return ResetQueueEntries_native(this)
	end
	ISteamMusicRemote.reset_queue_entries = ISteamMusicRemote.ResetQueueEntries

	local SetQueueEntry_native = vtable_entry(this, 24, "bool(__thiscall*)(void*, int, int, const char *)")
	function ISteamMusicRemote.SetQueueEntry(nID, nPosition, pchEntryText)
		return SetQueueEntry_native(this, nID, nPosition, pchEntryText)
	end
	ISteamMusicRemote.set_queue_entry = ISteamMusicRemote.SetQueueEntry

	local SetCurrentQueueEntry_native = vtable_entry(this, 25, "bool(__thiscall*)(void*, int)")
	function ISteamMusicRemote.SetCurrentQueueEntry(nID)
		return SetCurrentQueueEntry_native(this, nID)
	end
	ISteamMusicRemote.set_current_queue_entry = ISteamMusicRemote.SetCurrentQueueEntry

	local QueueDidChange_native = vtable_entry(this, 26, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.QueueDidChange()
		return QueueDidChange_native(this)
	end
	ISteamMusicRemote.queue_did_change = ISteamMusicRemote.QueueDidChange

	local PlaylistWillChange_native = vtable_entry(this, 27, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.PlaylistWillChange()
		return PlaylistWillChange_native(this)
	end
	ISteamMusicRemote.playlist_will_change = ISteamMusicRemote.PlaylistWillChange

	local ResetPlaylistEntries_native = vtable_entry(this, 28, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.ResetPlaylistEntries()
		return ResetPlaylistEntries_native(this)
	end
	ISteamMusicRemote.reset_playlist_entries = ISteamMusicRemote.ResetPlaylistEntries

	local SetPlaylistEntry_native = vtable_entry(this, 29, "bool(__thiscall*)(void*, int, int, const char *)")
	function ISteamMusicRemote.SetPlaylistEntry(nID, nPosition, pchEntryText)
		return SetPlaylistEntry_native(this, nID, nPosition, pchEntryText)
	end
	ISteamMusicRemote.set_playlist_entry = ISteamMusicRemote.SetPlaylistEntry

	local SetCurrentPlaylistEntry_native = vtable_entry(this, 30, "bool(__thiscall*)(void*, int)")
	function ISteamMusicRemote.SetCurrentPlaylistEntry(nID)
		return SetCurrentPlaylistEntry_native(this, nID)
	end
	ISteamMusicRemote.set_current_playlist_entry = ISteamMusicRemote.SetCurrentPlaylistEntry

	local PlaylistDidChange_native = vtable_entry(this, 31, "bool(__thiscall*)(void*)")
	function ISteamMusicRemote.PlaylistDidChange()
		return PlaylistDidChange_native(this)
	end
	ISteamMusicRemote.playlist_did_change = ISteamMusicRemote.PlaylistDidChange

	return ISteamMusicRemote
end

--
-- ISteamHTTP (STEAMHTTP_INTERFACE_VERSION003, user created: false)
--

local ISteamHTTP = {version="STEAMHTTP_INTERFACE_VERSION003",version_number=3}

index_funcs.ISteamHTTP = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 24, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMHTTP_INTERFACE_VERSION003")

	local CreateHTTPRequest_native = vtable_entry(this, 0, "unsigned int(__thiscall*)(void*, int, const char *)")
	function ISteamHTTP.CreateHTTPRequest(eHTTPRequestMethod, pchAbsoluteURL)
		eHTTPRequestMethod = to_enum_required(eHTTPRequestMethod, enums.EHTTPMethod, "http_request_method is required")
		return CreateHTTPRequest_native(this, eHTTPRequestMethod, pchAbsoluteURL)
	end
	ISteamHTTP.create_http_request = ISteamHTTP.CreateHTTPRequest

	local SetHTTPRequestContextValue_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, unsigned int, uint64_t)")
	function ISteamHTTP.SetHTTPRequestContextValue(hRequest, ulContextValue)
		return SetHTTPRequestContextValue_native(this, hRequest, ulContextValue)
	end
	ISteamHTTP.set_http_request_context_value = ISteamHTTP.SetHTTPRequestContextValue

	local SetHTTPRequestNetworkActivityTimeout_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, unsigned int, uint32_t)")
	function ISteamHTTP.SetHTTPRequestNetworkActivityTimeout(hRequest, unTimeoutSeconds)
		return SetHTTPRequestNetworkActivityTimeout_native(this, hRequest, unTimeoutSeconds)
	end
	ISteamHTTP.set_http_request_network_activity_timeout = ISteamHTTP.SetHTTPRequestNetworkActivityTimeout

	local SetHTTPRequestHeaderValue_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, unsigned int, const char *, const char *)")
	function ISteamHTTP.SetHTTPRequestHeaderValue(hRequest, pchHeaderName, pchHeaderValue)
		return SetHTTPRequestHeaderValue_native(this, hRequest, pchHeaderName, pchHeaderValue)
	end
	ISteamHTTP.set_http_request_header_value = ISteamHTTP.SetHTTPRequestHeaderValue

	local SetHTTPRequestGetOrPostParameter_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, unsigned int, const char *, const char *)")
	function ISteamHTTP.SetHTTPRequestGetOrPostParameter(hRequest, pchParamName, pchParamValue)
		return SetHTTPRequestGetOrPostParameter_native(this, hRequest, pchParamName, pchParamValue)
	end
	ISteamHTTP.set_http_request_get_or_post_parameter = ISteamHTTP.SetHTTPRequestGetOrPostParameter

	local SendHTTPRequest_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, unsigned int, uint64_t *)")
	local SendHTTPRequest_info = {
		struct = typeof([[
			struct {
				unsigned int m_hRequest;
				uint64_t m_ulContextValue;
				bool m_bRequestSuccessful;
				int m_eStatusCode;
				uint32_t m_unBodySize;
			} *
		]]),
		keys = {m_hRequest="request",m_ulContextValue="context_value",m_bRequestSuccessful="request_successful",m_eStatusCode="status_code",m_unBodySize="body_size"}
	}
	function ISteamHTTP.SendHTTPRequest(hRequest, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local pCallHandle_out = new_uint64_arr()
		local res = SendHTTPRequest_native(this, hRequest, pCallHandle_out)

		if callback ~= nil then
			pCallHandle_out = register_call_result(pCallHandle_out, callback, 2101, SendHTTPRequest_info)
		end

		return res, DEREF_GCSAFE(pCallHandle_out)
	end
	ISteamHTTP.send_http_request = ISteamHTTP.SendHTTPRequest

	local SendHTTPRequestAndStreamResponse_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, unsigned int, uint64_t *)")
	local SendHTTPRequestAndStreamResponse_info = {
		struct = typeof([[
			struct {
				unsigned int m_hRequest;
				uint64_t m_ulContextValue;
				bool m_bRequestSuccessful;
				int m_eStatusCode;
				uint32_t m_unBodySize;
			} *
		]]),
		keys = {m_hRequest="request",m_ulContextValue="context_value",m_bRequestSuccessful="request_successful",m_eStatusCode="status_code",m_unBodySize="body_size"}
	}
	function ISteamHTTP.SendHTTPRequestAndStreamResponse(hRequest, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local pCallHandle_out = new_uint64_arr()
		local res = SendHTTPRequestAndStreamResponse_native(this, hRequest, pCallHandle_out)

		if callback ~= nil then
			pCallHandle_out = register_call_result(pCallHandle_out, callback, 2101, SendHTTPRequestAndStreamResponse_info)
		end

		return res, DEREF_GCSAFE(pCallHandle_out)
	end
	ISteamHTTP.send_http_request_and_stream_response = ISteamHTTP.SendHTTPRequestAndStreamResponse

	local DeferHTTPRequest_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamHTTP.DeferHTTPRequest(hRequest)
		return DeferHTTPRequest_native(this, hRequest)
	end
	ISteamHTTP.defer_http_request = ISteamHTTP.DeferHTTPRequest

	local PrioritizeHTTPRequest_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamHTTP.PrioritizeHTTPRequest(hRequest)
		return PrioritizeHTTPRequest_native(this, hRequest)
	end
	ISteamHTTP.prioritize_http_request = ISteamHTTP.PrioritizeHTTPRequest

	local GetHTTPResponseHeaderSize_native = vtable_entry(this, 9, "bool(__thiscall*)(void*, unsigned int, const char *, uint32_t *)")
	function ISteamHTTP.GetHTTPResponseHeaderSize(hRequest, pchHeaderName)
		local unResponseHeaderSize_out = new_uint32_arr()
		local res = GetHTTPResponseHeaderSize_native(this, hRequest, pchHeaderName, unResponseHeaderSize_out)

		return res, DEREF_GCSAFE(unResponseHeaderSize_out)
	end
	ISteamHTTP.get_http_response_header_size = ISteamHTTP.GetHTTPResponseHeaderSize

	local GetHTTPResponseHeaderValue_native = vtable_entry(this, 10, "bool(__thiscall*)(void*, unsigned int, const char *, uint8_t *, uint32_t)")
	function ISteamHTTP.GetHTTPResponseHeaderValue(hRequest, pchHeaderName, pHeaderValueBuffer, unBufferSize)
		return GetHTTPResponseHeaderValue_native(this, hRequest, pchHeaderName, pHeaderValueBuffer, unBufferSize)
	end
	ISteamHTTP.get_http_response_header_value = ISteamHTTP.GetHTTPResponseHeaderValue

	local GetHTTPResponseBodySize_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, unsigned int, uint32_t *)")
	function ISteamHTTP.GetHTTPResponseBodySize(hRequest)
		local unBodySize_out = new_uint32_arr()
		local res = GetHTTPResponseBodySize_native(this, hRequest, unBodySize_out)

		return res, DEREF_GCSAFE(unBodySize_out)
	end
	ISteamHTTP.get_http_response_body_size = ISteamHTTP.GetHTTPResponseBodySize

	local GetHTTPResponseBodyData_native = vtable_entry(this, 12, "bool(__thiscall*)(void*, unsigned int, uint8_t *, uint32_t)")
	function ISteamHTTP.GetHTTPResponseBodyData(hRequest, pBodyDataBuffer, unBufferSize)
		return GetHTTPResponseBodyData_native(this, hRequest, pBodyDataBuffer, unBufferSize)
	end
	ISteamHTTP.get_http_response_body_data = ISteamHTTP.GetHTTPResponseBodyData

	local GetHTTPStreamingResponseBodyData_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, unsigned int, uint32_t, uint8_t *, uint32_t)")
	function ISteamHTTP.GetHTTPStreamingResponseBodyData(hRequest, cOffset, pBodyDataBuffer, unBufferSize)
		return GetHTTPStreamingResponseBodyData_native(this, hRequest, cOffset, pBodyDataBuffer, unBufferSize)
	end
	ISteamHTTP.get_http_streaming_response_body_data = ISteamHTTP.GetHTTPStreamingResponseBodyData

	local ReleaseHTTPRequest_native = vtable_entry(this, 14, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamHTTP.ReleaseHTTPRequest(hRequest)
		return ReleaseHTTPRequest_native(this, hRequest)
	end
	ISteamHTTP.release_http_request = ISteamHTTP.ReleaseHTTPRequest

	local GetHTTPDownloadProgressPct_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, unsigned int, float *)")
	function ISteamHTTP.GetHTTPDownloadProgressPct(hRequest)
		local pflPercentOut_out = new_float_arr()
		local res = GetHTTPDownloadProgressPct_native(this, hRequest, pflPercentOut_out)

		return res, DEREF_GCSAFE(pflPercentOut_out)
	end
	ISteamHTTP.get_http_download_progress_pct = ISteamHTTP.GetHTTPDownloadProgressPct

	local SetHTTPRequestRawPostBody_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, unsigned int, const char *, uint8_t *, uint32_t)")
	function ISteamHTTP.SetHTTPRequestRawPostBody(hRequest, pchContentType, pubBody, unBodyLen)
		return SetHTTPRequestRawPostBody_native(this, hRequest, pchContentType, pubBody, unBodyLen)
	end
	ISteamHTTP.set_http_request_raw_post_body = ISteamHTTP.SetHTTPRequestRawPostBody

	local CreateCookieContainer_native = vtable_entry(this, 17, "unsigned int(__thiscall*)(void*, bool)")
	function ISteamHTTP.CreateCookieContainer(bAllowResponsesToModify)
		return CreateCookieContainer_native(this, bAllowResponsesToModify)
	end
	ISteamHTTP.create_cookie_container = ISteamHTTP.CreateCookieContainer

	local ReleaseCookieContainer_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamHTTP.ReleaseCookieContainer(hCookieContainer)
		return ReleaseCookieContainer_native(this, hCookieContainer)
	end
	ISteamHTTP.release_cookie_container = ISteamHTTP.ReleaseCookieContainer

	local SetCookie_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, unsigned int, const char *, const char *, const char *)")
	function ISteamHTTP.SetCookie(hCookieContainer, pchHost, pchUrl, pchCookie)
		return SetCookie_native(this, hCookieContainer, pchHost, pchUrl, pchCookie)
	end
	ISteamHTTP.set_cookie = ISteamHTTP.SetCookie

	local SetHTTPRequestCookieContainer_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, unsigned int, unsigned int)")
	function ISteamHTTP.SetHTTPRequestCookieContainer(hRequest, hCookieContainer)
		return SetHTTPRequestCookieContainer_native(this, hRequest, hCookieContainer)
	end
	ISteamHTTP.set_http_request_cookie_container = ISteamHTTP.SetHTTPRequestCookieContainer

	local SetHTTPRequestUserAgentInfo_native = vtable_entry(this, 21, "bool(__thiscall*)(void*, unsigned int, const char *)")
	function ISteamHTTP.SetHTTPRequestUserAgentInfo(hRequest, pchUserAgentInfo)
		return SetHTTPRequestUserAgentInfo_native(this, hRequest, pchUserAgentInfo)
	end
	ISteamHTTP.set_http_request_user_agent_info = ISteamHTTP.SetHTTPRequestUserAgentInfo

	local SetHTTPRequestRequiresVerifiedCertificate_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, unsigned int, bool)")
	function ISteamHTTP.SetHTTPRequestRequiresVerifiedCertificate(hRequest, bRequireVerifiedCertificate)
		return SetHTTPRequestRequiresVerifiedCertificate_native(this, hRequest, bRequireVerifiedCertificate)
	end
	ISteamHTTP.set_http_request_requires_verified_certificate = ISteamHTTP.SetHTTPRequestRequiresVerifiedCertificate

	local SetHTTPRequestAbsoluteTimeoutMS_native = vtable_entry(this, 23, "bool(__thiscall*)(void*, unsigned int, uint32_t)")
	function ISteamHTTP.SetHTTPRequestAbsoluteTimeoutMS(hRequest, unMilliseconds)
		return SetHTTPRequestAbsoluteTimeoutMS_native(this, hRequest, unMilliseconds)
	end
	ISteamHTTP.set_http_request_absolute_timeout_ms = ISteamHTTP.SetHTTPRequestAbsoluteTimeoutMS

	local GetHTTPRequestWasTimedOut_native = vtable_entry(this, 24, "bool(__thiscall*)(void*, unsigned int, bool *)")
	function ISteamHTTP.GetHTTPRequestWasTimedOut(hRequest)
		local pbWasTimedOut_out = new_bool_arr()
		local res = GetHTTPRequestWasTimedOut_native(this, hRequest, pbWasTimedOut_out)

		return res, DEREF_GCSAFE(pbWasTimedOut_out)
	end
	ISteamHTTP.get_http_request_was_timed_out = ISteamHTTP.GetHTTPRequestWasTimedOut

	return ISteamHTTP
end

--
-- ISteamHTMLSurface (STEAMHTMLSURFACE_INTERFACE_VERSION_005, user created: false)
--

local ISteamHTMLSurface = {version="STEAMHTMLSURFACE_INTERFACE_VERSION_005",version_number=5}

index_funcs.ISteamHTMLSurface = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 31, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMHTMLSURFACE_INTERFACE_VERSION_005")

	local Init_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamHTMLSurface.Init()
		return Init_native(this)
	end
	ISteamHTMLSurface.init = ISteamHTMLSurface.Init

	local Shutdown_native = vtable_entry(this, 2, "bool(__thiscall*)(void*)")
	function ISteamHTMLSurface.Shutdown()
		return Shutdown_native(this)
	end
	ISteamHTMLSurface.shutdown = ISteamHTMLSurface.Shutdown

	local CreateBrowser_native = vtable_entry(this, 3, "uint64_t(__thiscall*)(void*, const char *, const char *)")
	local CreateBrowser_info = {
		struct = typeof([[
			struct {
				unsigned int unBrowserHandle;
			} *
		]]),
		keys = {unBrowserHandle="browser_handle"}
	}
	function ISteamHTMLSurface.CreateBrowser(pchUserAgent, pchUserCSS, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = CreateBrowser_native(this, pchUserAgent, pchUserCSS)

		if callback ~= nil then
			res = register_call_result(res, callback, 4501, CreateBrowser_info)
		end

		return res
	end
	ISteamHTMLSurface.create_browser = ISteamHTMLSurface.CreateBrowser

	local RemoveBrowser_native = vtable_entry(this, 4, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.RemoveBrowser(unBrowserHandle)
		return RemoveBrowser_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.remove_browser = ISteamHTMLSurface.RemoveBrowser

	local LoadURL_native = vtable_entry(this, 5, "void(__thiscall*)(void*, unsigned int, const char *, const char *)")
	function ISteamHTMLSurface.LoadURL(unBrowserHandle, pchURL, pchPostData)
		return LoadURL_native(this, unBrowserHandle, pchURL, pchPostData)
	end
	ISteamHTMLSurface.load_url = ISteamHTMLSurface.LoadURL

	local SetSize_native = vtable_entry(this, 6, "void(__thiscall*)(void*, unsigned int, uint32_t, uint32_t)")
	function ISteamHTMLSurface.SetSize(unBrowserHandle, unWidth, unHeight)
		return SetSize_native(this, unBrowserHandle, unWidth, unHeight)
	end
	ISteamHTMLSurface.set_size = ISteamHTMLSurface.SetSize

	local StopLoad_native = vtable_entry(this, 7, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.StopLoad(unBrowserHandle)
		return StopLoad_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.stop_load = ISteamHTMLSurface.StopLoad

	local Reload_native = vtable_entry(this, 8, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.Reload(unBrowserHandle)
		return Reload_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.reload = ISteamHTMLSurface.Reload

	local GoBack_native = vtable_entry(this, 9, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.GoBack(unBrowserHandle)
		return GoBack_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.go_back = ISteamHTMLSurface.GoBack

	local GoForward_native = vtable_entry(this, 10, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.GoForward(unBrowserHandle)
		return GoForward_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.go_forward = ISteamHTMLSurface.GoForward

	local AddHeader_native = vtable_entry(this, 11, "void(__thiscall*)(void*, unsigned int, const char *, const char *)")
	function ISteamHTMLSurface.AddHeader(unBrowserHandle, pchKey, pchValue)
		return AddHeader_native(this, unBrowserHandle, pchKey, pchValue)
	end
	ISteamHTMLSurface.add_header = ISteamHTMLSurface.AddHeader

	local ExecuteJavascript_native = vtable_entry(this, 12, "void(__thiscall*)(void*, unsigned int, const char *)")
	function ISteamHTMLSurface.ExecuteJavascript(unBrowserHandle, pchScript)
		return ExecuteJavascript_native(this, unBrowserHandle, pchScript)
	end
	ISteamHTMLSurface.execute_javascript = ISteamHTMLSurface.ExecuteJavascript

	local MouseUp_native = vtable_entry(this, 13, "void(__thiscall*)(void*, unsigned int, int)")
	function ISteamHTMLSurface.MouseUp(unBrowserHandle, eMouseButton)
		eMouseButton = to_enum_required(eMouseButton, enums.EHTMLMouseButton, "mouse_button is required")
		return MouseUp_native(this, unBrowserHandle, eMouseButton)
	end
	ISteamHTMLSurface.mouse_up = ISteamHTMLSurface.MouseUp

	local MouseDown_native = vtable_entry(this, 14, "void(__thiscall*)(void*, unsigned int, int)")
	function ISteamHTMLSurface.MouseDown(unBrowserHandle, eMouseButton)
		eMouseButton = to_enum_required(eMouseButton, enums.EHTMLMouseButton, "mouse_button is required")
		return MouseDown_native(this, unBrowserHandle, eMouseButton)
	end
	ISteamHTMLSurface.mouse_down = ISteamHTMLSurface.MouseDown

	local MouseDoubleClick_native = vtable_entry(this, 15, "void(__thiscall*)(void*, unsigned int, int)")
	function ISteamHTMLSurface.MouseDoubleClick(unBrowserHandle, eMouseButton)
		eMouseButton = to_enum_required(eMouseButton, enums.EHTMLMouseButton, "mouse_button is required")
		return MouseDoubleClick_native(this, unBrowserHandle, eMouseButton)
	end
	ISteamHTMLSurface.mouse_double_click = ISteamHTMLSurface.MouseDoubleClick

	local MouseMove_native = vtable_entry(this, 16, "void(__thiscall*)(void*, unsigned int, int, int)")
	function ISteamHTMLSurface.MouseMove(unBrowserHandle, x, y)
		return MouseMove_native(this, unBrowserHandle, x, y)
	end
	ISteamHTMLSurface.mouse_move = ISteamHTMLSurface.MouseMove

	local MouseWheel_native = vtable_entry(this, 17, "void(__thiscall*)(void*, unsigned int, int32_t)")
	function ISteamHTMLSurface.MouseWheel(unBrowserHandle, nDelta)
		return MouseWheel_native(this, unBrowserHandle, nDelta)
	end
	ISteamHTMLSurface.mouse_wheel = ISteamHTMLSurface.MouseWheel

	local KeyDown_native = vtable_entry(this, 18, "void(__thiscall*)(void*, unsigned int, uint32_t, int, bool)")
	function ISteamHTMLSurface.KeyDown(unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers, bIsSystemKey)
		eHTMLKeyModifiers = to_enum_required(eHTMLKeyModifiers, enums.EHTMLKeyModifiers, "html_key_modifiers is required")
		return KeyDown_native(this, unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers, bIsSystemKey)
	end
	ISteamHTMLSurface.key_down = ISteamHTMLSurface.KeyDown

	local KeyUp_native = vtable_entry(this, 19, "void(__thiscall*)(void*, unsigned int, uint32_t, int)")
	function ISteamHTMLSurface.KeyUp(unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers)
		eHTMLKeyModifiers = to_enum_required(eHTMLKeyModifiers, enums.EHTMLKeyModifiers, "html_key_modifiers is required")
		return KeyUp_native(this, unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers)
	end
	ISteamHTMLSurface.key_up = ISteamHTMLSurface.KeyUp

	local KeyChar_native = vtable_entry(this, 20, "void(__thiscall*)(void*, unsigned int, uint32_t, int)")
	function ISteamHTMLSurface.KeyChar(unBrowserHandle, cUnicodeChar, eHTMLKeyModifiers)
		eHTMLKeyModifiers = to_enum_required(eHTMLKeyModifiers, enums.EHTMLKeyModifiers, "html_key_modifiers is required")
		return KeyChar_native(this, unBrowserHandle, cUnicodeChar, eHTMLKeyModifiers)
	end
	ISteamHTMLSurface.key_char = ISteamHTMLSurface.KeyChar

	local SetHorizontalScroll_native = vtable_entry(this, 21, "void(__thiscall*)(void*, unsigned int, uint32_t)")
	function ISteamHTMLSurface.SetHorizontalScroll(unBrowserHandle, nAbsolutePixelScroll)
		return SetHorizontalScroll_native(this, unBrowserHandle, nAbsolutePixelScroll)
	end
	ISteamHTMLSurface.set_horizontal_scroll = ISteamHTMLSurface.SetHorizontalScroll

	local SetVerticalScroll_native = vtable_entry(this, 22, "void(__thiscall*)(void*, unsigned int, uint32_t)")
	function ISteamHTMLSurface.SetVerticalScroll(unBrowserHandle, nAbsolutePixelScroll)
		return SetVerticalScroll_native(this, unBrowserHandle, nAbsolutePixelScroll)
	end
	ISteamHTMLSurface.set_vertical_scroll = ISteamHTMLSurface.SetVerticalScroll

	local SetKeyFocus_native = vtable_entry(this, 23, "void(__thiscall*)(void*, unsigned int, bool)")
	function ISteamHTMLSurface.SetKeyFocus(unBrowserHandle, bHasKeyFocus)
		return SetKeyFocus_native(this, unBrowserHandle, bHasKeyFocus)
	end
	ISteamHTMLSurface.set_key_focus = ISteamHTMLSurface.SetKeyFocus

	local ViewSource_native = vtable_entry(this, 24, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.ViewSource(unBrowserHandle)
		return ViewSource_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.view_source = ISteamHTMLSurface.ViewSource

	local CopyToClipboard_native = vtable_entry(this, 25, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.CopyToClipboard(unBrowserHandle)
		return CopyToClipboard_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.copy_to_clipboard = ISteamHTMLSurface.CopyToClipboard

	local PasteFromClipboard_native = vtable_entry(this, 26, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.PasteFromClipboard(unBrowserHandle)
		return PasteFromClipboard_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.paste_from_clipboard = ISteamHTMLSurface.PasteFromClipboard

	local Find_native = vtable_entry(this, 27, "void(__thiscall*)(void*, unsigned int, const char *, bool, bool)")
	function ISteamHTMLSurface.Find(unBrowserHandle, pchSearchStr, bCurrentlyInFind, bReverse)
		return Find_native(this, unBrowserHandle, pchSearchStr, bCurrentlyInFind, bReverse)
	end
	ISteamHTMLSurface.find = ISteamHTMLSurface.Find

	local StopFind_native = vtable_entry(this, 28, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.StopFind(unBrowserHandle)
		return StopFind_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.stop_find = ISteamHTMLSurface.StopFind

	local GetLinkAtPosition_native = vtable_entry(this, 29, "void(__thiscall*)(void*, unsigned int, int, int)")
	function ISteamHTMLSurface.GetLinkAtPosition(unBrowserHandle, x, y)
		return GetLinkAtPosition_native(this, unBrowserHandle, x, y)
	end
	ISteamHTMLSurface.get_link_at_position = ISteamHTMLSurface.GetLinkAtPosition

	local SetCookie_native = vtable_entry(this, 30, "void(__thiscall*)(void*, const char *, const char *, const char *, const char *, unsigned int, bool, bool)")
	function ISteamHTMLSurface.SetCookie(pchHostname, pchKey, pchValue, pchPath, nExpires, bSecure, bHTTPOnly)
		return SetCookie_native(this, pchHostname, pchKey, pchValue, pchPath, nExpires, bSecure, bHTTPOnly)
	end
	ISteamHTMLSurface.set_cookie = ISteamHTMLSurface.SetCookie

	local SetPageScaleFactor_native = vtable_entry(this, 31, "void(__thiscall*)(void*, unsigned int, float, int, int)")
	function ISteamHTMLSurface.SetPageScaleFactor(unBrowserHandle, flZoom, nPointX, nPointY)
		return SetPageScaleFactor_native(this, unBrowserHandle, flZoom, nPointX, nPointY)
	end
	ISteamHTMLSurface.set_page_scale_factor = ISteamHTMLSurface.SetPageScaleFactor

	local SetBackgroundMode_native = vtable_entry(this, 32, "void(__thiscall*)(void*, unsigned int, bool)")
	function ISteamHTMLSurface.SetBackgroundMode(unBrowserHandle, bBackgroundMode)
		return SetBackgroundMode_native(this, unBrowserHandle, bBackgroundMode)
	end
	ISteamHTMLSurface.set_background_mode = ISteamHTMLSurface.SetBackgroundMode

	local SetDPIScalingFactor_native = vtable_entry(this, 33, "void(__thiscall*)(void*, unsigned int, float)")
	function ISteamHTMLSurface.SetDPIScalingFactor(unBrowserHandle, flDPIScaling)
		return SetDPIScalingFactor_native(this, unBrowserHandle, flDPIScaling)
	end
	ISteamHTMLSurface.set_dpi_scaling_factor = ISteamHTMLSurface.SetDPIScalingFactor

	local OpenDeveloperTools_native = vtable_entry(this, 34, "void(__thiscall*)(void*, unsigned int)")
	function ISteamHTMLSurface.OpenDeveloperTools(unBrowserHandle)
		return OpenDeveloperTools_native(this, unBrowserHandle)
	end
	ISteamHTMLSurface.open_developer_tools = ISteamHTMLSurface.OpenDeveloperTools

	local AllowStartRequest_native = vtable_entry(this, 35, "void(__thiscall*)(void*, unsigned int, bool)")
	function ISteamHTMLSurface.AllowStartRequest(unBrowserHandle, bAllowed)
		return AllowStartRequest_native(this, unBrowserHandle, bAllowed)
	end
	ISteamHTMLSurface.allow_start_request = ISteamHTMLSurface.AllowStartRequest

	local JSDialogResponse_native = vtable_entry(this, 36, "void(__thiscall*)(void*, unsigned int, bool)")
	function ISteamHTMLSurface.JSDialogResponse(unBrowserHandle, bResult)
		return JSDialogResponse_native(this, unBrowserHandle, bResult)
	end
	ISteamHTMLSurface.js_dialog_response = ISteamHTMLSurface.JSDialogResponse

	local FileLoadDialogResponse_native = vtable_entry(this, 37, "void(__thiscall*)(void*, unsigned int, const char **)")
	function ISteamHTMLSurface.FileLoadDialogResponse(unBrowserHandle, pchSelectedFiles)
		return FileLoadDialogResponse_native(this, unBrowserHandle, pchSelectedFiles)
	end
	ISteamHTMLSurface.file_load_dialog_response = ISteamHTMLSurface.FileLoadDialogResponse

	return ISteamHTMLSurface
end

--
-- ISteamInventory (STEAMINVENTORY_INTERFACE_V003, user created: false)
--

local ISteamInventory = {version="STEAMINVENTORY_INTERFACE_V003",version_number=3}

index_funcs.ISteamInventory = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 35, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMINVENTORY_INTERFACE_V003")

	local GetResultStatus_native = vtable_entry(this, 0, "int(__thiscall*)(void*, int)")
	function ISteamInventory.GetResultStatus(resultHandle)
		return GetResultStatus_native(this, resultHandle)
	end
	ISteamInventory.get_result_status = ISteamInventory.GetResultStatus

	local GetResultItems_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, int, SteamItemDetails_t *, uint32_t *)")
	function ISteamInventory.GetResultItems(resultHandle, pOutItemsArray, punOutItemsArraySize)
		return GetResultItems_native(this, resultHandle, pOutItemsArray, punOutItemsArraySize)
	end
	ISteamInventory.get_result_items = ISteamInventory.GetResultItems

	local GetResultItemProperty_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, int, uint32_t, const char *, char *, uint32_t *)")
	function ISteamInventory.GetResultItemProperty(resultHandle, unItemIndex, pchPropertyName, pchValueBuffer, punValueBufferSizeOut)
		return GetResultItemProperty_native(this, resultHandle, unItemIndex, pchPropertyName, pchValueBuffer, punValueBufferSizeOut)
	end
	ISteamInventory.get_result_item_property = ISteamInventory.GetResultItemProperty

	local GetResultTimestamp_native = vtable_entry(this, 3, "uint32_t(__thiscall*)(void*, int)")
	function ISteamInventory.GetResultTimestamp(resultHandle)
		return GetResultTimestamp_native(this, resultHandle)
	end
	ISteamInventory.get_result_timestamp = ISteamInventory.GetResultTimestamp

	local CheckResultSteamID_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, int, SteamID)")
	function ISteamInventory.CheckResultSteamID(resultHandle, steamIDExpected)
		steamIDExpected = to_steamid_required(steamIDExpected, "steamid_expected is required")
		return CheckResultSteamID_native(this, resultHandle, steamIDExpected)
	end
	ISteamInventory.check_result_steamid = ISteamInventory.CheckResultSteamID

	local DestroyResult_native = vtable_entry(this, 5, "void(__thiscall*)(void*, int)")
	function ISteamInventory.DestroyResult(resultHandle)
		return DestroyResult_native(this, resultHandle)
	end
	ISteamInventory.destroy_result = ISteamInventory.DestroyResult

	local GetAllItems_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, int *)")
	function ISteamInventory.GetAllItems()
		local pResultHandle_out = new_int_arr()
		local res = GetAllItems_native(this, pResultHandle_out)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.get_all_items = ISteamInventory.GetAllItems

	local GetItemsByID_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, int *, const uint64_t *, uint32_t)")
	function ISteamInventory.GetItemsByID(pInstanceIDs, unCountInstanceIDs)
		local pResultHandle_out = new_int_arr()
		local res = GetItemsByID_native(this, pResultHandle_out, pInstanceIDs, unCountInstanceIDs)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.get_items_by_id = ISteamInventory.GetItemsByID

	local SerializeResult_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, int, void *, uint32_t *)")
	function ISteamInventory.SerializeResult(resultHandle, pOutBuffer, punOutBufferSize)
		return SerializeResult_native(this, resultHandle, pOutBuffer, punOutBufferSize)
	end
	ISteamInventory.serialize_result = ISteamInventory.SerializeResult

	local DeserializeResult_native = vtable_entry(this, 9, "bool(__thiscall*)(void*, int *, const void *, uint32_t, bool)")
	function ISteamInventory.DeserializeResult(pBuffer, unBufferSize, bRESERVED_MUST_BE_FALSE)
		local pOutResultHandle_out = new_int_arr()
		local res = DeserializeResult_native(this, pOutResultHandle_out, pBuffer, unBufferSize, bRESERVED_MUST_BE_FALSE)

		return res, DEREF_GCSAFE(pOutResultHandle_out)
	end
	ISteamInventory.deserialize_result = ISteamInventory.DeserializeResult

	local GenerateItems_native = vtable_entry(this, 10, "bool(__thiscall*)(void*, int *, const int *, const uint32_t *, uint32_t)")
	function ISteamInventory.GenerateItems(pArrayItemDefs, punArrayQuantity, unArrayLength)
		local pResultHandle_out = new_int_arr()
		local res = GenerateItems_native(this, pResultHandle_out, pArrayItemDefs, punArrayQuantity, unArrayLength)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.generate_items = ISteamInventory.GenerateItems

	local GrantPromoItems_native = vtable_entry(this, 11, "bool(__thiscall*)(void*, int *)")
	function ISteamInventory.GrantPromoItems()
		local pResultHandle_out = new_int_arr()
		local res = GrantPromoItems_native(this, pResultHandle_out)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.grant_promo_items = ISteamInventory.GrantPromoItems

	local AddPromoItem_native = vtable_entry(this, 12, "bool(__thiscall*)(void*, int *, int)")
	function ISteamInventory.AddPromoItem(itemDef)
		local pResultHandle_out = new_int_arr()
		local res = AddPromoItem_native(this, pResultHandle_out, itemDef)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.add_promo_item = ISteamInventory.AddPromoItem

	local AddPromoItems_native = vtable_entry(this, 13, "bool(__thiscall*)(void*, int *, const int *, uint32_t)")
	function ISteamInventory.AddPromoItems(pArrayItemDefs, unArrayLength)
		local pResultHandle_out = new_int_arr()
		local res = AddPromoItems_native(this, pResultHandle_out, pArrayItemDefs, unArrayLength)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.add_promo_items = ISteamInventory.AddPromoItems

	local ConsumeItem_native = vtable_entry(this, 14, "bool(__thiscall*)(void*, int *, uint64_t, uint32_t)")
	function ISteamInventory.ConsumeItem(itemConsume, unQuantity)
		local pResultHandle_out = new_int_arr()
		local res = ConsumeItem_native(this, pResultHandle_out, itemConsume, unQuantity)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.consume_item = ISteamInventory.ConsumeItem

	local ExchangeItems_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, int *, const int *, const uint32_t *, uint32_t, const uint64_t *, const uint32_t *, uint32_t)")
	function ISteamInventory.ExchangeItems(pArrayGenerate, punArrayGenerateQuantity, unArrayGenerateLength, pArrayDestroy, punArrayDestroyQuantity, unArrayDestroyLength)
		local pResultHandle_out = new_int_arr()
		local res = ExchangeItems_native(this, pResultHandle_out, pArrayGenerate, punArrayGenerateQuantity, unArrayGenerateLength, pArrayDestroy, punArrayDestroyQuantity, unArrayDestroyLength)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.exchange_items = ISteamInventory.ExchangeItems

	local TransferItemQuantity_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, int *, uint64_t, uint32_t, uint64_t)")
	function ISteamInventory.TransferItemQuantity(itemIdSource, unQuantity, itemIdDest)
		local pResultHandle_out = new_int_arr()
		local res = TransferItemQuantity_native(this, pResultHandle_out, itemIdSource, unQuantity, itemIdDest)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.transfer_item_quantity = ISteamInventory.TransferItemQuantity

	local SendItemDropHeartbeat_native = vtable_entry(this, 17, "void(__thiscall*)(void*)")
	function ISteamInventory.SendItemDropHeartbeat()
		return SendItemDropHeartbeat_native(this)
	end
	ISteamInventory.send_item_drop_heartbeat = ISteamInventory.SendItemDropHeartbeat

	local TriggerItemDrop_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, int *, int)")
	function ISteamInventory.TriggerItemDrop(dropListDefinition)
		local pResultHandle_out = new_int_arr()
		local res = TriggerItemDrop_native(this, pResultHandle_out, dropListDefinition)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.trigger_item_drop = ISteamInventory.TriggerItemDrop

	local TradeItems_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, int *, SteamID, const uint64_t *, const uint32_t *, uint32_t, const uint64_t *, const uint32_t *, uint32_t)")
	function ISteamInventory.TradeItems(steamIDTradePartner, pArrayGive, pArrayGiveQuantity, nArrayGiveLength, pArrayGet, pArrayGetQuantity, nArrayGetLength)
		steamIDTradePartner = to_steamid_required(steamIDTradePartner, "steamid_trade_partner is required")
		local pResultHandle_out = new_int_arr()
		local res = TradeItems_native(this, pResultHandle_out, steamIDTradePartner, pArrayGive, pArrayGiveQuantity, nArrayGiveLength, pArrayGet, pArrayGetQuantity, nArrayGetLength)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.trade_items = ISteamInventory.TradeItems

	local LoadItemDefinitions_native = vtable_entry(this, 20, "bool(__thiscall*)(void*)")
	function ISteamInventory.LoadItemDefinitions()
		return LoadItemDefinitions_native(this)
	end
	ISteamInventory.load_item_definitions = ISteamInventory.LoadItemDefinitions

	local GetItemDefinitionIDs_native = vtable_entry(this, 21, "bool(__thiscall*)(void*, int *, uint32_t *)")
	function ISteamInventory.GetItemDefinitionIDs(pItemDefIDs, punItemDefIDsArraySize)
		return GetItemDefinitionIDs_native(this, pItemDefIDs, punItemDefIDsArraySize)
	end
	ISteamInventory.get_item_definition_ids = ISteamInventory.GetItemDefinitionIDs

	local GetItemDefinitionProperty_native = vtable_entry(this, 22, "bool(__thiscall*)(void*, int, const char *, char *, uint32_t *)")
	function ISteamInventory.GetItemDefinitionProperty(iDefinition, pchPropertyName, pchValueBuffer, punValueBufferSizeOut)
		return GetItemDefinitionProperty_native(this, iDefinition, pchPropertyName, pchValueBuffer, punValueBufferSizeOut)
	end
	ISteamInventory.get_item_definition_property = ISteamInventory.GetItemDefinitionProperty

	local RequestEligiblePromoItemDefinitionsIDs_native = vtable_entry(this, 23, "uint64_t(__thiscall*)(void*, SteamID)")
	local RequestEligiblePromoItemDefinitionsIDs_info = {
		struct = typeof([[
			struct {
				int m_result;
				SteamID m_steamID;
				int m_numEligiblePromoItemDefs;
				bool m_bCachedData;
			} *
		]]),
		keys = {m_result="result",m_steamID="steamid",m_numEligiblePromoItemDefs="num_eligible_promo_item_defs",m_bCachedData="cached_data"}
	}
	function ISteamInventory.RequestEligiblePromoItemDefinitionsIDs(steamID, callback)
		steamID = to_steamid_required(steamID, "steamid is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestEligiblePromoItemDefinitionsIDs_native(this, steamID)

		if callback ~= nil then
			res = register_call_result(res, callback, 4703, RequestEligiblePromoItemDefinitionsIDs_info)
		end

		return res
	end
	ISteamInventory.request_eligible_promo_item_definitions_ids = ISteamInventory.RequestEligiblePromoItemDefinitionsIDs

	local GetEligiblePromoItemDefinitionIDs_native = vtable_entry(this, 24, "bool(__thiscall*)(void*, SteamID, int *, uint32_t *)")
	function ISteamInventory.GetEligiblePromoItemDefinitionIDs(steamID, pItemDefIDs, punItemDefIDsArraySize)
		steamID = to_steamid_required(steamID, "steamid is required")
		return GetEligiblePromoItemDefinitionIDs_native(this, steamID, pItemDefIDs, punItemDefIDsArraySize)
	end
	ISteamInventory.get_eligible_promo_item_definition_ids = ISteamInventory.GetEligiblePromoItemDefinitionIDs

	local StartPurchase_native = vtable_entry(this, 25, "uint64_t(__thiscall*)(void*, const int *, const uint32_t *, uint32_t)")
	local StartPurchase_info = {
		struct = typeof([[
			struct {
				int m_result;
				uint64_t m_ulOrderID;
				uint64_t m_ulTransID;
			} *
		]]),
		keys = {m_result="result",m_ulOrderID="order_id",m_ulTransID="trans_id"}
	}
	function ISteamInventory.StartPurchase(pArrayItemDefs, punArrayQuantity, unArrayLength, callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = StartPurchase_native(this, pArrayItemDefs, punArrayQuantity, unArrayLength)

		if callback ~= nil then
			res = register_call_result(res, callback, 4704, StartPurchase_info)
		end

		return res
	end
	ISteamInventory.start_purchase = ISteamInventory.StartPurchase

	local RequestPrices_native = vtable_entry(this, 26, "uint64_t(__thiscall*)(void*)")
	local RequestPrices_info = {
		struct = typeof([[
			struct {
				int m_result;
				char m_rgchCurrency[4];
			} *
		]]),
		keys = {m_result="result",m_rgchCurrency="currency"}
	}
	function ISteamInventory.RequestPrices(callback)
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestPrices_native(this)

		if callback ~= nil then
			res = register_call_result(res, callback, 4705, RequestPrices_info)
		end

		return res
	end
	ISteamInventory.request_prices = ISteamInventory.RequestPrices

	local GetNumItemsWithPrices_native = vtable_entry(this, 27, "uint32_t(__thiscall*)(void*)")
	function ISteamInventory.GetNumItemsWithPrices()
		return GetNumItemsWithPrices_native(this)
	end
	ISteamInventory.get_num_items_with_prices = ISteamInventory.GetNumItemsWithPrices

	local GetItemsWithPrices_native = vtable_entry(this, 28, "bool(__thiscall*)(void*, int *, uint64_t *, uint64_t *, uint32_t)")
	function ISteamInventory.GetItemsWithPrices(pArrayItemDefs, pCurrentPrices, pBasePrices, unArrayLength)
		return GetItemsWithPrices_native(this, pArrayItemDefs, pCurrentPrices, pBasePrices, unArrayLength)
	end
	ISteamInventory.get_items_with_prices = ISteamInventory.GetItemsWithPrices

	local GetItemPrice_native = vtable_entry(this, 29, "bool(__thiscall*)(void*, int, uint64_t *, uint64_t *)")
	function ISteamInventory.GetItemPrice(iDefinition)
		local pCurrentPrice_out = new_uint64_arr()
		local pBasePrice_out = new_uint64_arr()
		local res = GetItemPrice_native(this, iDefinition, pCurrentPrice_out, pBasePrice_out)

		return res, DEREF_GCSAFE(pCurrentPrice_out), DEREF_GCSAFE(pBasePrice_out)
	end
	ISteamInventory.get_item_price = ISteamInventory.GetItemPrice

	local StartUpdateProperties_native = vtable_entry(this, 30, "void(__thiscall*)(void*, uint64_t *)")
	function ISteamInventory.StartUpdateProperties()
		local SteamInventoryUpdateHandle_t_out = new_uint64_arr()
		StartUpdateProperties_native(this, SteamInventoryUpdateHandle_t_out)

		return DEREF_GCSAFE(SteamInventoryUpdateHandle_t_out)
	end
	ISteamInventory.start_update_properties = ISteamInventory.StartUpdateProperties

	local RemoveProperty_native = vtable_entry(this, 31, "bool(__thiscall*)(void*, uint64_t, uint64_t, const char *)")
	function ISteamInventory.RemoveProperty(handle, nItemID, pchPropertyName)
		return RemoveProperty_native(this, handle, nItemID, pchPropertyName)
	end
	ISteamInventory.remove_property = ISteamInventory.RemoveProperty

	local SetPropertyString_native = vtable_entry(this, 32, "bool(__thiscall*)(void*, uint64_t, uint64_t, const char *, const char *)")
	function ISteamInventory.SetPropertyString(handle, nItemID, pchPropertyName, pchPropertyValue)
		return SetPropertyString_native(this, handle, nItemID, pchPropertyName, pchPropertyValue)
	end
	ISteamInventory.set_property_string = ISteamInventory.SetPropertyString

	local SetPropertyBool_native = vtable_entry(this, 33, "bool(__thiscall*)(void*, uint64_t, uint64_t, const char *, bool)")
	function ISteamInventory.SetPropertyBool(handle, nItemID, pchPropertyName, bValue)
		return SetPropertyBool_native(this, handle, nItemID, pchPropertyName, bValue)
	end
	ISteamInventory.set_property_bool = ISteamInventory.SetPropertyBool

	local SetPropertyInt64_native = vtable_entry(this, 34, "bool(__thiscall*)(void*, uint64_t, uint64_t, const char *, int64_t)")
	function ISteamInventory.SetPropertyInt64(handle, nItemID, pchPropertyName, nValue)
		return SetPropertyInt64_native(this, handle, nItemID, pchPropertyName, nValue)
	end
	ISteamInventory.set_property_int64 = ISteamInventory.SetPropertyInt64

	local SetPropertyFloat_native = vtable_entry(this, 35, "bool(__thiscall*)(void*, uint64_t, uint64_t, const char *, float)")
	function ISteamInventory.SetPropertyFloat(handle, nItemID, pchPropertyName, flValue)
		return SetPropertyFloat_native(this, handle, nItemID, pchPropertyName, flValue)
	end
	ISteamInventory.set_property_float = ISteamInventory.SetPropertyFloat

	local SubmitUpdateProperties_native = vtable_entry(this, 36, "bool(__thiscall*)(void*, uint64_t, int *)")
	function ISteamInventory.SubmitUpdateProperties(handle)
		local pResultHandle_out = new_int_arr()
		local res = SubmitUpdateProperties_native(this, handle, pResultHandle_out)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.submit_update_properties = ISteamInventory.SubmitUpdateProperties

	local InspectItem_native = vtable_entry(this, 37, "bool(__thiscall*)(void*, int *, const char *)")
	function ISteamInventory.InspectItem(pchItemToken)
		local pResultHandle_out = new_int_arr()
		local res = InspectItem_native(this, pResultHandle_out, pchItemToken)

		return res, DEREF_GCSAFE(pResultHandle_out)
	end
	ISteamInventory.inspect_item = ISteamInventory.InspectItem

	return ISteamInventory
end

--
-- ISteamVideo (STEAMVIDEO_INTERFACE_V002, user created: false)
--

local ISteamVideo = {version="STEAMVIDEO_INTERFACE_V002",version_number=2}

index_funcs.ISteamVideo = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 36, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMVIDEO_INTERFACE_V002")

	local GetVideoURL_native = vtable_entry(this, 0, "void(__thiscall*)(void*, unsigned int)")
	function ISteamVideo.GetVideoURL(unVideoAppID)
		return GetVideoURL_native(this, unVideoAppID)
	end
	ISteamVideo.get_video_url = ISteamVideo.GetVideoURL

	local IsBroadcasting_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, int *)")
	function ISteamVideo.IsBroadcasting()
		local pnNumViewers_out = new_int_arr()
		local res = IsBroadcasting_native(this, pnNumViewers_out)

		return res, DEREF_GCSAFE(pnNumViewers_out)
	end
	ISteamVideo.is_broadcasting = ISteamVideo.IsBroadcasting

	local GetOPFSettings_native = vtable_entry(this, 2, "void(__thiscall*)(void*, unsigned int)")
	function ISteamVideo.GetOPFSettings(unVideoAppID)
		return GetOPFSettings_native(this, unVideoAppID)
	end
	ISteamVideo.get_opf_settings = ISteamVideo.GetOPFSettings

	local GetOPFStringForApp_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, unsigned int, char *, int32_t *)")
	function ISteamVideo.GetOPFStringForApp(unVideoAppID, pchBuffer, pnBufferSize)
		return GetOPFStringForApp_native(this, unVideoAppID, pchBuffer, pnBufferSize)
	end
	ISteamVideo.get_opf_string_for_app = ISteamVideo.GetOPFStringForApp

	return ISteamVideo
end

--
-- ISteamParentalSettings (STEAMPARENTALSETTINGS_INTERFACE_VERSION001, user created: false)
--

local ISteamParentalSettings = {version="STEAMPARENTALSETTINGS_INTERFACE_VERSION001",version_number=1}

index_funcs.ISteamParentalSettings = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 37, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMPARENTALSETTINGS_INTERFACE_VERSION001")

	local BIsParentalLockEnabled_native = vtable_entry(this, 0, "bool(__thiscall*)(void*)")
	function ISteamParentalSettings.BIsParentalLockEnabled()
		return BIsParentalLockEnabled_native(this)
	end
	ISteamParentalSettings.is_parental_lock_enabled = ISteamParentalSettings.BIsParentalLockEnabled

	local BIsParentalLockLocked_native = vtable_entry(this, 1, "bool(__thiscall*)(void*)")
	function ISteamParentalSettings.BIsParentalLockLocked()
		return BIsParentalLockLocked_native(this)
	end
	ISteamParentalSettings.is_parental_lock_locked = ISteamParentalSettings.BIsParentalLockLocked

	local BIsAppBlocked_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamParentalSettings.BIsAppBlocked(nAppID)
		return BIsAppBlocked_native(this, nAppID)
	end
	ISteamParentalSettings.is_app_blocked = ISteamParentalSettings.BIsAppBlocked

	local BIsAppInBlockList_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamParentalSettings.BIsAppInBlockList(nAppID)
		return BIsAppInBlockList_native(this, nAppID)
	end
	ISteamParentalSettings.is_app_in_block_list = ISteamParentalSettings.BIsAppInBlockList

	local BIsFeatureBlocked_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, int)")
	function ISteamParentalSettings.BIsFeatureBlocked(eFeature)
		eFeature = to_enum_required(eFeature, enums.EParentalFeature, "feature is required")
		return BIsFeatureBlocked_native(this, eFeature)
	end
	ISteamParentalSettings.is_feature_blocked = ISteamParentalSettings.BIsFeatureBlocked

	local BIsFeatureInBlockList_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, int)")
	function ISteamParentalSettings.BIsFeatureInBlockList(eFeature)
		eFeature = to_enum_required(eFeature, enums.EParentalFeature, "feature is required")
		return BIsFeatureInBlockList_native(this, eFeature)
	end
	ISteamParentalSettings.is_feature_in_block_list = ISteamParentalSettings.BIsFeatureInBlockList

	return ISteamParentalSettings
end

--
-- ISteamRemotePlay (STEAMREMOTEPLAY_INTERFACE_VERSION001, user created: false)
--

local ISteamRemotePlay = {version="STEAMREMOTEPLAY_INTERFACE_VERSION001",version_number=1}

index_funcs.ISteamRemotePlay = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 40, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "STEAMREMOTEPLAY_INTERFACE_VERSION001")

	local GetSessionCount_native = vtable_entry(this, 0, "uint32_t(__thiscall*)(void*)")
	function ISteamRemotePlay.GetSessionCount()
		return GetSessionCount_native(this)
	end
	ISteamRemotePlay.get_session_count = ISteamRemotePlay.GetSessionCount

	local GetSessionID_native = vtable_entry(this, 1, "unsigned int(__thiscall*)(void*, int)")
	function ISteamRemotePlay.GetSessionID(iSessionIndex)
		return GetSessionID_native(this, iSessionIndex)
	end
	ISteamRemotePlay.get_session_id = ISteamRemotePlay.GetSessionID

	local GetSessionSteamID_native = vtable_entry(this, 2, "void(__thiscall*)(void*, SteamID *, unsigned int)")
	function ISteamRemotePlay.GetSessionSteamID(unSessionID)
		local CSteamID_out = new_SteamID_arr()
		GetSessionSteamID_native(this, CSteamID_out, unSessionID)

		return DEREF_GCSAFE(CSteamID_out)
	end
	ISteamRemotePlay.get_session_steamid = ISteamRemotePlay.GetSessionSteamID

	local GetSessionClientName_native = vtable_entry(this, 3, "const char *(__thiscall*)(void*, unsigned int)")
	function ISteamRemotePlay.GetSessionClientName(unSessionID)
		local res = GetSessionClientName_native(this, unSessionID)

		return res ~= nil and ffi_string(res) or nil
	end
	ISteamRemotePlay.get_session_client_name = ISteamRemotePlay.GetSessionClientName

	local GetSessionClientFormFactor_native = vtable_entry(this, 4, "int(__thiscall*)(void*, unsigned int)")
	function ISteamRemotePlay.GetSessionClientFormFactor(unSessionID)
		return GetSessionClientFormFactor_native(this, unSessionID)
	end
	ISteamRemotePlay.get_session_client_form_factor = ISteamRemotePlay.GetSessionClientFormFactor

	local BGetSessionClientResolution_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, unsigned int, int *, int *)")
	function ISteamRemotePlay.BGetSessionClientResolution(unSessionID)
		local pnResolutionX_out = new_int_arr()
		local pnResolutionY_out = new_int_arr()
		local res = BGetSessionClientResolution_native(this, unSessionID, pnResolutionX_out, pnResolutionY_out)

		return res, DEREF_GCSAFE(pnResolutionX_out), DEREF_GCSAFE(pnResolutionY_out)
	end
	ISteamRemotePlay.get_session_client_resolution = ISteamRemotePlay.BGetSessionClientResolution

	local BSendRemotePlayTogetherInvite_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, SteamID)")
	function ISteamRemotePlay.BSendRemotePlayTogetherInvite(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamid_friend is required")
		return BSendRemotePlayTogetherInvite_native(this, steamIDFriend)
	end
	ISteamRemotePlay.send_remote_play_together_invite = ISteamRemotePlay.BSendRemotePlayTogetherInvite

	return ISteamRemotePlay
end

--
-- ISteamNetworkingMessages (SteamNetworkingMessages002, user created: false)
--

local ISteamNetworkingMessages = {version="SteamNetworkingMessages002",version_number=2}

index_funcs.ISteamNetworkingMessages = function()
	local this = proc_bind("steamnetworkingsockets.dll", "SteamNetworkingMessages_LibV2", "void*(__thiscall*)(unsigned int, unsigned int)")()

	local SendMessageToUser_native = vtable_entry(this, 0, "int(__thiscall*)(void*, const SteamNetworkingIdentity &, const void *, uint32_t, int, int)")
	function ISteamNetworkingMessages.SendMessageToUser(identityRemote, pubData, cubData, nSendFlags, nRemoteChannel)
		return SendMessageToUser_native(this, identityRemote, pubData, cubData, nSendFlags, nRemoteChannel)
	end
	ISteamNetworkingMessages.send_message_to_user = ISteamNetworkingMessages.SendMessageToUser

	local ReceiveMessagesOnChannel_native = vtable_entry(this, 1, "int(__thiscall*)(void*, int, SteamNetworkingMessage_t **, int)")
	function ISteamNetworkingMessages.ReceiveMessagesOnChannel(nLocalChannel, ppOutMessages, nMaxMessages)
		return ReceiveMessagesOnChannel_native(this, nLocalChannel, ppOutMessages, nMaxMessages)
	end
	ISteamNetworkingMessages.receive_messages_on_channel = ISteamNetworkingMessages.ReceiveMessagesOnChannel

	local AcceptSessionWithUser_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, const SteamNetworkingIdentity &)")
	function ISteamNetworkingMessages.AcceptSessionWithUser(identityRemote)
		return AcceptSessionWithUser_native(this, identityRemote)
	end
	ISteamNetworkingMessages.accept_session_with_user = ISteamNetworkingMessages.AcceptSessionWithUser

	local CloseSessionWithUser_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, const SteamNetworkingIdentity &)")
	function ISteamNetworkingMessages.CloseSessionWithUser(identityRemote)
		return CloseSessionWithUser_native(this, identityRemote)
	end
	ISteamNetworkingMessages.close_session_with_user = ISteamNetworkingMessages.CloseSessionWithUser

	local CloseChannelWithUser_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, const SteamNetworkingIdentity &, int)")
	function ISteamNetworkingMessages.CloseChannelWithUser(identityRemote, nLocalChannel)
		return CloseChannelWithUser_native(this, identityRemote, nLocalChannel)
	end
	ISteamNetworkingMessages.close_channel_with_user = ISteamNetworkingMessages.CloseChannelWithUser

	local GetSessionConnectionInfo_native = vtable_entry(this, 5, "int(__thiscall*)(void*, const SteamNetworkingIdentity &, SteamNetConnectionInfo_t *, SteamNetworkingQuickConnectionStatus *)")
	function ISteamNetworkingMessages.GetSessionConnectionInfo(identityRemote)
		local pConnectionInfo_out = structs.SteamNetConnectionInfo_t_arr(1)
		local pQuickStatus_out = structs.SteamNetworkingQuickConnectionStatus_arr(1)
		local res = GetSessionConnectionInfo_native(this, identityRemote, pConnectionInfo_out, pQuickStatus_out)

		return res, DEREF_GCSAFE(pConnectionInfo_out), DEREF_GCSAFE(pQuickStatus_out)
	end
	ISteamNetworkingMessages.get_session_connection_info = ISteamNetworkingMessages.GetSessionConnectionInfo

	return ISteamNetworkingMessages
end

--
-- ISteamNetworkingSockets (SteamNetworkingSockets009, user created: false)
--

local ISteamNetworkingSockets = {version="SteamNetworkingSockets009",version_number=9}

index_funcs.ISteamNetworkingSockets = function()
	local this = proc_bind("steamnetworkingsockets.dll", "SteamNetworkingSockets_LibV9", "void*(__thiscall*)(unsigned int, unsigned int)")()

	local CreateListenSocketIP_native = vtable_entry(this, 0, "unsigned int(__thiscall*)(void*, const SteamNetworkingIPAddr &, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.CreateListenSocketIP(localAddress, nOptions, pOptions)
		return CreateListenSocketIP_native(this, localAddress, nOptions, pOptions)
	end
	ISteamNetworkingSockets.create_listen_socket_ip = ISteamNetworkingSockets.CreateListenSocketIP

	local ConnectByIPAddress_native = vtable_entry(this, 1, "unsigned int(__thiscall*)(void*, const SteamNetworkingIPAddr &, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.ConnectByIPAddress(address, nOptions, pOptions)
		return ConnectByIPAddress_native(this, address, nOptions, pOptions)
	end
	ISteamNetworkingSockets.connect_by_ip_address = ISteamNetworkingSockets.ConnectByIPAddress

	local CreateListenSocketP2P_native = vtable_entry(this, 2, "unsigned int(__thiscall*)(void*, int, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.CreateListenSocketP2P(nLocalVirtualPort, nOptions, pOptions)
		return CreateListenSocketP2P_native(this, nLocalVirtualPort, nOptions, pOptions)
	end
	ISteamNetworkingSockets.create_listen_socket_p2p = ISteamNetworkingSockets.CreateListenSocketP2P

	local ConnectP2P_native = vtable_entry(this, 3, "unsigned int(__thiscall*)(void*, const SteamNetworkingIdentity &, int, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.ConnectP2P(identityRemote, nRemoteVirtualPort, nOptions, pOptions)
		return ConnectP2P_native(this, identityRemote, nRemoteVirtualPort, nOptions, pOptions)
	end
	ISteamNetworkingSockets.connect_p2p = ISteamNetworkingSockets.ConnectP2P

	local AcceptConnection_native = vtable_entry(this, 4, "int(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingSockets.AcceptConnection(hConn)
		return AcceptConnection_native(this, hConn)
	end
	ISteamNetworkingSockets.accept_connection = ISteamNetworkingSockets.AcceptConnection

	local CloseConnection_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, unsigned int, int, const char *, bool)")
	function ISteamNetworkingSockets.CloseConnection(hPeer, nReason, pszDebug, bEnableLinger)
		return CloseConnection_native(this, hPeer, nReason, pszDebug, bEnableLinger)
	end
	ISteamNetworkingSockets.close_connection = ISteamNetworkingSockets.CloseConnection

	local CloseListenSocket_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingSockets.CloseListenSocket(hSocket)
		return CloseListenSocket_native(this, hSocket)
	end
	ISteamNetworkingSockets.close_listen_socket = ISteamNetworkingSockets.CloseListenSocket

	local SetConnectionUserData_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, unsigned int, int64_t)")
	function ISteamNetworkingSockets.SetConnectionUserData(hPeer, nUserData)
		return SetConnectionUserData_native(this, hPeer, nUserData)
	end
	ISteamNetworkingSockets.set_connection_user_data = ISteamNetworkingSockets.SetConnectionUserData

	local GetConnectionUserData_native = vtable_entry(this, 8, "int64_t(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingSockets.GetConnectionUserData(hPeer)
		return GetConnectionUserData_native(this, hPeer)
	end
	ISteamNetworkingSockets.get_connection_user_data = ISteamNetworkingSockets.GetConnectionUserData

	local SetConnectionName_native = vtable_entry(this, 9, "void(__thiscall*)(void*, unsigned int, const char *)")
	function ISteamNetworkingSockets.SetConnectionName(hPeer, pszName)
		return SetConnectionName_native(this, hPeer, pszName)
	end
	ISteamNetworkingSockets.set_connection_name = ISteamNetworkingSockets.SetConnectionName

	local GetConnectionName_native = vtable_entry(this, 10, "bool(__thiscall*)(void*, unsigned int, char *, int)")
	function ISteamNetworkingSockets.GetConnectionName(hPeer, pszName, nMaxLen)
		return GetConnectionName_native(this, hPeer, pszName, nMaxLen)
	end
	ISteamNetworkingSockets.get_connection_name = ISteamNetworkingSockets.GetConnectionName

	local SendMessageToConnection_native = vtable_entry(this, 11, "int(__thiscall*)(void*, unsigned int, const void *, uint32_t, int, int64_t *)")
	function ISteamNetworkingSockets.SendMessageToConnection(hConn, pData, cbData, nSendFlags)
		local pOutMessageNumber_out = new_int64_arr()
		local res = SendMessageToConnection_native(this, hConn, pData, cbData, nSendFlags, pOutMessageNumber_out)

		return res, DEREF_GCSAFE(pOutMessageNumber_out)
	end
	ISteamNetworkingSockets.send_message_to_connection = ISteamNetworkingSockets.SendMessageToConnection

	local SendMessages_native = vtable_entry(this, 12, "void(__thiscall*)(void*, int, SteamNetworkingMessage_t *const *, int64_t *)")
	function ISteamNetworkingSockets.SendMessages(nMessages, pMessages)
		local pOutMessageNumberOrResult_out = new_int64_arr()
		SendMessages_native(this, nMessages, pMessages, pOutMessageNumberOrResult_out)

		return DEREF_GCSAFE(pOutMessageNumberOrResult_out)
	end
	ISteamNetworkingSockets.send_messages = ISteamNetworkingSockets.SendMessages

	local FlushMessagesOnConnection_native = vtable_entry(this, 13, "int(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingSockets.FlushMessagesOnConnection(hConn)
		return FlushMessagesOnConnection_native(this, hConn)
	end
	ISteamNetworkingSockets.flush_messages_on_connection = ISteamNetworkingSockets.FlushMessagesOnConnection

	local ReceiveMessagesOnConnection_native = vtable_entry(this, 14, "int(__thiscall*)(void*, unsigned int, SteamNetworkingMessage_t **, int)")
	function ISteamNetworkingSockets.ReceiveMessagesOnConnection(hConn, ppOutMessages, nMaxMessages)
		return ReceiveMessagesOnConnection_native(this, hConn, ppOutMessages, nMaxMessages)
	end
	ISteamNetworkingSockets.receive_messages_on_connection = ISteamNetworkingSockets.ReceiveMessagesOnConnection

	local GetConnectionInfo_native = vtable_entry(this, 15, "bool(__thiscall*)(void*, unsigned int, SteamNetConnectionInfo_t *)")
	function ISteamNetworkingSockets.GetConnectionInfo(hConn)
		local pInfo_out = structs.SteamNetConnectionInfo_t_arr(1)
		local res = GetConnectionInfo_native(this, hConn, pInfo_out)

		return res, DEREF_GCSAFE(pInfo_out)
	end
	ISteamNetworkingSockets.get_connection_info = ISteamNetworkingSockets.GetConnectionInfo

	local GetQuickConnectionStatus_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, unsigned int, SteamNetworkingQuickConnectionStatus *)")
	function ISteamNetworkingSockets.GetQuickConnectionStatus(hConn)
		local pStats_out = structs.SteamNetworkingQuickConnectionStatus_arr(1)
		local res = GetQuickConnectionStatus_native(this, hConn, pStats_out)

		return res, DEREF_GCSAFE(pStats_out)
	end
	ISteamNetworkingSockets.get_quick_connection_status = ISteamNetworkingSockets.GetQuickConnectionStatus

	local GetDetailedConnectionStatus_native = vtable_entry(this, 17, "int(__thiscall*)(void*, unsigned int, char *, int)")
	function ISteamNetworkingSockets.GetDetailedConnectionStatus(hConn, pszBuf, cbBuf)
		return GetDetailedConnectionStatus_native(this, hConn, pszBuf, cbBuf)
	end
	ISteamNetworkingSockets.get_detailed_connection_status = ISteamNetworkingSockets.GetDetailedConnectionStatus

	local GetListenSocketAddress_native = vtable_entry(this, 18, "bool(__thiscall*)(void*, unsigned int, SteamNetworkingIPAddr *)")
	function ISteamNetworkingSockets.GetListenSocketAddress(hSocket)
		local address_out = structs.SteamNetworkingIPAddr_arr(1)
		local res = GetListenSocketAddress_native(this, hSocket, address_out)

		return res, DEREF_GCSAFE(address_out)
	end
	ISteamNetworkingSockets.get_listen_socket_address = ISteamNetworkingSockets.GetListenSocketAddress

	local CreateSocketPair_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, unsigned int *, unsigned int *, bool, const SteamNetworkingIdentity *, const SteamNetworkingIdentity *)")
	function ISteamNetworkingSockets.CreateSocketPair(bUseNetworkLoopback, pIdentity1, pIdentity2)
		local pOutConnection1_out = new_unsigned_int_arr()
		local pOutConnection2_out = new_unsigned_int_arr()
		local res = CreateSocketPair_native(this, pOutConnection1_out, pOutConnection2_out, bUseNetworkLoopback, pIdentity1, pIdentity2)

		return res, DEREF_GCSAFE(pOutConnection1_out), DEREF_GCSAFE(pOutConnection2_out)
	end
	ISteamNetworkingSockets.create_socket_pair = ISteamNetworkingSockets.CreateSocketPair

	local GetIdentity_native = vtable_entry(this, 20, "bool(__thiscall*)(void*, SteamNetworkingIdentity *)")
	function ISteamNetworkingSockets.GetIdentity()
		local pIdentity_out = structs.SteamNetworkingIdentity_arr(1)
		local res = GetIdentity_native(this, pIdentity_out)

		return res, DEREF_GCSAFE(pIdentity_out)
	end
	ISteamNetworkingSockets.get_identity = ISteamNetworkingSockets.GetIdentity

	local InitAuthentication_native = vtable_entry(this, 21, "int(__thiscall*)(void*)")
	function ISteamNetworkingSockets.InitAuthentication()
		return InitAuthentication_native(this)
	end
	ISteamNetworkingSockets.init_authentication = ISteamNetworkingSockets.InitAuthentication

	local GetAuthenticationStatus_native = vtable_entry(this, 22, "int(__thiscall*)(void*, SteamNetAuthenticationStatus_t *)")
	function ISteamNetworkingSockets.GetAuthenticationStatus()
		local pDetails_out = structs.SteamNetAuthenticationStatus_t_arr(1)
		local res = GetAuthenticationStatus_native(this, pDetails_out)

		return res, DEREF_GCSAFE(pDetails_out)
	end
	ISteamNetworkingSockets.get_authentication_status = ISteamNetworkingSockets.GetAuthenticationStatus

	local CreatePollGroup_native = vtable_entry(this, 23, "unsigned int(__thiscall*)(void*)")
	function ISteamNetworkingSockets.CreatePollGroup()
		return CreatePollGroup_native(this)
	end
	ISteamNetworkingSockets.create_poll_group = ISteamNetworkingSockets.CreatePollGroup

	local DestroyPollGroup_native = vtable_entry(this, 24, "bool(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingSockets.DestroyPollGroup(hPollGroup)
		return DestroyPollGroup_native(this, hPollGroup)
	end
	ISteamNetworkingSockets.destroy_poll_group = ISteamNetworkingSockets.DestroyPollGroup

	local SetConnectionPollGroup_native = vtable_entry(this, 25, "bool(__thiscall*)(void*, unsigned int, unsigned int)")
	function ISteamNetworkingSockets.SetConnectionPollGroup(hConn, hPollGroup)
		return SetConnectionPollGroup_native(this, hConn, hPollGroup)
	end
	ISteamNetworkingSockets.set_connection_poll_group = ISteamNetworkingSockets.SetConnectionPollGroup

	local ReceiveMessagesOnPollGroup_native = vtable_entry(this, 26, "int(__thiscall*)(void*, unsigned int, SteamNetworkingMessage_t **, int)")
	function ISteamNetworkingSockets.ReceiveMessagesOnPollGroup(hPollGroup, ppOutMessages, nMaxMessages)
		return ReceiveMessagesOnPollGroup_native(this, hPollGroup, ppOutMessages, nMaxMessages)
	end
	ISteamNetworkingSockets.receive_messages_on_poll_group = ISteamNetworkingSockets.ReceiveMessagesOnPollGroup

	local ReceivedRelayAuthTicket_native = vtable_entry(this, 27, "bool(__thiscall*)(void*, const void *, int, SteamDatagramRelayAuthTicket *)")
	function ISteamNetworkingSockets.ReceivedRelayAuthTicket(pvTicket, cbTicket, pOutParsedTicket)
		return ReceivedRelayAuthTicket_native(this, pvTicket, cbTicket, pOutParsedTicket)
	end
	ISteamNetworkingSockets.received_relay_auth_ticket = ISteamNetworkingSockets.ReceivedRelayAuthTicket

	local FindRelayAuthTicketForServer_native = vtable_entry(this, 28, "int(__thiscall*)(void*, const SteamNetworkingIdentity &, int, SteamDatagramRelayAuthTicket *)")
	function ISteamNetworkingSockets.FindRelayAuthTicketForServer(identityGameServer, nRemoteVirtualPort, pOutParsedTicket)
		return FindRelayAuthTicketForServer_native(this, identityGameServer, nRemoteVirtualPort, pOutParsedTicket)
	end
	ISteamNetworkingSockets.find_relay_auth_ticket_for_server = ISteamNetworkingSockets.FindRelayAuthTicketForServer

	local ConnectToHostedDedicatedServer_native = vtable_entry(this, 29, "unsigned int(__thiscall*)(void*, const SteamNetworkingIdentity &, int, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.ConnectToHostedDedicatedServer(identityTarget, nRemoteVirtualPort, nOptions, pOptions)
		return ConnectToHostedDedicatedServer_native(this, identityTarget, nRemoteVirtualPort, nOptions, pOptions)
	end
	ISteamNetworkingSockets.connect_to_hosted_dedicated_server = ISteamNetworkingSockets.ConnectToHostedDedicatedServer

	local GetHostedDedicatedServerPort_native = vtable_entry(this, 30, "uint16_t(__thiscall*)(void*)")
	function ISteamNetworkingSockets.GetHostedDedicatedServerPort()
		return GetHostedDedicatedServerPort_native(this)
	end
	ISteamNetworkingSockets.get_hosted_dedicated_server_port = ISteamNetworkingSockets.GetHostedDedicatedServerPort

	local GetHostedDedicatedServerPOPID_native = vtable_entry(this, 31, "unsigned int(__thiscall*)(void*)")
	function ISteamNetworkingSockets.GetHostedDedicatedServerPOPID()
		return GetHostedDedicatedServerPOPID_native(this)
	end
	ISteamNetworkingSockets.get_hosted_dedicated_server_pop_id = ISteamNetworkingSockets.GetHostedDedicatedServerPOPID

	local GetHostedDedicatedServerAddress_native = vtable_entry(this, 32, "int(__thiscall*)(void*, SteamDatagramHostedAddress *)")
	function ISteamNetworkingSockets.GetHostedDedicatedServerAddress()
		local pRouting_out = structs.SteamDatagramHostedAddress_arr(1)
		local res = GetHostedDedicatedServerAddress_native(this, pRouting_out)

		return res, DEREF_GCSAFE(pRouting_out)
	end
	ISteamNetworkingSockets.get_hosted_dedicated_server_address = ISteamNetworkingSockets.GetHostedDedicatedServerAddress

	local CreateHostedDedicatedServerListenSocket_native = vtable_entry(this, 33, "unsigned int(__thiscall*)(void*, int, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.CreateHostedDedicatedServerListenSocket(nLocalVirtualPort, nOptions, pOptions)
		return CreateHostedDedicatedServerListenSocket_native(this, nLocalVirtualPort, nOptions, pOptions)
	end
	ISteamNetworkingSockets.create_hosted_dedicated_server_listen_socket = ISteamNetworkingSockets.CreateHostedDedicatedServerListenSocket

	local GetGameCoordinatorServerLogin_native = vtable_entry(this, 34, "int(__thiscall*)(void*, SteamDatagramGameCoordinatorServerLogin *, int *, void *)")
	function ISteamNetworkingSockets.GetGameCoordinatorServerLogin(pLoginInfo, pcbSignedBlob, pBlob)
		return GetGameCoordinatorServerLogin_native(this, pLoginInfo, pcbSignedBlob, pBlob)
	end
	ISteamNetworkingSockets.get_game_coordinator_server_login = ISteamNetworkingSockets.GetGameCoordinatorServerLogin

	local ConnectP2PCustomSignaling_native = vtable_entry(this, 35, "unsigned int(__thiscall*)(void*, void* *, const SteamNetworkingIdentity *, int, int, const SteamNetworkingConfigValue_t *)")
	function ISteamNetworkingSockets.ConnectP2PCustomSignaling(pSignaling, pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions)
		return ConnectP2PCustomSignaling_native(this, pSignaling, pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions)
	end
	ISteamNetworkingSockets.connect_p2p_custom_signaling = ISteamNetworkingSockets.ConnectP2PCustomSignaling

	local ReceivedP2PCustomSignal_native = vtable_entry(this, 36, "bool(__thiscall*)(void*, const void *, int, void* *)")
	function ISteamNetworkingSockets.ReceivedP2PCustomSignal(pMsg, cbMsg, pContext)
		return ReceivedP2PCustomSignal_native(this, pMsg, cbMsg, pContext)
	end
	ISteamNetworkingSockets.received_p2p_custom_signal = ISteamNetworkingSockets.ReceivedP2PCustomSignal

	local GetCertificateRequest_native = vtable_entry(this, 37, "bool(__thiscall*)(void*, int *, void *, char * &)")
	function ISteamNetworkingSockets.GetCertificateRequest(pcbBlob, pBlob, errMsg)
		return GetCertificateRequest_native(this, pcbBlob, pBlob, errMsg)
	end
	ISteamNetworkingSockets.get_certificate_request = ISteamNetworkingSockets.GetCertificateRequest

	local SetCertificate_native = vtable_entry(this, 38, "bool(__thiscall*)(void*, const void *, int, char * &)")
	function ISteamNetworkingSockets.SetCertificate(pCertificate, cbCertificate, errMsg)
		return SetCertificate_native(this, pCertificate, cbCertificate, errMsg)
	end
	ISteamNetworkingSockets.set_certificate = ISteamNetworkingSockets.SetCertificate

	local RunCallbacks_native = vtable_entry(this, 39, "void(__thiscall*)(void*)")
	function ISteamNetworkingSockets.RunCallbacks()
		return RunCallbacks_native(this)
	end
	ISteamNetworkingSockets.run_callbacks = ISteamNetworkingSockets.RunCallbacks

	return ISteamNetworkingSockets
end

--
-- ISteamNetworkingUtils (SteamNetworkingUtils003, user created: false)
--

local ISteamNetworkingUtils = {version="SteamNetworkingUtils003",version_number=3}

index_funcs.ISteamNetworkingUtils = function()
	local this = proc_bind("steamnetworkingsockets.dll", "SteamNetworkingUtils_LibV3", "void*(__thiscall*)(unsigned int, unsigned int)")()

	local AllocateMessage_native = vtable_entry(this, 0, "SteamNetworkingMessage_t *(__thiscall*)(void*, int)")
	function ISteamNetworkingUtils.AllocateMessage(cbAllocateBuffer)
		return AllocateMessage_native(this, cbAllocateBuffer)
	end
	ISteamNetworkingUtils.allocate_message = ISteamNetworkingUtils.AllocateMessage

	local GetRelayNetworkStatus_native = vtable_entry(this, 1, "int(__thiscall*)(void*, SteamRelayNetworkStatus_t *)")
	function ISteamNetworkingUtils.GetRelayNetworkStatus()
		local pDetails_out = structs.SteamRelayNetworkStatus_t_arr(1)
		local res = GetRelayNetworkStatus_native(this, pDetails_out)

		return res, DEREF_GCSAFE(pDetails_out)
	end
	ISteamNetworkingUtils.get_relay_network_status = ISteamNetworkingUtils.GetRelayNetworkStatus

	local GetLocalPingLocation_native = vtable_entry(this, 2, "float(__thiscall*)(void*, SteamNetworkPingLocation_t &)")
	function ISteamNetworkingUtils.GetLocalPingLocation(result)
		return GetLocalPingLocation_native(this, result)
	end
	ISteamNetworkingUtils.get_local_ping_location = ISteamNetworkingUtils.GetLocalPingLocation

	local EstimatePingTimeBetweenTwoLocations_native = vtable_entry(this, 3, "int(__thiscall*)(void*, const SteamNetworkPingLocation_t &, const SteamNetworkPingLocation_t &)")
	function ISteamNetworkingUtils.EstimatePingTimeBetweenTwoLocations(location1, location2)
		return EstimatePingTimeBetweenTwoLocations_native(this, location1, location2)
	end
	ISteamNetworkingUtils.estimate_ping_time_between_two_locations = ISteamNetworkingUtils.EstimatePingTimeBetweenTwoLocations

	local EstimatePingTimeFromLocalHost_native = vtable_entry(this, 4, "int(__thiscall*)(void*, const SteamNetworkPingLocation_t &)")
	function ISteamNetworkingUtils.EstimatePingTimeFromLocalHost(remoteLocation)
		return EstimatePingTimeFromLocalHost_native(this, remoteLocation)
	end
	ISteamNetworkingUtils.estimate_ping_time_from_local_host = ISteamNetworkingUtils.EstimatePingTimeFromLocalHost

	local ConvertPingLocationToString_native = vtable_entry(this, 5, "void(__thiscall*)(void*, const SteamNetworkPingLocation_t &, char *, int)")
	function ISteamNetworkingUtils.ConvertPingLocationToString(location, pszBuf, cchBufSize)
		return ConvertPingLocationToString_native(this, location, pszBuf, cchBufSize)
	end
	ISteamNetworkingUtils.convert_ping_location_to_string = ISteamNetworkingUtils.ConvertPingLocationToString

	local ParsePingLocationString_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, const char *, SteamNetworkPingLocation_t &)")
	function ISteamNetworkingUtils.ParsePingLocationString(pszString, result)
		return ParsePingLocationString_native(this, pszString, result)
	end
	ISteamNetworkingUtils.parse_ping_location_string = ISteamNetworkingUtils.ParsePingLocationString

	local CheckPingDataUpToDate_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, float)")
	function ISteamNetworkingUtils.CheckPingDataUpToDate(flMaxAgeSeconds)
		return CheckPingDataUpToDate_native(this, flMaxAgeSeconds)
	end
	ISteamNetworkingUtils.check_ping_data_up_to_date = ISteamNetworkingUtils.CheckPingDataUpToDate

	local GetPingToDataCenter_native = vtable_entry(this, 8, "int(__thiscall*)(void*, unsigned int, unsigned int *)")
	function ISteamNetworkingUtils.GetPingToDataCenter(popID)
		local pViaRelayPoP_out = new_unsigned_int_arr()
		local res = GetPingToDataCenter_native(this, popID, pViaRelayPoP_out)

		return res, DEREF_GCSAFE(pViaRelayPoP_out)
	end
	ISteamNetworkingUtils.get_ping_to_data_center = ISteamNetworkingUtils.GetPingToDataCenter

	local GetDirectPingToPOP_native = vtable_entry(this, 9, "int(__thiscall*)(void*, unsigned int)")
	function ISteamNetworkingUtils.GetDirectPingToPOP(popID)
		return GetDirectPingToPOP_native(this, popID)
	end
	ISteamNetworkingUtils.get_direct_ping_to_pop = ISteamNetworkingUtils.GetDirectPingToPOP

	local GetPOPCount_native = vtable_entry(this, 10, "int(__thiscall*)(void*)")
	function ISteamNetworkingUtils.GetPOPCount()
		return GetPOPCount_native(this)
	end
	ISteamNetworkingUtils.get_pop_count = ISteamNetworkingUtils.GetPOPCount

	local GetPOPList_native = vtable_entry(this, 11, "int(__thiscall*)(void*, unsigned int *, int)")
	function ISteamNetworkingUtils.GetPOPList(list, nListSz)
		return GetPOPList_native(this, list, nListSz)
	end
	ISteamNetworkingUtils.get_pop_list = ISteamNetworkingUtils.GetPOPList

	local GetLocalTimestamp_native = vtable_entry(this, 12, "long long(__thiscall*)(void*)")
	function ISteamNetworkingUtils.GetLocalTimestamp()
		return GetLocalTimestamp_native(this)
	end
	ISteamNetworkingUtils.get_local_timestamp = ISteamNetworkingUtils.GetLocalTimestamp

	local SetDebugOutputFunction_native = vtable_entry(this, 13, "void(__thiscall*)(void*, int, void (__thiscall*)(int, const char *))")
	function ISteamNetworkingUtils.SetDebugOutputFunction(eDetailLevel, pfnFunc)
		eDetailLevel = to_enum_required(eDetailLevel, enums.ESteamNetworkingSocketsDebugOutputType, "detail_level is required")
		return SetDebugOutputFunction_native(this, eDetailLevel, pfnFunc)
	end
	ISteamNetworkingUtils.set_debug_output_function = ISteamNetworkingUtils.SetDebugOutputFunction

	local SetConfigValue_native = vtable_entry(this, 14, "bool(__thiscall*)(void*, int, int, intptr_t, int, const void *)")
	function ISteamNetworkingUtils.SetConfigValue(eValue, eScopeType, scopeObj, eDataType, pArg)
		eValue = to_enum_required(eValue, enums.ESteamNetworkingConfigValue, "value is required")
		eScopeType = to_enum_required(eScopeType, enums.ESteamNetworkingConfigScope, "scope_type is required")
		eDataType = to_enum_required(eDataType, enums.ESteamNetworkingConfigDataType, "data_type is required")
		return SetConfigValue_native(this, eValue, eScopeType, scopeObj, eDataType, pArg)
	end
	ISteamNetworkingUtils.set_config_value = ISteamNetworkingUtils.SetConfigValue

	local GetConfigValue_native = vtable_entry(this, 15, "int(__thiscall*)(void*, int, int, intptr_t, int *, void *, size_t *)")
	function ISteamNetworkingUtils.GetConfigValue(eValue, eScopeType, scopeObj, pResult, cbResult)
		eValue = to_enum_required(eValue, enums.ESteamNetworkingConfigValue, "value is required")
		eScopeType = to_enum_required(eScopeType, enums.ESteamNetworkingConfigScope, "scope_type is required")
		local pOutDataType_out = new_int_arr()
		local res = GetConfigValue_native(this, eValue, eScopeType, scopeObj, pOutDataType_out, pResult, cbResult)

		return res, DEREF_GCSAFE(pOutDataType_out)
	end
	ISteamNetworkingUtils.get_config_value = ISteamNetworkingUtils.GetConfigValue

	local GetConfigValueInfo_native = vtable_entry(this, 16, "bool(__thiscall*)(void*, int, const char **, int *, int *, int *)")
	function ISteamNetworkingUtils.GetConfigValueInfo(eValue, pOutName)
		eValue = to_enum_required(eValue, enums.ESteamNetworkingConfigValue, "value is required")
		local pOutDataType_out = new_int_arr()
		local pOutScope_out = new_int_arr()
		local pOutNextValue_out = new_int_arr()
		local res = GetConfigValueInfo_native(this, eValue, pOutName, pOutDataType_out, pOutScope_out, pOutNextValue_out)

		return res, DEREF_GCSAFE(pOutDataType_out), DEREF_GCSAFE(pOutScope_out), DEREF_GCSAFE(pOutNextValue_out)
	end
	ISteamNetworkingUtils.get_config_value_info = ISteamNetworkingUtils.GetConfigValueInfo

	local GetFirstConfigValue_native = vtable_entry(this, 17, "int(__thiscall*)(void*)")
	function ISteamNetworkingUtils.GetFirstConfigValue()
		return GetFirstConfigValue_native(this)
	end
	ISteamNetworkingUtils.get_first_config_value = ISteamNetworkingUtils.GetFirstConfigValue

	local SteamNetworkingIPAddr_ToString_native = vtable_entry(this, 18, "void(__thiscall*)(void*, const SteamNetworkingIPAddr &, char *, uint32_t, bool)")
	function ISteamNetworkingUtils.SteamNetworkingIPAddr_ToString(addr, buf, cbBuf, bWithPort)
		return SteamNetworkingIPAddr_ToString_native(this, addr, buf, cbBuf, bWithPort)
	end
	ISteamNetworkingUtils.steam_networking_ip_addr_to_string = ISteamNetworkingUtils.SteamNetworkingIPAddr_ToString

	local SteamNetworkingIPAddr_ParseString_native = vtable_entry(this, 19, "bool(__thiscall*)(void*, SteamNetworkingIPAddr *, const char *)")
	function ISteamNetworkingUtils.SteamNetworkingIPAddr_ParseString(pAddr, pszStr)
		return SteamNetworkingIPAddr_ParseString_native(this, pAddr, pszStr)
	end
	ISteamNetworkingUtils.steam_networking_ip_addr_parse_string = ISteamNetworkingUtils.SteamNetworkingIPAddr_ParseString

	local SteamNetworkingIdentity_ToString_native = vtable_entry(this, 20, "void(__thiscall*)(void*, const SteamNetworkingIdentity &, char *, uint32_t)")
	function ISteamNetworkingUtils.SteamNetworkingIdentity_ToString(identity, buf, cbBuf)
		return SteamNetworkingIdentity_ToString_native(this, identity, buf, cbBuf)
	end
	ISteamNetworkingUtils.steam_networking_identity_to_string = ISteamNetworkingUtils.SteamNetworkingIdentity_ToString

	local SteamNetworkingIdentity_ParseString_native = vtable_entry(this, 21, "bool(__thiscall*)(void*, SteamNetworkingIdentity *, const char *)")
	function ISteamNetworkingUtils.SteamNetworkingIdentity_ParseString(pIdentity, pszStr)
		return SteamNetworkingIdentity_ParseString_native(this, pIdentity, pszStr)
	end
	ISteamNetworkingUtils.steam_networking_identity_parse_string = ISteamNetworkingUtils.SteamNetworkingIdentity_ParseString

	return ISteamNetworkingUtils
end

--
-- ISteamGameServerStats (SteamGameServerStats001, user created: false)
--

local ISteamGameServerStats = {version="SteamGameServerStats001",version_number=1}

index_funcs.ISteamGameServerStats = function()
	local this = vtable_bind("steamclient.dll", "SteamClient020", 14, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamGameServerStats001")

	local RequestUserStats_native = vtable_entry(this, 0, "uint64_t(__thiscall*)(void*, SteamID)")
	local RequestUserStats_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_steamIDUser;
			} *
		]]),
		keys = {m_eResult="result",m_steamIDUser="steamid_user"}
	}
	function ISteamGameServerStats.RequestUserStats(steamIDUser, callback)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = RequestUserStats_native(this, steamIDUser)

		if callback ~= nil then
			res = register_call_result(res, callback, 1800, RequestUserStats_info)
		end

		return res
	end
	ISteamGameServerStats.request_user_stats = ISteamGameServerStats.RequestUserStats

	local GetUserStatInt32_native = vtable_entry(this, 1, "bool(__thiscall*)(void*, SteamID, const char *, int32_t *)")
	function ISteamGameServerStats.GetUserStatInt32(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pData_out = new_int32_arr()
		local res = GetUserStatInt32_native(this, steamIDUser, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamGameServerStats.get_user_stat_int32 = ISteamGameServerStats.GetUserStatInt32

	local GetUserStatFloat_native = vtable_entry(this, 2, "bool(__thiscall*)(void*, SteamID, const char *, float *)")
	function ISteamGameServerStats.GetUserStatFloat(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pData_out = new_float_arr()
		local res = GetUserStatFloat_native(this, steamIDUser, pchName, pData_out)

		return res, DEREF_GCSAFE(pData_out)
	end
	ISteamGameServerStats.get_user_stat_float = ISteamGameServerStats.GetUserStatFloat

	local GetUserAchievement_native = vtable_entry(this, 3, "bool(__thiscall*)(void*, SteamID, const char *, bool *)")
	function ISteamGameServerStats.GetUserAchievement(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		local pbAchieved_out = new_bool_arr()
		local res = GetUserAchievement_native(this, steamIDUser, pchName, pbAchieved_out)

		return res, DEREF_GCSAFE(pbAchieved_out)
	end
	ISteamGameServerStats.get_user_achievement = ISteamGameServerStats.GetUserAchievement

	local SetUserStatInt32_native = vtable_entry(this, 4, "bool(__thiscall*)(void*, SteamID, const char *, int32_t)")
	function ISteamGameServerStats.SetUserStatInt32(steamIDUser, pchName, nData)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return SetUserStatInt32_native(this, steamIDUser, pchName, nData)
	end
	ISteamGameServerStats.set_user_stat_int32 = ISteamGameServerStats.SetUserStatInt32

	local SetUserStatFloat_native = vtable_entry(this, 5, "bool(__thiscall*)(void*, SteamID, const char *, float)")
	function ISteamGameServerStats.SetUserStatFloat(steamIDUser, pchName, fData)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return SetUserStatFloat_native(this, steamIDUser, pchName, fData)
	end
	ISteamGameServerStats.set_user_stat_float = ISteamGameServerStats.SetUserStatFloat

	local UpdateUserAvgRateStat_native = vtable_entry(this, 6, "bool(__thiscall*)(void*, SteamID, const char *, float, double)")
	function ISteamGameServerStats.UpdateUserAvgRateStat(steamIDUser, pchName, flCountThisSession, dSessionLength)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return UpdateUserAvgRateStat_native(this, steamIDUser, pchName, flCountThisSession, dSessionLength)
	end
	ISteamGameServerStats.update_user_avg_rate_stat = ISteamGameServerStats.UpdateUserAvgRateStat

	local SetUserAchievement_native = vtable_entry(this, 7, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamGameServerStats.SetUserAchievement(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return SetUserAchievement_native(this, steamIDUser, pchName)
	end
	ISteamGameServerStats.set_user_achievement = ISteamGameServerStats.SetUserAchievement

	local ClearUserAchievement_native = vtable_entry(this, 8, "bool(__thiscall*)(void*, SteamID, const char *)")
	function ISteamGameServerStats.ClearUserAchievement(steamIDUser, pchName)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		return ClearUserAchievement_native(this, steamIDUser, pchName)
	end
	ISteamGameServerStats.clear_user_achievement = ISteamGameServerStats.ClearUserAchievement

	local StoreUserStats_native = vtable_entry(this, 9, "uint64_t(__thiscall*)(void*, SteamID)")
	local StoreUserStats_info = {
		struct = typeof([[
			struct {
				int m_eResult;
				SteamID m_steamIDUser;
			} *
		]]),
		keys = {m_eResult="result",m_steamIDUser="steamid_user"}
	}
	function ISteamGameServerStats.StoreUserStats(steamIDUser, callback)
		steamIDUser = to_steamid_required(steamIDUser, "steamid_user is required")
		if callback ~= nil and not is_valid_callback(callback) then
			return error("Invalid callback, expected function or await")
		end

		local res = StoreUserStats_native(this, steamIDUser)

		if callback ~= nil then
			res = register_call_result(res, callback, 1801, StoreUserStats_info)
		end

		return res
	end
	ISteamGameServerStats.store_user_stats = ISteamGameServerStats.StoreUserStats

	return ISteamGameServerStats
end

--
-- some extensions for interfaces
--

index_funcs_extra.ISteamFriends = function()
	--
	-- SteamFriends002 stuff
	-- https://github.com/SteamRE/open-steamworks/blob/master/Open%20Steamworks/ISteamFriends002.h
	--
	local steamfriends002 = vtable_bind("steamclient.dll", "SteamClient020", 8, "void*(__thiscall*)(void*, int, int, const char *)")(hSteamUser, hSteamPipe, "SteamFriends002")

	local SetPersonaState_native = vtable_entry(steamfriends002, 3, "void(__thiscall*)(void*, int)")
	M.ISteamFriends.SetPersonaState = function(ePersonaState)
		ePersonaState = to_enum_required(ePersonaState, enums.EPersonaState, "ePersonaState is required")
		return SetPersonaState_native(steamfriends002, ePersonaState)
	end
	M.ISteamFriends.set_persona_state = M.ISteamFriends.SetPersonaState

	local AddFriend_native = vtable_entry(steamfriends002, 13, "bool(__thiscall*)(void*, SteamID)")
	M.ISteamFriends.AddFriend = function(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamIDFriend is required")
		return AddFriend_native(steamfriends002, steamIDFriend)
	end
	M.ISteamFriends.add_friend = M.ISteamFriends.AddFriend

	local RemoveFriend_native = vtable_entry(steamfriends002, 14, "bool(__thiscall*)(void*, SteamID)")
	M.ISteamFriends.RemoveFriend = function(steamIDFriend)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamIDFriend is required")
		return RemoveFriend_native(steamfriends002, steamIDFriend)
	end
	M.ISteamFriends.remove_friend = M.ISteamFriends.RemoveFriend

	local SendMsgToFriend_native = vtable_entry(steamfriends002, 19, "bool(__thiscall*)(void*, SteamID, int, const char*, int)")
	M.ISteamFriends.SendMsgToFriend = function(steamIDFriend, eFriendMsgType, pvMsgBody)
		steamIDFriend = to_steamid_required(steamIDFriend, "steamIDFriend is required")
		eFriendMsgType = to_enum_required(eFriendMsgType, enums.EChatEntryType, "eFriendMsgType is required")
		local cubMsgBody = string_len(pvMsgBody)
		return SendMsgToFriend_native(steamfriends002, steamIDFriend, eFriendMsgType, pvMsgBody, cubMsgBody)
	end
	M.ISteamFriends.send_msg_to_friend = M.ISteamFriends.SendMsgToFriend

	-- fix GetPersonaState
	local get_friend_persona_state = M.ISteamFriends.GetFriendPersonaState
	local my_steamid = M.ISteamUser.GetSteamID()

	M.ISteamFriends.GetPersonaState = function()
		return get_friend_persona_state(my_steamid)
	end
	M.ISteamFriends.get_persona_state = M.ISteamFriends.GetPersonaState
end

index_funcs_extra.ISteamMatchmaking = function()
	local matchframework001 = client.create_interface("matchmaking.dll", "MATCHFRAMEWORK_001")

	local GetMatchSession_native = vtable_entry(matchframework001, 13, "void*(__thiscall*)(void*)")
	local GetLobbyID_native = vtable_thunk(4, "SteamID(__thiscall*)(void*)")
	M.ISteamMatchmaking.GetLobbyID = function()
		local match_session = GetMatchSession_native(matchframework001)

		if match_session ~= nil then
			local lobby_steam_id = GetLobbyID_native(match_session)

			if lobby_steam_id.accountid > 0 then
				return lobby_steam_id
			end
		end
	end
end

index_funcs_extra.ISteamNetworkingUtils = function()
	local GetNetworkConfigURL_native = proc_bind("steamnetworkingsockets.dll", "SteamDatagram_GetNetworkConfigURL", "char *(__thiscall*)(unsigned int, unsigned int)")

	M.ISteamNetworkingUtils.SteamDatagram_GetNetworkConfigURL = function()
		local str = GetNetworkConfigURL_native()

		if str ~= nil then
			return ffi.string(str)
		end
	end
end

--
-- clean up everything on shutdown
--

client.set_event_callback("shutdown", function()
	for _, value in pairs(pending_call_results) do
		local instance = cast(callback_base_ptr, value)
		call_result_cancel(instance)
	end

	for _, instance_storage in pairs(registered_callbacks_instances) do
		local instance = cast(callback_base_ptr, instance_storage)
		SteamAPI_UnregisterCallback(instance)
	end
end)

--
-- return module back to user
--

return M
--[[
Lua Stream API 1.0.0
Created 2016 by Michael Karneim.
For detailed documentation on the Lua Stream API please see <http://github.com/mkarneim/lua-stream-api>.

  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org>

This function returns a sequential stream with the provided input as its source.
The input parameter must be nil or one of type table, boolean, number, string, or function.
* If input is of type table, then the the new stream is created from the elements of the table,
  assuming that the table is an array indexed with consecutive numbers from 1 to n, containing
  no nil values.
* If input is a single value of type boolean, number, or string, then the new stream contains
  just this value as its only element.
* If input if of type function, then the new stream is created with this function as its
  iterator function, which must be a parameterless function that produces the "next" element on
  each call.
* If input is nil (or not provided at all), then the new stream is empty.
--]]

local function stream(input)

	-- The following _* functions are internal functions that implement the stream's behaviour based
	-- on iterator functions.
	-- The documentation of these functions is obmitted since it can be easiy deduced from the
	-- documentation of the corresponding stream function at the end of this file.

	local function _iterator(input)
		if input == nil then
			error("input must be of type table, but was nil")
		elseif type(input)~="table" then
			error("input must be of type table, but was a "..type(input)..": "..input)
		end
		local len = #input
		local i = 0
		local result = function()
			i = i + 1
			if i > len then
				return nil
			else
				return input[i]
			end
		end
		return result
	end

	local function _next(iter)
		return iter()
	end

	local function _concat(itarr)
		local len = #itarr
		local i = 1
		local it = itarr[i]
		local result = function()
			if i > len then
				return nil
			else
				while true do
					local e = it()
					if e ~= nil then
						return e
					else
						i = i + 1
						if i > len then
							return nil
						else
							it = itarr[i]
						end
					end
				end
			end
		end
		return result
	end

	local function _peek(iter,c)
		if c == nil then
			error("c must be of type function, but was nil")
		end
		if type(c)~="function" then
			error("c must be of type function, but was a "..type(c))
		end
		local result = function()
			local e = iter()
			if e ~= nil then
				c(e)
			end
			return e
		end
		return result
	end

	local function _filter(iter,p)
		if p == nil then
			error("p must be of type function, but was nil")
		end
		if type(p)~="function" then
			error("p must be of type function, but was a "..type(p))
		end
		local result = function()
			local e = iter()
			while e ~= nil do
				if p(e) then
					return e
				else
					e = iter()
				end
			end
			return nil
		end
		return result
	end

	local function _pack(iter,n)
		return function()
			local result = nil
			for i=1,n do
				local e = iter()
				if e == nil then
					return result
				else
					if result == nil then
						result = {}
					end
					table.insert(result,e)
				end
			end
			return result
		end
	end

	local function _map(iter,f)
		if f == nil then
			error("f must be of type function, but was nil")
		end
		if type(f)~="function" then
			error("f must be of type function, but was a "..type(f))
		end
		local result = function()
			local e = iter()
			if e ~= nil then
				return f(e)
			else
				return nil
			end
		end
		return result
	end

	local function _flatmap(iter,f)
		if f == nil then
			error("f must be of type function, but was nil")
		end
		if type(f)~="function" then
			error("f must be of type function, but was a "..type(f))
		end
		local it = nil
		local result = function()
			while true do
				if it == nil then
					local e = iter()
					if e == nil then
						return nil
					else
						it = _iterator(f(e))
					end
				else
					local e = it()
					if e ~= nil then
						return e
					else
						it = nil
					end
				end
			end
		end
		return result
	end

	local function _flatten(iter)
		return _flatmap(iter, function(e) return e end)
	end

	local function _distinct(iter)
		local processed = {}
		local result = function()
			local e = iter()
			while e ~= nil do
				if processed[e]==nil then
					processed[e]=true
					return e
				else
					e = iter()
				end
			end
			return nil
		end
		return result
	end

	local function _limit(iter,max)
		local count = 0
		local result = function()
			count = count + 1
			if count > max then
				return nil
			else
				return iter()
			end
		end
		return result
	end

	local function _skip(iter,num)
		local i = 0
		while i<num do
			i = i + 1
			local e = iter()
			if e == nil then
				break
			end
		end
		return iter
	end

	local function _last(iter)
		local result = nil
		for e in iter do
			result = e
		end
		return result
	end

	local function _foreach(iter,c)
		if c == nil then
			error("c must be of type function, but was nil")
		end
		if type(c)~="function" then
			error("c must be of type function, but was a "..type(c))
		end
		for e in iter do
			c(e)
		end
	end

	local function _toarray(iter)
		local result = {}
		local i = 0
		for e in iter do
			i = i + 1
			result[i] = e
		end
		return result
	end

	local function _shuffle(iter)
		local result = _toarray(iter)
		local rand = math.random
		local iterations = #result
		local j
		for i = iterations, 2, -1 do
			j = rand(i)
			result[i], result[j] = result[j], result[i]
		end
		return _iterator(result)
	end

	local function _group(iter,f)
		if f == nil then
			error("f must be of type function, but was nil")
		end
		if type(f)~="function" then
			error("f must be of type function, but was a "..type(f))
		end
		local result = {}
		for e in iter do
			local key = f(e)
			local values = result[key]
			if values == nil then
				values = {}
				result[key] = values
			end
			values[#values+1] = e
		end
		return result
	end

	local function _split(iter,f)
		if f == nil then
			error("f must be of type function, but was nil")
		end
		if type(f)~="function" then
			error("f must be of type function, but was a "..type(f))
		end
		local a1 = {}
		local a2 = {}
		local function pull(match,amatch,anomatch)
			return function()
				if amatch[1] ~= nil then
					return table.remove(amatch,1)
				else
					local e = iter()
					while e ~= nil do
						if f(e) == match then
							return e
						else
							table.insert(anomatch,e)
							e = iter()
						end
					end
					return nil
				end
			end
		end
		local it1 = pull(true,a1,a2)
		local it2 = pull(false,a2,a1)
		return stream(it1), stream(it2)
	end

	local function _merge(itarr)
		local idx = 1
		return function()
			local len = #itarr
			if len == 0 then
				return nil
			end
			for i=1,len do
				if idx > len then
					idx = 1
				end
				local it = itarr[idx]
				local e = it()
				if e ~= nil then
					idx = idx + 1
					return e
				else
					table.remove(itarr, idx)
					len = #itarr
				end
			end

			local nilcount = 0
			local result = {}
			for i,it in ipairs(itarr) do
				local e = it()
				if e == nil then
					nilcount = nilcount + 1
				else
					result[i-nilcount] = e
				end
			end
			if nilcount >= #itarr then
				return nil
			else
				return result
			end
		end
	end

	local function _reduce(iter,init,op)
		if op == nil then
			error("op must be of type function, but was nil")
		end
		if type(op)~="function" then
			error("op must be of type function, but was a "..type(op))
		end
		local result = init
		for e in iter do
			result = op(result,e)
		end
		return result
	end

	local function _reverse(iter)
		local result = _toarray(iter)
		local len = #result
		for i=1, len/2 do
			result[i], result[len-i+1] = result[len-i+1], result[i]
		end
		return _iterator(result)
	end

	local function _sort(iter,comp)
		local result = _toarray(iter)
		table.sort(result,comp)
		return _iterator(result)
	end

	local function _count(iter)
		local result = 0
		for e in iter do
			result = result + 1
		end
		return result
	end

	local function _max(iter,comp)
		local result = nil
		for e in iter do
			if result == nil or (comp ~= nil and comp(result,e)) or result < e then
				result = e
			end
		end
		return result
	end

	local function _min(iter,comp)
		local result = nil
		for e in iter do
			if result == nil or (comp ~= nil and comp(e,result)) or e < result then
				result = e
			end
		end
		return result
	end

	local function _sum(iter)
		local result = 0
		for e in iter do
			result = result + e
		end
		return result
	end

	local function _avg(iter)
		local sum = 0
		local count = 0;
		for e in iter do
			count = count + 1
			sum = sum + e
		end
		if count == 0 then
			return nil
		else
			return sum/count
		end
	end

	local function _allmatch(iter,p)
		if p == nil then
			error("p must be of type function, but was nil")
		end
		if type(p)~="function" then
			error("p must be of type function, but was a "..type(p))
		end
		for e in iter do
			if not p(e) then
				return false
			end
		end
		return true
	end

	local function _anymatch(iter,p)
		if p == nil then
			error("p must be of type function, but was nil")
		end
		if type(p)~="function" then
			error("p must be of type function, but was a "..type(p))
		end
		for e in iter do
			if p(e) then
				return true
			end
		end
		return false
	end

	local function _nonematch(iter,p)
		return not _anymatch(iter,p)
	end

	-- Returns a new stream created form the given interator function.
	local function _stream(iter)
		local result = {
			-- Returns the iterator function for the elements of this stream.
			iter = function()
				return iter
			end,
			-- Returns the next (aka first) element of this stream, or nil if the stream is empty.
			next = function()
				return _next(iter)
			end,
			-- Returns a lazily concatenated stream whose elements are all the elements of this stream
			-- followed by all the elements of the streams provided by the varargs parameter.
			concat = function(...)
				local streams = {iter}
				for i,s in ipairs({...}) do
					streams[i+1] = s.iter()
				end
				return stream(_concat(streams))
			end,
			-- Returns a stream consisting of the elements of this stream, additionally performing
			-- the provided action on each element as elements are consumed from the resulting stream.
			peek = function(c)
				return stream(_peek(iter,c))
			end,
			-- Returns a stream consisting of the elements of this stream that match the given predicate.
			filter = function(p)
				return stream(_filter(iter,p))
			end,
			-- Returns a stream consisting of chunks, made of n adjacent elements of the original stream.
			pack = function(n)
				return stream(_pack(iter,n))
			end,
			-- Returns a stream consisting of the results of applying the given function
			-- to the elements of this stream.
			map = function(f)
				return stream(_map(iter,f))
			end,
			-- Returns a stream consisting of the flattened results
			-- produced by applying the provided mapping function on each element.
			flatmap = function(f)
				return stream(_flatmap(iter,f))
			end,
			-- Returns a stream consisting of the flattened elements.
			flatten = function()
				return stream(_flatten(iter))
			end,
			-- Returns a stream consisting of the elements of this stream,
			-- truncated to be no longer than maxsize in length.
			limit = function(maxsize)
				return stream(_limit(iter,maxsize))
			end,
			-- Returns a stream consisting of the remaining elements of this stream
			-- after discarding the first n elements of the stream. If this stream contains
			-- fewer than n elements then an empty stream will be returned.
			skip = function(n)
				return stream(_skip(iter,n))
			end,
			-- Returns the last element of this stream.
			last = function()
				return _last(iter)
			end,
			-- Performs the given action for each element of this stream.
			foreach = function(c)
				_foreach(iter,c)
			end,
			-- Returns an array containing the elements of this stream.
			toarray = function()
				return _toarray(iter)
			end,
			-- Returns a stream consisting of the elements of this stream, ordered randomly.
			-- Call math.randomseed( os.time() ) first to get nice random orders.
			shuffle = function()
				return stream(_shuffle(iter))
			end,
			-- Returns a table which is grouping the elements of this stream by keys provided from
			-- the specified classification function.
			group = function(f)
				return _group(iter,f)
			end,
			-- Returns two streams consisting of the elements of this stream
			-- separated by the given predicate.
			split = function(f)
				return _split(iter,f)
			end,
			-- Returns a lazily merged stream whose elements are all the elements of this stream
			-- and of the streams provided by the varargs parameter. The elements are taken from all
			-- streams round-robin.
			merge = function(...)
				local itarr = {iter}
				for i,s in ipairs({...}) do
					itarr[i+1] = s.iter()
				end
				return stream(_merge(itarr))
			end,
			-- Returns the result of the given collector that is supplied
			-- with an iterator for the elements of this stream.
			collect = function(c)
				return c(iter)
			end,
			-- Performs a reduction on the elements of this stream, using the provided initial value
			-- and the associative accumulation function, and returns the reduced value.
			reduce = function(init,op)
				return _reduce(iter,init,op)
			end,
			-- Returns a stream consisting of the elements of this stream in reversed order.
			reverse = function()
				return stream(_reverse(iter))
			end,
			-- Returns a stream consisting of the elements of this stream, sorted according to the
			-- provided comparator.
			-- See table.sort for details on the comp parameter.
			-- If comp is not given, then the standard Lua operator < is used.
			sort = function(comp)
				return stream(_sort(iter,comp))
			end,
			-- Returns a stream consisting of the distinct elements
			-- (according to the standard Lua operator ==) of this stream.
			distinct = function()
				return stream(_distinct(iter))
			end,
			-- Returns the count of elements in this stream.
			count = function()
				return _count(iter)
			end,
			-- Returns the maximum element of this stream according to the provided comparator,
			-- or nil if this stream is empty.
			-- See table.sort for details on the comp parameter.
			-- If comp is not given, then the standard Lua operator < is used.
			max = function(comp)
				return _max(iter,comp)
			end,
			-- Returns the minimum element of this stream according to the provided comparator,
			-- or nil if this stream is empty.
			-- See table.sort for details on the comp parameter.
			-- If comp is not given, then the standard Lua operator < is used.
			min = function(comp)
				return _min(iter,comp)
			end,
			-- Returns the sum of elements in this stream.
			sum = function()
				return _sum(iter)
			end,
			-- Returns the arithmetic mean of elements of this stream, or nil if this stream is empty.
			avg = function()
				return _avg(iter)
			end,
			-- Returns whether all elements of this stream match the provided predicate.
			-- If the stream is empty then true is returned and the predicate is not evaluated.
			allmatch = function(p)
				return _allmatch(iter,p)
			end,
			-- Returns whether any elements of this stream match the provided predicate.
			-- If the stream is empty then false is returned and the predicate is not evaluated.
			anymatch = function(p)
				return _anymatch(iter,p)
			end,
			-- Returns whether no elements of this stream match the provided predicate.
			-- If the stream is empty then true is returned and the predicate is not evaluated.
			nonematch = function(p)
				return _nonematch(iter,p)
			end
		}
		return result
	end

	-- create an appropriate stream depending on the input type
	if input==nil then
		return _stream(_iterator({}))
	elseif type(input)=="table" then
		return _stream(_iterator(input))
	elseif type(input)=="boolean" or type(input)=="number" or type(input)=="string" then
		return _stream(_iterator({input}))
	elseif type(input)=="function" then
		return _stream(input)
	else
		error("input must be nil or of type table, boolean, number, string, or function, but was a "..type(input))
	end
end

return stream;
local M = {}

local ffi = require "ffi"
local bit = require "bit"

local bit_bor = bit.bor
local ffi_string = ffi.string
local ffi_cast = ffi.cast

local function vmt_entry(instance, index, type)
	return ffi.cast(type, (ffi.cast("void***", instance)[0])[index])
end

-- instance is bound to the callback as an upvalue
local function vmt_bind(module, interface, index, typestring)
	local instance = client.create_interface(module, interface) or error("invalid interface")
	local success, typeof = pcall(ffi.typeof, typestring)
	if not success then
		error(typeof, 2)
	end
	local fnptr = vmt_entry(instance, index, typeof) or error("invalid vtable")
	return function(...)
		return fnptr(instance, ...)
	end
end

-- instance will be passed to the function at runtime
local function vmt_thunk(index, typestring)
	local t = ffi.typeof(typestring)
	return function(instance, ...)
		assert(instance ~= nil)
		if instance then
			return vmt_entry(instance, index, t)(instance, ...)
		end
	end
end

local new_charbuffer = ffi.typeof("char[?]")
local new_intptr = ffi.typeof("int[1]")
local new_widebuffer = ffi.typeof("wchar_t[?]")

-- localize
local native_Localize_ConvertAnsiToUnicode 	= vmt_bind("localize.dll", "Localize_001", 15, "int(__thiscall*)(void*, const char*, wchar_t*, int)")
local native_Localize_ConvertUnicodeToAnsi 	= vmt_bind("localize.dll", "Localize_001", 16, "int(__thiscall*)(void*, wchar_t*, char*, int)")
local native_Localize_FindSafe 							= vmt_bind("localize.dll", "Localize_001", 12, "wchar_t*(__thiscall*)(void*, const char*)")

-- surface
local native_Surface_DrawSetColor 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 15, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawFilledRect 			= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 16, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawOutlinedRect 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 18, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawLine 						= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 19, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawPolyLine 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 20, "void(__thiscall*)(void*, int*, int*, int)")
local native_Surface_DrawSetTextFont 			= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 23, "void(__thiscall*)(void*, unsigned long)")
local native_Surface_DrawSetTextColor 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 25, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawSetTextPos 			= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 26, "void(__thiscall*)(void*, int, int)")
local native_Surface_DrawPrintText 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 28, "void(__thiscall*)(void*, const wchar_t*, int, int)")
local native_Surface_DrawGetTextureId 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 34, "int(__thiscall*)(void*, const char*)") -- new
local native_Surface_DrawGetTextureFile 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 35, "bool(__thiscall*)(void*, int, char*, int)") -- new
local native_Surface_DrawSetTextureFile 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 36, "void(__thiscall*)(void*, int, const char*, int, bool)") -- new
local native_Surface_DrawSetTextureRGBA 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 37, "void(__thiscall*)(void*, int, const wchar_t*, int, int)") -- new
local native_Surface_DrawSetTexture 			= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 38, "void(__thiscall*)(void*, int)") -- new
local native_Surface_DeleteTextureByID 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 39, "void(__thiscall*)(void*, int)") -- new
local native_Surface_DrawGetTextureSize 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 40, "void(__thiscall*)(void*, int, int&, int&)") -- new
local native_Surface_DrawTexturedRect 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 41, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_IsTextureIDValid 		= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 42, "bool(__thiscall*)(void*, int)") -- new
local native_Surface_CreateNewTextureID 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 43, "int(__thiscall*)(void*, bool)") -- new
local native_Surface_UnlockCursor 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 66, "void(__thiscall*)(void*)")
local native_Surface_LockCursor 					= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 67, "void(__thiscall*)(void*)")
local native_Surface_CreateFont 					= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 71, "unsigned int(__thiscall*)(void*)")
local native_Surface_SetFontGlyph 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 72, "void(__thiscall*)(void*, unsigned long, const char*, int, int, int, int, unsigned long, int, int)")
local native_Surface_GetTextSize 					= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 79, "void(__thiscall*)(void*, unsigned long, const wchar_t*, int&, int&)")
local native_Surface_GetCursorPos 				= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 100, "unsigned int(__thiscall*)(void*, int*, int*)")
local native_Surface_SetCursorPos					= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 101, "unsigned int(__thiscall*)(void*, int, int)")
local native_Surface_DrawOutlinedCircle 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 103, "void(__thiscall*)(void*, int, int, int, int)")
local native_Surface_DrawFilledRectFade 	= vmt_bind("vguimatsurface.dll", "VGUI_Surface031", 123, "void(__thiscall*)(void*, int, int, int, int, unsigned int, unsigned int, bool)")

local function draw_print_text(text, localized)
	if localized then
		local cb_size = 1024
		local char_buffer = new_charbuffer(cb_size)
		native_Localize_ConvertUnicodeToAnsi(text, char_buffer, cb_size)

		local test = ffi_string(char_buffer)
		return native_Surface_DrawPrintText(text, test:len(), 0)
	else
		local wb_size = 1024
		local wide_buffer = new_widebuffer(wb_size)

		native_Localize_ConvertAnsiToUnicode(text, wide_buffer, wb_size)
		return native_Surface_DrawPrintText(wide_buffer, text:len(), 0)
	end
end

local function get_text_size(font, text)
	local wide_buffer = new_widebuffer(1024)
	local w_ptr = new_intptr()
	local h_ptr = new_intptr()

	native_Localize_ConvertAnsiToUnicode(text, wide_buffer, 1024)
	native_Surface_GetTextSize(font, wide_buffer, w_ptr, h_ptr)

	local w = tonumber(w_ptr[0])
	local h = tonumber(h_ptr[0])

	return w, h
end

--------------------------
-- renderer functions --
--------------------------

-- cache fonts since we cant delete them, so if multiple scripts create the same font they get the same ID
local font_cache = {}

function M.create_font(windows_font_name, tall, weight, flags)
	local flags_i = 0
	local t = type(flags)
	if t == "number" then
		flags_i = flags
	elseif t == "table" then
		for i=1, #flags do
			flags_i = flags_i + flags[i]
		end
	else
		error("invalid flags type, has to be number or table")
	end

	local cache_key = string.format("%s\0%d\0%d\0%d", windows_font_name, tall, weight, flags_i)
	if font_cache[cache_key] == nil then
		font_cache[cache_key] = native_Surface_CreateFont()
		native_Surface_SetFontGlyph(font_cache[cache_key], windows_font_name, tall, weight, 0, 0, bit_bor(flags_i), 0, 0)
	end

	return font_cache[cache_key]
end

function M.localize_string(str, buf_size)
	local res = native_Localize_FindSafe(str)
	local charbuffer = new_charbuffer(buf_size or 1024)
	native_Localize_ConvertUnicodeToAnsi(res, charbuffer, buf_size or 1024)
	return charbuffer and ffi_string(charbuffer) or nil
end

function M.draw_text(x, y, r, g, b, a, font, text)
	native_Surface_DrawSetTextPos(x, y)
	native_Surface_DrawSetTextFont(font)
	native_Surface_DrawSetTextColor(r, g, b, a)
	return draw_print_text(text, false)
end

function M.draw_localized_text(x, y, r, g, b, a, font, text)
	native_Surface_DrawSetTextPos(x, y)
	native_Surface_DrawSetTextFont(font)
	native_Surface_DrawSetTextColor(r, g, b, a)

	local localized_string = native_Localize_FindSafe(text)
	return draw_print_text(localized_string, true)
end

function M.draw_line(x0, y0, x1, y1, r, g, b, a)
	native_Surface_DrawSetColor(r, g, b, a)
	return native_Surface_DrawLine(x0, y0, x1, y1)
end

function M.draw_filled_rect(x, y, w, h, r, g, b, a)
	native_Surface_DrawSetColor(r, g, b, a)
	return native_Surface_DrawFilledRect(x, y, x + w, y + h)
end

function M.draw_outlined_rect(x, y, w, h, r, g, b, a)
	native_Surface_DrawSetColor(r, g, b, a)
	return native_Surface_DrawOutlinedRect(x, y, x + w, y + h)
end

function M.draw_filled_outlined_rect(x, y, w, h, r0, g0, b0, a0, r1, g1, b1, a1)
	native_Surface_DrawSetColor(r0, g0, b0, a0)
	native_Surface_DrawFilledRect(x, y, x + w, y + h)
	native_Surface_DrawSetColor(r1, g1, b1, a1)
	return native_Surface_DrawOutlinedRect(x, y, x + w, y + h)
end

function M.draw_filled_gradient_rect(x, y, w, h, r0, g0, b0, a0, r1, g1, b1, a1, horizontal)
	native_Surface_DrawSetColor(r0, g0, b0, a0)
	native_Surface_DrawFilledRectFade(x, y, x + w, y + h, 255, 255, horizontal)

	native_Surface_DrawSetColor(r1, g1, b1, a1)
	return native_Surface_DrawFilledRectFade(x, y, x + w, y + h, 0, 255, horizontal)
end

function M.draw_outlined_circle(x, y, r, g, b, a, radius, segments)
	native_Surface_DrawSetColor(r, g, b, a)
	return native_Surface_DrawOutlinedCircle(x, y, radius, segments)
end

function M.draw_poly_line(x, y, r, g, b, a, count)
	native_Surface_DrawSetColor(r, g, b, a)
	return native_Surface_DrawPolyLine(new_intptr(x), new_intptr(y), count)
end

function M.test_font(x, y, r, g, b, a, font)
	local _, height_offset = get_text_size(font, "a b c d e f g h i j k l m n o p q r s t u v w x y z")

	M.draw_text(x, y, r, g, b, a, font, "a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9  + #    , . -")
	M.draw_text(x, y + height_offset, r, g, b, a,  font, "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z = ! \"  $ % & / ( ) = ? { [ ] } \\ * ' _ : ; ~ ")
end

function M.get_text_size(font, text)
	return get_text_size(font, text)
end

function M.set_mouse_pos(x, y)
	return native_Surface_SetCursorPos(x, y)
end

function M.get_mouse_pos()
	local x_ptr = new_intptr()
	local y_ptr = new_intptr()

	native_Surface_GetCursorPos(x_ptr, y_ptr)

	local x = tonumber(x_ptr[0])
	local y = tonumber(y_ptr[0])

	return x, y
end

function M.unlock_cursor()
	return native_Surface_UnlockCursor()
end

function M.lock_cursor()
	return native_Surface_LockCursor()
end

function M.load_texture(filename)
	local texture = native_Surface_CreateNewTextureID(false)
	native_Surface_DrawSetTextureFile(texture, filename, true, true)

	local wide_ptr = new_intptr()
	local tall_ptr = new_intptr()
	native_Surface_DrawGetTextureSize(texture, wide_ptr, tall_ptr)

	local w = tonumber(wide_ptr[0])
	local h = tonumber(tall_ptr[0])

	return texture, w, h
end

-- fallback to built in renderer
setmetatable(M, {
	__index = renderer
})

return M
local ui_back = _G['ui'];
local ui = {};
ui.__index = ui;

function ui:add_callback(func)
    if (type(func) == 'function') then
        self.callbacks[#self.callbacks + 1] = func;
        self:process_callbacks();
    end
    return self;
end

function ui:add_children(children, value)
    if (getmetatable(children) == ui) then
        children = { children };
    end

    for i, child in pairs(children) do
        self.children[#self.children + 1] = {
            obj = child,
            value = value or true
        };
    end
    table.sort(self.children, function(a, b)
        return a.obj:ref() > b.obj:ref();
    end);
    self:process_callbacks();
end

function ui:process_callbacks(visible)
    local callback = function()
        local selfValue = self:get();
        for i = 1, #self.children do
            local child = self.children[i];
            local child_visible = type(child.value) == 'function' and child.value(self) or selfValue == child.value;
            child.obj:set_visible(child_visible);
            if (visible ~= nil) then
                child.obj:set_visible(visible and child_visible);
            end
            if (visible ~= nil) then
                child.obj:process_callbacks(visible and child_visible);
            else
                child.obj:process_callbacks(child_visible);
            end
        end

        for i = 1, #self.callbacks do
            local callback = self.callbacks[i];
            callback();
        end

        for i = 1, #self.events do
            local event = self.events[i];
            local registerValue = type(event.value) == 'function' and event.value(self) or selfValue == event.value;
            if (event.registered ~= registerValue) then
                client[(registerValue and '' or 'un') .. 'set_event_callback'](event.name, event.func);
                event.registered = registerValue;
            end
        end
    end
    local status, err = pcall(function()
        ui_back.get(self:ref());
    end)
    if(not err) then
        self:set_callback(callback);
        callback();
    end
end

function ui:get(i)
    if (self == nil) then
        return
    end
    if (i) then
        return ui_back.get(self.objs[i] or self);
    end

    local ret = {};
    for i = 1, #self.objs do
        local toRet = {};
        pcall(function()
            toRet = { ui_back.get(self.objs[i] or self) };
        end)
        for n = 1, #toRet do
            ret[#ret + 1] = toRet[n];
        end
    end
    return unpack(ret);
end

function ui:register(name, func, value)
    local index = #self.events + 1;
    self.events[index] = { registered = false, name = name, func = func, value = value or true }
    return index;
end

function ui:unregister(index)
    table.remove(self.events, index);
    return self;
end

function ui:compare(val, ignoreCase)
    local selfVal = self:get();
    return (ignoreCase and selfVal:lower() or selfVal) == val;
end

function ui:lower()
    return self:get():lower();
end

function ui:set(...)
    if (not self) then
        return
    end
    local item = type(self) ~= 'number' and self.objs[1] or self;
    if (item) then
        ui_back.set(item, ...);
    end
    return self;
end

function ui:set_index(i, ...)
    if (not self) then
        return
    end
    local item = type(self) ~= 'number' and self.objs[i] or self;
    if (item) then
        ui_back.set(item, ...);
    end
    return self;
end

function ui:update(...)
    local ret = {};
    for i = 1, #self.objs do
        local varargs = { ... };
        if (varargs[i] ~= nil) then
            ret[#ret + 1] = ui_back.update(self.objs[i] or self, varargs[i]);
        end
    end
    return self;
end

function ui:ref(i)
    return i and self.objs[i] or unpack(self.objs);
end

function ui:set_callback(...)
    local ret = {};
    for i = 1, #self.objs do
        local varargs = { ... };
        if (varargs[i] ~= nil) then
            ret[#ret + 1] = ui_back.set_callback(self.objs[i] or self, varargs[i]);
        end
    end
    return self;
end

function ui:set_visible(...)
    local ret = {};
    for i = 1, #self.objs do
        local varargs = { ... };
        if (varargs[i] ~= nil) then
            ret[#ret + 1] = ui_back.set_visible(self.objs[i] or self, varargs[i]);
        end
    end
    return self;
end

function ui:name(i)
    if (i) then
        return ui_back.name(self.objs[i] or self);
    end
    local ret = {};
    if (type(self) == 'number') then
        return ui_back.name(self);
    end
    for i = 1, #self.objs do
        ret[#ret + 1] = ui_back.name(self.objs[i] or self);
    end
    return unpack(ret);
end

-- Inits
local components = {
    'new_button',
    'new_checkbox',
    'new_color_picker',
    'new_combobox',
    'new_hotkey',
    'new_label',
    'new_listbox',
    'new_multiselect',
    'new_slider',
    'new_string',
    'new_textbox',
    'reference'
}

--- Init
---
function ui.new(...)
    return setmetatable({
        objs = { ... },
        children = {},
        callbacks = {},
        events = {}
    }, ui)
end

for i = 1, #components do
    local comp = components[i];
    ui[comp] = function(...)
        local args = { ... };
        local parent = args[1];
        if (getmetatable(parent) == ui) then
            table.remove(args, 1);
        else
            parent = nil;
        end

        --Handle adding of label before color pickers
        local generatedUIs = {};
        if (comp == components[3]) then
            local drawLabel = args[8];
            if (drawLabel) then
                generatedUIs[#generatedUIs + 1] = ui.new(ui_back['new_label'](unpack(args)));
            end
        end

        -- Create our UI Object
        local idx = #generatedUIs + 1;
        generatedUIs[idx] = ui.new(ui_back[comp](unpack(args)));

        if (parent) then
            parent:add_children(generatedUIs);
        end
        return generatedUIs[idx];
    end
end

--- Defaults
local defaults = {
    'is_menu_open',
    'menu_position',
    'menu_size',
    'mouse_position'
}
for i = 1, #defaults do
    local default = defaults[i];
    ui[default] = function(...)
        return ui_back[default](...);
    end
end

setmetatable(ui, { __call = function(_, ...)
    return ui.new(...)
end })

return ui;
local M = {}

local table_insert, table_concat, string_rep, string_len, string_sub = table.insert, table.concat, string.rep, string.len, string.sub
local math_max, math_floor, math_ceil = math.max, math.floor, math.ceil

local function len(str)
	local _, count = string.gsub(tostring(str), "[^\128-\193]", "")
	return count
end

local styles = {
	--					 1    2     3    4    5     6    7    8     9    10   11
	["ASCII"] = {"-", "|", "+"},
	["Compact"] = {"-", " ", " ", " ", " ", " ", " ", " "},
	["ASCII (Girder)"] = {"=", "||",  "//", "[]", "\\\\",  "|]", "[]", "[|",  "\\\\", "[]", "//"},
	["Unicode"] = {"", "",  "", "", "",  "", "", "",  "", "", ""},
	["Unicode (Single Line)"] = {"", "",  "", "", "",  "", "", "",  "", "", ""},
	["Markdown (Github)"] = {"-", "|", "|"}
}

--initialize missing style values (ascii etc)
for _, style in pairs(styles) do
	if #style == 3 then
		for j=4, 11 do
			style[j] = style[3]
		end
	end
end

local function justify_center(text, width)
	text = string_sub(text, 1, width)
	local length = len(text)
	return string_rep(" ", math_floor(width/2-length/2)) .. text .. string_rep(" ", math_ceil(width/2-length/2))
end

local function justify_left(text, width)
	text = string_sub(text, 1, width)
	return text .. string_rep(" ", width-len(text))
end

function M.generate_table(rows, headings, options)
	if type(options) == "string" or options == nil then
		options = {
			style=options or "ASCII",
		}
	end

	if options.top_line == nil then
		options.top_line = options.style ~= "Markdown (Github)"
	end

	if options.bottom_line == nil then
		options.bottom_line = options.style ~= "Markdown (Github)"
	end

	if options.header_seperator_line == nil then
		options.header_seperator_line = true
	end

	local seperators = styles[options.style] or styles["ASCII"]

	local rows_out, columns_width, columns_count = {}, {}, 0
	local has_headings = headings ~= nil and #headings > 0

	if has_headings then
		for i=1, #headings do
			columns_width[i] = len(headings[i])+2
		end
		columns_count = #headings
	else
		for i=1, #rows do
			columns_count = math_max(columns_count, #rows[i])
		end
	end

	for i=1, #rows do
		local row = rows[i]
		for c=1, columns_count do
			columns_width[c] = math_max(columns_width[c] or 2, len(row[c])+2)
		end
	end

	local column_seperator_rows = {}
	for i=1, columns_count do
		table_insert(column_seperator_rows, string_rep(seperators[1], columns_width[i]))
	end
	if options.top_line then
		table_insert(rows_out, seperators[3] .. table_concat(column_seperator_rows, seperators[4]) .. seperators[5])
	end

	if has_headings then
		local headings_justified = {}
		for i=1, columns_count do
			headings_justified[i] = justify_center(headings[i], columns_width[i])
		end
		table_insert(rows_out, seperators[2] .. table_concat(headings_justified, seperators[2]) .. seperators[2])
		if options.header_seperator_line then
			table_insert(rows_out, seperators[6] .. table_concat(column_seperator_rows, seperators[7]) .. seperators[8])
		end
	end

	for i=1, #rows do
		local row, row_out = rows[i], {}
		if #row == 0 then
			table_insert(rows_out, seperators[6] .. table_concat(column_seperator_rows, seperators[7]) .. seperators[8])
		else
			for j=1, columns_count do
				local justified = options.value_justify == "center" and justify_center(row[j] or "", columns_width[j]-2) or justify_left(row[j] or "", columns_width[j]-2)
				row_out[j] = " " .. justified .. " "
			end
			table_insert(rows_out, seperators[2] .. table_concat(row_out, seperators[2]) .. seperators[2])
		end
	end

	if options.bottom_line and seperators[9] then
		table_insert(rows_out, seperators[9] .. table_concat(column_seperator_rows, seperators[10]) .. seperators[11])
	end

	return table_concat(rows_out, "\n")
end

return setmetatable(M, {
	__call = function(_, ...)
		return M.generate_table(...)
	end
})
--------------------------------------------------------------------------------
-- Cache commonly used functions
--------------------------------------------------------------------------------
local setmetatable, error, client_set_event_callback, client_unset_event_callback, ui_get, ui_new_checkbox, pairs, ui_set, ui_set_callback, ui_set_visible = setmetatable, error, client.set_event_callback, client.unset_event_callback, ui.get, ui.new_checkbox, pairs, ui.set, ui.set_callback, ui.set_visible

--------------------------------------------------------------------------------
-- Constants and variables
--------------------------------------------------------------------------------
local OBJ_REFERENCE 	  = 0
local OBJ_CHANGE_CALLBACK = 1
local OBJ_EVENT_CALLBACKS = 2

local objects 		= {}
local ref_to_object = {}
local object_mt
local checkbox_mt

--------------------------------------------------------------------------------
-- Implementation
--------------------------------------------------------------------------------
local function proxy_to_object(proxy)
	return objects[proxy] or error("invalid object", 3)
end

local function reference_to_object(ref)
	return ref_to_object[ref] or error("invalid reference", 2)
end

local function make_proxy(ref)
	local obj = {}
	local proxy = setmetatable({}, object_mt)
	obj[OBJ_REFERENCE] = ref
	obj[OBJ_EVENT_CALLBACKS] = {}
	objects[proxy] = obj
	ref_to_object[ref] = obj
	return proxy
end

local function new_checkbox(...)
	local ref = ui_new_checkbox(...)
	if ref then
		local proxy = make_proxy(ref)
		return setmetatable(proxy, checkbox_mt)
	end
end

local function object_changed(ref)
	local value = ui_get(ref)
	local obj = reference_to_object(ref)
	local change_callback = obj[OBJ_CHANGE_CALLBACK]
	if change_callback then
		-- Invoke the change callback and pass the value of the object for ease of use
		change_callback(ref, value)
	end
	local event_callbacks = obj[OBJ_EVENT_CALLBACKS]
	if event_callbacks then
		local update_callback = value and client_set_event_callback or client_unset_event_callback
		for event_name, callback in pairs(event_callbacks) do
			update_callback(event_name, callback)
		end
	end
end

local function object_register_callback(proxy, event_name, callback)
	local obj = proxy_to_object(proxy)
	if event_name == "change" then
		obj[OBJ_CHANGE_CALLBACK] = callback
	else
		obj[OBJ_EVENT_CALLBACKS][event_name] = callback
	end
	object_changed(obj[OBJ_REFERENCE])
	ui_set_callback(obj[OBJ_REFERENCE], object_changed)
end

local function object_hide(proxy)
	local obj = proxy_to_object(proxy)
	ui_set_visible(obj[OBJ_REFERENCE], false)
end

local function object_show(proxy)
	local obj = proxy_to_object(proxy)
	ui_set_visible(obj[OBJ_REFERENCE], true)
end

local function object_get(proxy)
	local obj = proxy_to_object(proxy)
	return ui_get(obj[OBJ_REFERENCE])
end

local function object_set(proxy, value)
	local obj = proxy_to_object(proxy)
	ui_set(obj[OBJ_REFERENCE], value)
end

--------------------------------------------------------------------------------
-- Initilization code
--------------------------------------------------------------------------------
local function init()
	object_mt = {
		on 		= object_register_callback,
		hide 	= object_hide,
		show 	= object_show,
		get 	= object_get,
		set 	= object_set,
	}
	checkbox_mt = {
		__index = object_mt
	}
end

init()

--------------------------------------------------------------------------------
-- Return exposed functions
--------------------------------------------------------------------------------
return {
	new_checkbox = new_checkbox
}
--
-- dependencies
--

local ffi = require "ffi"
local typeof, sizeof, cast, ffi_string, ffi_gc, string_format = ffi.typeof, ffi.sizeof, ffi.cast, ffi.string, ffi.gc, string.format

--
-- helper functions
--

local function find_sig(mdlname, pattern, typename, offset, deref_count)
	local raw_match = client.find_signature(mdlname, pattern) or error("signature not found", 2)
	local match = cast("uintptr_t", raw_match)

	if offset ~= nil and offset ~= 0 then
		match = match + offset
	end

	if deref_count ~= nil then
		for i = 1, deref_count do
			match = cast("uintptr_t*", match)[0]
			if match == nil then
				return error("signature not found")
			end
		end
	end

	return cast(typename, match)
end

--
-- steam api
--

local register_call_result, register_callback
do
	if not pcall(ffi.sizeof, "SteamAPICall_t") then
		ffi.cdef[[
			typedef uint64_t SteamAPICall_t;

			struct SteamAPI_callback_base_vtbl {
				void(__thiscall *run1)(struct SteamAPI_callback_base *, void *, bool, uint64_t);
				void(__thiscall *run2)(struct SteamAPI_callback_base *, void *);
				int(__thiscall *get_size)(struct SteamAPI_callback_base *);
			};

			struct SteamAPI_callback_base {
				struct SteamAPI_callback_base_vtbl *vtbl;
				uint8_t flags;
				int id;
				uint64_t api_call_handle;
				struct SteamAPI_callback_base_vtbl vtbl_storage[1];
			};
		]]
	end

	local ESteamAPICallFailure = {
		[-1] = "No failure",
		[0]  = "Steam gone",
		[1]  = "Network failure",
		[2]  = "Invalid handle",
		[3]  = "Mismatched callback"
	}

	local SteamAPI_RegisterCallResult, SteamAPI_UnregisterCallResult
	local SteamAPI_RegisterCallback, SteamAPI_UnregisterCallback

	local callback_base        = typeof("struct SteamAPI_callback_base")
	local sizeof_callback_base = sizeof(callback_base)
	local callback_base_array  = typeof("struct SteamAPI_callback_base[1]")
	local callback_base_ptr    = typeof("struct SteamAPI_callback_base*")
	local uintptr_t            = typeof("uintptr_t")
	local api_call_handlers    = {}
	local pending_call_results = {}
	local registered_callbacks = {}

	local function pointer_key(p)
		return tostring(tonumber(cast(uintptr_t, p)))
	end

	local function callback_base_run_common(self, param, io_failure)
		-- prevent SteamAPI_UnregisterCallResult from being called for this callresult
		self.api_call_handle = 0

		local key = pointer_key(self)
		local handler = api_call_handlers[key]
		if handler ~= nil then
			xpcall(handler, client.error_log, param, io_failure)
		end

		if pending_call_results[key] ~= nil then
			api_call_handlers[key] = nil
			pending_call_results[key] = nil
		end
	end

	local function callback_base_run1(self, param, io_failure, api_call_handle)
		if api_call_handle == self.api_call_handle then
			callback_base_run_common(self, param, io_failure)
		end
	end

	local function callback_base_run2(self, param)
		callback_base_run_common(self, param, false)
	end

	local function callback_base_get_size(self)
		return sizeof_callback_base
	end

	local function call_result_cancel(self)
		if self.api_call_handle ~= 0 then
			SteamAPI_UnregisterCallResult(self, self.api_call_handle)
			self.api_call_handle = 0

			local key = pointer_key(self)
			api_call_handlers[key] = nil
			pending_call_results[key] = nil
		end
	end

	pcall(ffi.metatype, callback_base, {
		__gc = call_result_cancel,
		__index = {
			cancel = call_result_cancel
		}
	})

	local callback_base_run1_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *, bool, uint64_t)", callback_base_run1)
	local callback_base_run2_ct = cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *)", callback_base_run2)
	local callback_base_get_size_ct = cast("int(__thiscall *)(struct SteamAPI_callback_base *)", callback_base_get_size)

	function register_call_result(api_call_handle, handler, id)
		assert(api_call_handle ~= 0)
		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)

		instance.vtbl_storage[0].run1 = callback_base_run1_ct
		instance.vtbl_storage[0].run2 = callback_base_run2_ct
		instance.vtbl_storage[0].get_size = callback_base_get_size_ct
		instance.vtbl = instance.vtbl_storage
		instance.api_call_handle = api_call_handle
		instance.id = id

		local key = pointer_key(instance)
		api_call_handlers[key] = handler
		pending_call_results[key] = instance_storage

		SteamAPI_RegisterCallResult(instance, api_call_handle)

		return instance
	end

	function register_callback(id, handler)
		assert(registered_callbacks[id] == nil)

		local instance_storage = callback_base_array()
		local instance = cast(callback_base_ptr, instance_storage)

		instance.vtbl_storage[0].run1 = callback_base_run1_ct
		instance.vtbl_storage[0].run2 = callback_base_run2_ct
		instance.vtbl_storage[0].get_size = callback_base_get_size_ct
		instance.vtbl = instance.vtbl_storage
		instance.api_call_handle = 0
		instance.id = id

		local key = pointer_key(instance)
		api_call_handlers[key] = handler
		registered_callbacks[id] = instance_storage

		SteamAPI_RegisterCallback(instance, id)
	end

	local function vmt_entry(instance, index, type)
		return cast(type, (cast("void***", instance)[0])[index])
	end

	-- SteamAPI_RunCallbacks = find_sig("steam_api.dll", "\x32\xC9\x83\x3D\xCC\xCC\xCC\xCC\xCC", "void(__cdecl*)(void)")

	SteamAPI_RegisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xFF\x75\x10", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")
	SteamAPI_UnregisterCallResult = find_sig("steam_api.dll", "\x55\x8B\xEC\xFF\x75\x10\xFF\x75\x0C", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)")

	SteamAPI_RegisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x7E\x0D\x68\xCC\xCC\xCC\xCC\xFF\x15\xCC\xCC\xCC\xCC\x5D\xC3\xC7\x05", "void(__cdecl*)(struct SteamAPI_callback_base *, int)")
	SteamAPI_UnregisterCallback = find_sig("steam_api.dll", "\x55\x8B\xEC\x83\xEC\x08\x80\x3D", "void(__cdecl*)(struct SteamAPI_callback_base *)")

	client.set_event_callback("shutdown", function()
		for key, value in pairs(pending_call_results) do
			local instance = cast(callback_base_ptr, value)
			call_result_cancel(instance)
		end

		for key, value in pairs(registered_callbacks) do
			local instance = cast(callback_base_ptr, value)
			SteamAPI_UnregisterCallback(instance)
		end
	end)
end

--
-- ffi definitions
--

if not pcall(sizeof, "http_HHTMLBrowser") then
	ffi.cdef[[
		typedef uint32_t http_HHTMLBrowser;

		struct http_ISteamHTMLSurfaceVtbl {
			bool(__thiscall *ISteamHTMLSurface)(uintptr_t);
			bool(__thiscall *Init)(uintptr_t);
			bool(__thiscall *Shutdown)(uintptr_t);
			SteamAPICall_t(__thiscall *CreateBrowser)(uintptr_t, const char*, const char*);
			void(__thiscall *RemoveBrowser)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *LoadURL)(uintptr_t, http_HHTMLBrowser, const char*, const char*);
			void(__thiscall *SetSize)(uintptr_t, http_HHTMLBrowser, uint32_t, uint32_t);
			void(__thiscall *StopLoad)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *Reload)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *GoBack)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *GoForward)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *AddHeader)(uintptr_t, http_HHTMLBrowser, const char*, const char*);
			void(__thiscall *ExecuteJavascript)(uintptr_t, http_HHTMLBrowser, const char*);
			void(__thiscall *MouseUp)(uintptr_t, http_HHTMLBrowser, int);
			void(__thiscall *MouseDown)(uintptr_t, http_HHTMLBrowser, int);
			void(__thiscall *MouseDoubleClick)(uintptr_t, http_HHTMLBrowser, int);
			void(__thiscall *MouseMove)(uintptr_t, http_HHTMLBrowser, int, int);
			void(__thiscall *MouseWheel)(uintptr_t, http_HHTMLBrowser, int32_t);
			void(__thiscall *KeyDown)(uintptr_t, http_HHTMLBrowser, uint32_t, int, bool);
			void(__thiscall *KeyUp)(uintptr_t, http_HHTMLBrowser, uint32_t, int);
			void(__thiscall *KeyChar)(uintptr_t, http_HHTMLBrowser, uint32_t, int);
			void(__thiscall *SetHorizontalScroll)(uintptr_t, http_HHTMLBrowser, uint32_t);
			void(__thiscall *SetVerticalScroll)(uintptr_t, http_HHTMLBrowser, uint32_t);
			void(__thiscall *SetKeyFocus)(uintptr_t, http_HHTMLBrowser, bool);
			void(__thiscall *ViewSource)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *CopyToClipboard)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *PasteFromClipboard)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *Find)(uintptr_t, http_HHTMLBrowser, const char*, bool, bool);
			void(__thiscall *StopFind)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *GetLinkAtPosition)(uintptr_t, http_HHTMLBrowser, int, int);
			void(__thiscall *SetCookie)(uintptr_t, const char*, const char*, const char*, const char*, uint32_t, bool, bool);
			void(__thiscall *SetPageScaleFactor)(uintptr_t, http_HHTMLBrowser, float, int, int);
			void(__thiscall *SetBackgroundMode)(uintptr_t, http_HHTMLBrowser, bool);
			void(__thiscall *SetDPIScalingFactor)(uintptr_t, http_HHTMLBrowser, float);
			void(__thiscall *OpenDeveloperTools)(uintptr_t, http_HHTMLBrowser);
			void(__thiscall *AllowStartRequest)(uintptr_t, http_HHTMLBrowser, bool);
			void(__thiscall *JSDialogResponse)(uintptr_t, http_HHTMLBrowser, bool);
			void(__thiscall *FileLoadDialogResponse)(uintptr_t, http_HHTMLBrowser, const char**);
		};
	]]
end

--
-- constants
--

-- https://wiki.facepunch.com/steamworks/CallbackType
local CALLBACK_HTML_BrowserReady_t = 4501
local CALLBACK_HTML_NeedsPaint_t = 4502
local CALLBACK_HTML_StartRequest_t = 4503
local CALLBACK_HTML_CloseBrowser_t = 4504
local CALLBACK_HTML_URLChanged_t = 4505
local CALLBACK_HTML_FinishedRequest_t = 4506
local CALLBACK_HTML_OpenLinkInNewTab_t = 4507
local CALLBACK_HTML_ChangedTitle_t = 4508
local CALLBACK_HTML_SearchResults_t = 4509
local CALLBACK_HTML_CanGoBackAndForward_t = 4510
local CALLBACK_HTML_HorizontalScroll_t = 4511
local CALLBACK_HTML_VerticalScroll_t = 4512
local CALLBACK_HTML_LinkAtPosition_t = 4513
local CALLBACK_HTML_JSAlert_t = 4514
local CALLBACK_HTML_JSConfirm_t = 4515
local CALLBACK_HTML_FileOpenDialog_t = 4516
local CALLBACK_HTML_NewWindow_t = 4521
local CALLBACK_HTML_SetCursor_t = 4522
local CALLBACK_HTML_StatusText_t = 4523
local CALLBACK_HTML_ShowToolTip_t = 4524
local CALLBACK_HTML_UpdateToolTip_t = 4525
local CALLBACK_HTML_HideToolTip_t = 4526
local CALLBACK_HTML_BrowserRestarted_t = 4527

--
-- private functions
--

local function find_isteamhtmlsurface()
	local steam_client_context = find_sig(
		"client_panorama.dll",
		"\xB9\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x83\x3D\xCC\xCC\xCC\xCC\xCC\x0F\x84",
		"uintptr_t",
		1, 1
	)

	local steamhtmlsurface = cast("uintptr_t*", steam_client_context)[18]

	if steamhtmlsurface == 0 then
		return error("find_isteamhtmlsurface failed")
	end

	local vmt = cast("struct http_ISteamHTMLSurfaceVtbl**", steamhtmlsurface)[0]
	if vmt == nil then
		return error("find_isteamhtmlsurface failed")
	end

	return steamhtmlsurface, vmt
end

local function func_bind(func, arg)
	return function(...)
		return func(arg, ...)
	end
end

--
-- isteamhtmlsurface callback types
--

local HTML_BrowserReady_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
} *
]])

local HTML_StartRequest_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchURL;
	const char* pchTarget;
	const char* pchPostData;
	bool bIsRedirect;
} *
]])

local HTML_FinishedRequest_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchURL;
	const char* pchPageTitle;
} *
]])

local HTML_JSAlert_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchMessage;
} *
]])

local HTML_JSConfirm_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchMessage;
} *
]])

local HTML_ChangedTitle_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchTitle;
} *
]])

local HTML_URLChanged_t_ptr = typeof([[
struct {
	http_HHTMLBrowser unBrowserHandle;
	const char* pchURL;
	const char* pchPostData;
	bool bIsRedirect;
	const char* pchPageTitle;
	bool bNewNavigation;
} *
]])

--
-- get isteamhtmlsurface interface
--

local steam_htmlsurface, steam_htmlsurface_vtable = find_isteamhtmlsurface()

--
-- isteamhtmlsurface functions
--

local native_ISteamHTMLSurface_Init = func_bind(steam_htmlsurface_vtable.Init, steam_htmlsurface)
local native_ISteamHTMLSurface_Shutdown = func_bind(steam_htmlsurface_vtable.Shutdown, steam_htmlsurface)
local native_ISteamHTMLSurface_CreateBrowser = func_bind(steam_htmlsurface_vtable.CreateBrowser, steam_htmlsurface)
local native_ISteamHTMLSurface_RemoveBrowser = func_bind(steam_htmlsurface_vtable.RemoveBrowser, steam_htmlsurface)
local native_ISteamHTMLSurface_LoadURL = func_bind(steam_htmlsurface_vtable.LoadURL, steam_htmlsurface)
local native_ISteamHTMLSurface_SetSize = func_bind(steam_htmlsurface_vtable.SetSize, steam_htmlsurface)
local native_ISteamHTMLSurface_StopLoad = func_bind(steam_htmlsurface_vtable.StopLoad, steam_htmlsurface)
local native_ISteamHTMLSurface_Reload = func_bind(steam_htmlsurface_vtable.Reload, steam_htmlsurface)
local native_ISteamHTMLSurface_GoBack = func_bind(steam_htmlsurface_vtable.GoBack, steam_htmlsurface)
local native_ISteamHTMLSurface_GoForward = func_bind(steam_htmlsurface_vtable.GoForward, steam_htmlsurface)
local native_ISteamHTMLSurface_AddHeader = func_bind(steam_htmlsurface_vtable.AddHeader, steam_htmlsurface)
local native_ISteamHTMLSurface_ExecuteJavascript = func_bind(steam_htmlsurface_vtable.ExecuteJavascript, steam_htmlsurface)
local native_ISteamHTMLSurface_MouseUp = func_bind(steam_htmlsurface_vtable.MouseUp, steam_htmlsurface)
local native_ISteamHTMLSurface_MouseDown = func_bind(steam_htmlsurface_vtable.MouseDown, steam_htmlsurface)
local native_ISteamHTMLSurface_MouseDoubleClick = func_bind(steam_htmlsurface_vtable.MouseDoubleClick, steam_htmlsurface)
local native_ISteamHTMLSurface_MouseMove = func_bind(steam_htmlsurface_vtable.MouseMove, steam_htmlsurface)
local native_ISteamHTMLSurface_MouseWheel = func_bind(steam_htmlsurface_vtable.MouseWheel, steam_htmlsurface)
local native_ISteamHTMLSurface_KeyDown = func_bind(steam_htmlsurface_vtable.KeyDown, steam_htmlsurface)
local native_ISteamHTMLSurface_KeyUp = func_bind(steam_htmlsurface_vtable.KeyUp, steam_htmlsurface)
local native_ISteamHTMLSurface_KeyChar = func_bind(steam_htmlsurface_vtable.KeyChar, steam_htmlsurface)
local native_ISteamHTMLSurface_SetHorizontalScroll = func_bind(steam_htmlsurface_vtable.SetHorizontalScroll, steam_htmlsurface)
local native_ISteamHTMLSurface_SetVerticalScroll = func_bind(steam_htmlsurface_vtable.SetVerticalScroll, steam_htmlsurface)
local native_ISteamHTMLSurface_SetKeyFocus = func_bind(steam_htmlsurface_vtable.SetKeyFocus, steam_htmlsurface)
local native_ISteamHTMLSurface_ViewSource = func_bind(steam_htmlsurface_vtable.ViewSource, steam_htmlsurface)
local native_ISteamHTMLSurface_CopyToClipboard = func_bind(steam_htmlsurface_vtable.CopyToClipboard, steam_htmlsurface)
local native_ISteamHTMLSurface_PasteFromClipboard = func_bind(steam_htmlsurface_vtable.PasteFromClipboard, steam_htmlsurface)
local native_ISteamHTMLSurface_Find = func_bind(steam_htmlsurface_vtable.Find, steam_htmlsurface)
local native_ISteamHTMLSurface_StopFind = func_bind(steam_htmlsurface_vtable.StopFind, steam_htmlsurface)
local native_ISteamHTMLSurface_GetLinkAtPosition = func_bind(steam_htmlsurface_vtable.GetLinkAtPosition, steam_htmlsurface)
local native_ISteamHTMLSurface_SetCookie = func_bind(steam_htmlsurface_vtable.SetCookie, steam_htmlsurface)
local native_ISteamHTMLSurface_SetPageScaleFactor = func_bind(steam_htmlsurface_vtable.SetPageScaleFactor, steam_htmlsurface)
local native_ISteamHTMLSurface_SetBackgroundMode = func_bind(steam_htmlsurface_vtable.SetBackgroundMode, steam_htmlsurface)
local native_ISteamHTMLSurface_SetDPIScalingFactor = func_bind(steam_htmlsurface_vtable.SetDPIScalingFactor, steam_htmlsurface)
local native_ISteamHTMLSurface_OpenDeveloperTools = func_bind(steam_htmlsurface_vtable.OpenDeveloperTools, steam_htmlsurface)
local native_ISteamHTMLSurface_AllowStartRequest = func_bind(steam_htmlsurface_vtable.AllowStartRequest, steam_htmlsurface)
local native_ISteamHTMLSurface_JSDialogResponse = func_bind(steam_htmlsurface_vtable.JSDialogResponse, steam_htmlsurface)
local native_ISteamHTMLSurface_FileLoadDialogResponse = func_bind(steam_htmlsurface_vtable.FileLoadDialogResponse, steam_htmlsurface)

--
-- handle to our browser, forward declared
--

local browser_handle

--
-- communication with web page
--

local handlers = {}
local Client = {
	send = function(message)
		if browser_handle ~= nil then
			native_ISteamHTMLSurface_ExecuteJavascript(browser_handle, string.format("Client.receive(%s)", json.stringify(message)))
		end
	end,
	receive = function(message, transport)
		message = json.parse(message)

		-- print("received message: ", inspect(message))

		if handlers[message.type] ~= nil then
			handlers[message.type](message)
		end
	end,
	register_handler = function(type, callback)
		handlers[type] = callback
	end
}

-- rpc server
local rpc_functions = {}
local RPCServer = {
	register = function(name, callback)
		rpc_functions[name] = callback
	end
}

Client.register_handler("rpc", function(message)
	if rpc_functions[message.method] then
		local resp = {
			type = "rpc_resp",
			id = message.id
		}

		local success, ret = pcall(rpc_functions[message.method], unpack(message.params or {}))

		if success then
			resp.result = ret
		else
			resp.error = ret
		end

		Client.send(resp)
	end
end)

local pending_rpc_callbacks, rpc_index = {}, 0
local RPCClient = {
	call = function(method, callback, ...)
		rpc_index = rpc_index + 1

		local message = {
			type = "rpc",
			method = method,
			id = rpc_index
		}

		local args = {...}

		if #args > 0 then
			message.params = args
		end

		pending_rpc_callbacks[rpc_index] = callback
		Client.send(message)
	end
}

Client.register_handler("rpc_resp", function(resp)
	if pending_rpc_callbacks[resp.id] ~= nil then
		if resp.error ~= nil then
			xpcall(pending_rpc_callbacks[resp.id], client.error_log, resp.error)
		else
			xpcall(pending_rpc_callbacks[resp.id], client.error_log, nil, resp.result)
		end
	end
end)

--
-- browser implementation
--

-- creates a browser, loads our js and calls the callback when done
local function setup_browser(browser_ready_callback)
	-- setup the steam callbacks
	local js_string = [[
		// communication with client
		var Client = (function(){
			var handlers = {}
			var _SendMessage = function(message) {
				var json = JSON.stringify(message)

				// console.log(`sending ${json}`)

				if(json.length > 10200) {
					// alert has a size limit, so we need to use document.location.hash - should be rare since it has its own rate limiting too
					var ensureChangeChar = document.location.hash[1] == "h" ? "H" : "h"

					// setting location causes a HTML_ChangedTitle_t event (even if the title didnt actually change) so we set it to an empty string here and avoid that
					document.title = ""
					document.location.hash = ensureChangeChar + json

					// console.log("used hash with ensureChangeChar " + JSON.stringify(ensureChangeChar))
				} else if(json.length > 4090) {
					// alert has no rate limit but is rather slow (and limited to 10240 chars), so only use it if its required
					alert(json)
					// console.log("used alert")
				} else {
					// title has an even smaller size limit (4096), but its the fastest
					var ensureChangeChar = document.title[0] == "t" ? "T" : "t"
					document.title = ensureChangeChar + json
					// console.log("used title with ensureChangeChar " + JSON.stringify(ensureChangeChar) + " because title is " + JSON.stringify(document.title))
				}
			}

			var _RegisterHandler = function(type, callback) {
				handlers[type] = callback
			}

			var _ReceiveMessage = function(message) {
				if(handlers[message.type]) {
					handlers[message.type](message)
				}
			}

			return {
				send: _SendMessage,
				register_handler: _RegisterHandler,
				receive: _ReceiveMessage
			}
		})()

		var RPCServer = (function(){
			var rpc_functions = {}

			// internal func to handle incoming RPC messages
			var _RPCHandler = function(message) {
				if(rpc_functions[message.method]) {
					var resp = {
						type: "rpc_resp",
						id: message.id
					}

					try {
						var params = message.params || []

						resp.result = rpc_functions[message.method](...params)
					} catch (e) {
						resp.error = e.toString()
					}

					Client.send(resp)
				}
			}
			Client.register_handler("rpc", _RPCHandler)

			var _RegisterRPCFunction = function(name, callback) {
				rpc_functions[name] = callback
			}

			return {
				register: _RegisterRPCFunction
			}
		})()

		RPCServer.register("add", function(a, b){
			return a + b
		})

		var RPCClient = (function(){
			var index = 0
			var pending_requests = {}

			var _RPCRespHandler = function(message) {
				if(pending_requests[message.id]) {
					if(message.error) {
						pending_requests[message.id].reject(message.error)
					} else {
						pending_requests[message.id].resolve(message.result)
					}
					pending_requests[message.id] = null
				}
			}
			Client.register_handler("rpc_resp", _RPCRespHandler)

			var _Call = async function(method, params) {
				index += 1
				var req = {
					type: "rpc",
					method: method,
					id: index
				}

				if(params) {
					req.params = params
				}

				var result = new Promise((resolve, reject) => {
					pending_requests[index] = {resolve: resolve, reject: reject}
				})

				Client.send(req)

				return result
			}

			return {
				call: _Call
			}
		})()

		// websocket implementation
		var ws_api = (function(){
			var open_websockets = []
			var socket_index = 0

			var _OnOpen = function(index, e) {
				RPCClient.call("ws_open", [index, {extensions: e.target.extensions, protocol: e.target.protocol}])
			}

			var _OnMessage = function(index, e) {
				RPCClient.call("ws_message", [index, e.data])
			}

			var _OnClose = function(index, e) {
				RPCClient.call("ws_closed", [index, e.code, e.reason, e.wasClean])
				open_websockets[index] = null
			}

			var _OnError = function(index, error) {
				RPCClient.call("ws_error", [index])
			}

			RPCServer.register("ws_create", function(url, protocols){
				var index = socket_index++
				console.log(`creating websocket with index ${index}`)
				var socket = (typeof protocols != "undefined") ? (new WebSocket(url, protocols)) : (new WebSocket(url))

				socket.onopen = _OnOpen.bind(null, index)
				socket.onmessage = _OnMessage.bind(null, index)
				socket.onclose = _OnClose.bind(null, index)
				socket.onerror = _OnError.bind(null, index)

				open_websockets[index] = socket

				return index
			})

			RPCServer.register("ws_send", function(index, data){
				if(open_websockets[index]) {
					console.log("sending ", data)
					open_websockets[index].send(data)
				}
			})

			RPCServer.register("ws_close", function(index, code, reason){
				if(open_websockets[index]) {
					open_websockets[index].close(code, reason)
				}
			})
		})()

		RPCClient.call("browser_ready")
	]]

	local js_loaded = false

	local function browser_ready(param, io_failure)
		if param == nil then
			return
		end

		local data = cast(HTML_BrowserReady_t_ptr, param)

		if data.unBrowserHandle == nil then
			return
		end

		-- our browser is ready
		browser_handle = data.unBrowserHandle

		-- load blank page so we can load our js
		native_ISteamHTMLSurface_LoadURL(browser_handle, "about:blank", "")

		-- debug stuff yo
		-- native_ISteamHTMLSurface_OpenDeveloperTools(browser_handle)
	end

	-- required to allow navigation
	register_callback(CALLBACK_HTML_StartRequest_t, function(param, io_failure)
		if param == nil then return end

		local data = cast(HTML_StartRequest_t_ptr, param)

		if data.unBrowserHandle == browser_handle then
			native_ISteamHTMLSurface_AllowStartRequest(browser_handle, true)
			-- native_ISteamHTMLSurface_ExecuteJavascript(browser_handle, [[window.stop()]])
		end
	end)

	-- alert handler
	register_callback(CALLBACK_HTML_JSAlert_t, function(param, io_failure)
		if param == nil then return end

		local data = cast(HTML_JSAlert_t_ptr, param)

		if data.unBrowserHandle == browser_handle and data.pchMessage ~= nil then
			local message = ffi.string(data.pchMessage)

			Client.receive(message, "alert")
			native_ISteamHTMLSurface_JSDialogResponse(browser_handle, false)
		end
	end)

	register_callback(CALLBACK_HTML_ChangedTitle_t, function(param, io_failure)
		if param == nil then return end

		local data = cast(HTML_ChangedTitle_t_ptr, param)

		if data.unBrowserHandle == browser_handle and data.pchTitle ~= nil then
			local message = ffi.string(data.pchTitle)

			if js_loaded then
				message = message:gsub("^about:blank#", "")

				local first_char = message:sub(1, 1)

				if first_char == "t" or first_char == "T" then
					Client.receive(message:sub(2, -1), "changedtitle")
				end
			else
				if message == "about:blank" then
					native_ISteamHTMLSurface_ExecuteJavascript(browser_handle, js_string)

					js_loaded = true

					if browser_ready_callback ~= nil then
						xpcall(browser_ready_callback, client.error_log)
					end
				end
			end
		end
	end)

	register_callback(CALLBACK_HTML_URLChanged_t, function(param, io_failure)
		if param == nil then return end

		local data = cast(HTML_URLChanged_t_ptr, param)

		if data.unBrowserHandle == browser_handle and data.bNewNavigation == false and data.bIsRedirect == false and data.pchURL ~= nil then
			local pchURL = ffi.string(data.pchURL)

			if js_loaded then
				local sub = pchURL:sub(1, 13)

				-- make sure its a message dedicated to the hash
				if sub == "about:blank#h" or sub == "about:blank#H" then
					Client.receive(pchURL:sub(14, -1), "hash")
				end
			end
		end
	end)

	local call_handle = native_ISteamHTMLSurface_CreateBrowser(nil, nil)
	register_call_result(call_handle, browser_ready, CALLBACK_HTML_BrowserReady_t)

	client.set_event_callback("shutdown", function()
		if browser_handle ~= nil then
			native_ISteamHTMLSurface_RemoveBrowser(browser_handle)
			browser_handle = nil
		end
	end)
end

--
-- websocket client (lua) implementation
--

local open_websockets, open_websockets_data = {}, setmetatable({}, {__mode = "k"})

local function ws_rpc_callback(self, err, res)
	if err ~= nil then
		local ws_data = open_websockets_data[self]

		if ws_data ~= nil and ws_data.callback_error ~= nil then
			xpcall(ws_data.callback_error, client.error_log, self, err)
		end
	end
end

local websocket_mt = {
	__metatable = false
}
websocket_mt.__index = {
	close = function(self, code, reason)
		local ws_data = open_websockets_data[self]

		-- check if valid
		if ws_data == nil then return error("invalid websocket") end
		if not ws_data.open then return error("websocket not open") end

		RPCClient.call("ws_close", func_bind(ws_rpc_callback, self), ws_data.index, code, reason)
	end,
	send = function(self, data)
		local ws_data = open_websockets_data[self]

		-- check if valid
		if ws_data == nil then return error("invalid websocket") end
		if not ws_data.open then return error("websocket not open") end

		RPCClient.call("ws_send", func_bind(ws_rpc_callback, self), ws_data.index, tostring(data))
	end
}

--
-- websocket callbacks (rpc)
--

RPCServer.register("ws_open", function(index, event)
	local ws = open_websockets[index]
	local ws_data = open_websockets_data[ws]

	if ws_data ~= nil then
		ws.open = true
		ws_data.open = true

		ws.protocol = event.protocol
		ws.extensions = event.extensions

		if ws_data.callback_open ~= nil then
			xpcall(ws_data.callback_open, client.error_log, ws)
		end
	end
end)

RPCServer.register("ws_message", function(index, data)
	local ws = open_websockets[index]
	local ws_data = open_websockets_data[ws]

	if ws_data ~= nil then
		if ws_data.callback_message ~= nil then
			xpcall(ws_data.callback_message, client.error_log, ws, data)
		end
	end
end)

RPCServer.register("ws_closed", function(index, code, reason, was_clean)
	local ws = open_websockets[index]
	local ws_data = open_websockets_data[ws]

	if ws_data ~= nil then
		ws.open = false
		ws_data.open = false
		if ws_data.callback_close ~= nil then
			xpcall(ws_data.callback_close, client.error_log, ws, code, reason, was_clean)
		end

		open_websockets[index] = nil
		open_websockets_data[ws] = nil
	end
end)

RPCServer.register("ws_error", function(index, event)
	local ws = open_websockets[index]
	local ws_data = open_websockets_data[ws]

	if ws_data ~= nil then
		if ws_data.callback_error ~= nil then
			xpcall(ws_data.callback_error, client.error_log, ws)
		end
	end
end)

-- websocket data
local browser_ready_state, pending_websockets = 0, {}

local function create_websocket_impl(websocket, url, protocols, callbacks)
	local callback_error = callbacks.error

	-- save some data about it (internally and inaccessible to the user)
	open_websockets_data[websocket] = {
		open = false,
		callback_open = callbacks.open,
		callback_error = callback_error,
		callback_message = callbacks.message,
		callback_close = callbacks.close
	}

	-- actually call to js to create our websocket
	RPCClient.call("ws_create", function(err, index)
		if err then
			if callback_error ~= nil then
				xpcall(callback_error, client.error_log, websocket, err)
			end

			open_websockets_data[websocket] = nil

			return
		end

		-- websocket created successfully, save index for later
		open_websockets[index] = websocket
		open_websockets_data[websocket].index = index
	end, url, protocols)
end

local function create_websocket(url, options, callbacks)
	if callbacks == nil then
		callbacks = options
		options = nil
	end

	if type(url) ~= "string" then
		return error("Invalid url, has to be a string")
	end

	-- make sure callbacks are valid
	if type(callbacks) ~= "table" then
		return error("Invalid callbacks, has to be a table")
	elseif callbacks.open == nil or type(callbacks.open) ~= "function" then
		return error("Invalid callbacks, open callback has to be registered")
	elseif callbacks.open == nil and callbacks.error == nil and callbacks.message == nil and callbacks.close == nil then
		return error("Invalid callbacks, at least one callback has to be registered")
	elseif (callbacks.error ~= nil and type(callbacks.error) ~= "function") or (callbacks.message ~= nil and type(callbacks.message) ~= "function") or (callbacks.close ~= nil and type(callbacks.close) ~= "function") then
		return error("Invalid callbacks, all callbacks have to be functions")
	end

	-- parse options
	local protocols

	if type(options) == "table" then
		if type(options.protocols) == "string" then
			protocols = options.protocols
		elseif type(options.protocols) == "table" and #options.protocols > 0 then
			for i=1, #options.protocols do
				if type(options.protocols[i]) ~= "string" then
					return error("Invalid options.protocols, has to be an array of strings")
				end
			end
			protocols = options.protocols
		elseif options.protocols ~= nil then
			return error("Invalid options.protocols, has to be a string or array")
		end
	elseif options ~= nil then
		return error("Invalid options, has to be a table")
	end

	-- check if browser is ready
	if browser_ready_state == 0 then
		-- browser isnt ready, initialize it
		browser_ready_state = 1

		setup_browser(function()
			browser_ready_state = 2

			-- actually open pending websocket(s)
			for i=1, #pending_websockets do
				local pending_websocket = pending_websockets[i]
				xpcall(create_websocket_impl, client.error_log, pending_websocket.websocket, pending_websocket.url, pending_websocket.protocols, pending_websocket.callbacks)
			end
			pending_websockets = nil
		end)
	end

	-- create websocket open
	local websocket = setmetatable({
		url = url,
		open = false
	}, websocket_mt)

	if browser_ready_state ~= 2 then
		table.insert(pending_websockets, {websocket=websocket, url=url, protocols=protocols, callbacks=callbacks})
	else
		create_websocket_impl(websocket, url, protocols, callbacks)
	end

	-- give websocket handle to user
	return websocket
end

--
-- public module functions
--

local M = {
	connect = create_websocket
}

return M
